theory SKINNY_64_128
 imports
  "HOL-Library.Word"
  "HOL.Bit_Operations"
  "HOL.List"
begin

section ‹SKINNY Block Cipher (64-bit block, 128-bit key)›

subsection ‹Configuration and Types›

definition BLOCK_SIZE :: nat where "BLOCK_SIZE = 64"
definition KEY_SIZE :: nat where "KEY_SIZE = 128"
definition NUM_ROUNDS :: nat where "NUM_ROUNDS = 36"
definition CELL_BITS :: nat where "CELL_BITS = 4"
definition NUM_CELLS :: nat where "NUM_CELLS = 16"
definition TWEAK_SIZE :: nat where "TWEAK_SIZE = 2"

type_synonym state = "64 word"
type_synonym cell = "4 word"
type_synonym tweak_key = "state"
type_synonym tweak_key_list = "tweak_key list"
type_synonym round_key = "state"

definition MASK_CELL :: "4 word" where "MASK_CELL = 0xF"
definition MASK_BLOCK :: "64 word" where "MASK_BLOCK = word_of_int (2^64 - 1)"

subsection ‹Cell Access Helper Functions›

definition word_slice :: "nat ⇒ nat ⇒ 'a::len word ⇒ 'b::len word" where
  "word_slice start len w = 
      word_of_int ((uint w div 2^start) mod 2^len)"

definition get_cell :: "nat ⇒ state ⇒ cell" where
  "get_cell i s = word_slice (CELL_BITS * i) CELL_BITS s"

definition set_cell :: "nat ⇒ cell ⇒ state ⇒ state" where
  "set_cell i c s =
    (let
      shift_val = CELL_BITS * i;
      cell_mask_shifted = push_bit shift_val (ucast MASK_CELL :: state);
      clear_mask = not cell_mask_shifted;
      cleared_s = and s clear_mask;
      shifted_c = push_bit shift_val (ucast c :: state)
    in
      or cleared_s shifted_c)"

definition map_cells :: "(cell ⇒ cell) ⇒ state ⇒ state" where
  "map_cells f s =
    foldr (λi acc. set_cell i (f (get_cell i acc)) acc) [0..<NUM_CELLS] s"

subsection ‹SubCells (SC) Layer and Inverse›

definition sbox4_table :: "nat list" where "sbox4_table = [0xC, 0x6, 0x9, 0x0, 0x1, 0xA, 0x2, 0xB, 0x3, 0x8, 0x5, 0xD, 0x4, 0xE, 0x7, 0xF]"
definition sbox4_inv_table :: "nat list" where "sbox4_inv_table = [0x3, 0x4, 0x6, 0x8, 0xC, 0xA, 0x1, 0xE, 0x9, 0x2, 0x5, 0x7, 0x0, 0xB, 0xD, 0xF]" 

definition skinny_sbox :: "cell ⇒ cell" where
  "skinny_sbox x = (of_nat (sbox4_table ! unat x) :: cell)"

definition skinny_sbox_inv :: "cell ⇒ cell" where
  "skinny_sbox_inv x = (of_nat (sbox4_inv_table ! unat x) :: cell)"

definition sub_cells :: "state ⇒ state" where "sub_cells = map_cells skinny_sbox"
definition sub_cells_inv :: "state ⇒ state" where "sub_cells_inv = map_cells skinny_sbox_inv"

lemma sub_cells_inverse [simp]: "sub_cells_inv (sub_cells s) = s" sorry
lemma sub_cells_inverse_reverse [simp]: "sub_cells (sub_cells_inv s) = s" sorry

subsection ‹Add Round Constant (ARC) and Add Tweak-Key (ATK)›

definition round_constants_table :: "6 word list" where
  "round_constants_table = map of_nat [0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3E, 0x3D, 0x3B, 0x37, 0x2F, 0x1E, 0x3C, 0x39, 0x33, 0x27, 0x0E, 0x1D, 0x3A, 0x35, 0x2B, 0x16, 0x2C, 0x18, 0x30, 0x21, 0x02, 0x05, 0x0B, 0x17, 0x2E, 0x1C, 0x38, 0x31, 0x23, 0x06, 0x0D]"

definition add_round_constant :: "nat ⇒ state ⇒ state" where
"add_round_constant r s =
  (if r < NUM_ROUNDS then
    let 
      rc = round_constants_table ! r;
      c0 = and rc 0xF; 
      c1 = ucast (drop_bit 4 rc) :: cell;
      c2 = of_nat 0x2 :: cell
    in
      set_cell 0 (xor (get_cell 0 s) (ucast c0))
      (set_cell 4 (xor (get_cell 4 s) c1)
      (set_cell 8 (xor (get_cell 8 s) c2) s))
  else s)"

definition combine_tweak_keys :: "tweak_key_list ⇒ round_key" where
"combine_tweak_keys tks =
  (case tks of
    [tk1, tk2] ⇒
      foldr (λi acc.  
        let c1 = get_cell i tk1; c2 = get_cell i tk2; combined = xor c1 c2
        in set_cell i combined acc
      ) [0..<8] 0
  | _ ⇒ 0)"

definition add_tweak_key :: "tweak_key_list ⇒ state ⇒ state" where
"add_tweak_key tks s = xor s (combine_tweak_keys tks)"

definition add_tweak_key_call :: "state ⇒ tweak_key_list ⇒ state" where
"add_tweak_key_call s tks = add_tweak_key tks s"

definition add_tweak_key_call_inv :: "state ⇒ tweak_key_list ⇒ state" where
"add_tweak_key_call_inv s tks = add_tweak_key tks s"


definition skinny_lfsr :: "nat ⇒ cell ⇒ cell" where
"skinny_lfsr i c =
  (if i = 1 then 
    (let
      left_shift = push_bit 1 c;
      tap1 = drop_bit (CELL_BITS - 1) c;
      tap2 = drop_bit (CELL_BITS - 3) c
    in
      xor left_shift (xor tap1 tap2))
  else if i = 2 then 
    (let
      right_shift = drop_bit 1 c;
      tap1 = push_bit (CELL_BITS - 1) c;
      tap2 = push_bit 1 c
    in
      xor right_shift (xor tap1 tap2))
  else c)"

definition tk_update :: "nat ⇒ tweak_key ⇒ tweak_key" where
"tk_update i tk = 
  (let
    cells = map (λj. get_cell j tk) [0..<NUM_CELLS];

    tk_permuted_cells = [
      cells ! 9, cells ! 15, cells ! 8, cells ! 13, 
      cells ! 10, cells ! 14, cells ! 12, cells ! 11,
      cells ! 0, cells ! 1, cells ! 2, cells ! 3, 
      cells ! 4, cells ! 5, cells ! 6, cells ! 7
    ];
    updated_cells = 
      (if i = 0 then 
        tk_permuted_cells
      else
        let row2_lfsr = map (λc. skinny_lfsr i c) (take 4 (drop 8 tk_permuted_cells));
            row3_lfsr = map (λc. skinny_lfsr i c) (take 4 (drop 12 tk_permuted_cells));
            rows01 = take 8 tk_permuted_cells
        in
          rows01 @ row2_lfsr @ row3_lfsr)
  in
    foldr (λ(j,c) acc. set_cell j c acc) (zip [0..<NUM_CELLS] updated_cells) 0)"



fun build_key_schedule_single :: "tweak_key ⇒ nat ⇒ round_key list" where
  "build_key_schedule_single tk 0 = []"
| "build_key_schedule_single tk (Suc n) = tk # build_key_schedule_single (tk_update 0 tk) n"

fun build_key_schedule_double_list :: "tweak_key_list ⇒ nat ⇒ tweak_key_list list" where
  "build_key_schedule_double_list tks 0 = []"
| "build_key_schedule_double_list [tk1, tk2] (Suc n) =
    (let tk1' = tk_update 0 tk1; tk2' = tk_update 1 tk2 in
     [tk1, tk2] # build_key_schedule_double_list [tk1', tk2'] n)"
| "build_key_schedule_double_list _ (Suc n) = []"


definition key_schedule :: "tweak_key_list ⇒ tweak_key_list list" where
"key_schedule tks =
  (case tks of
    [tk1, tk2] ⇒ build_key_schedule_double_list [tk1, tk2] NUM_ROUNDS
  | _ ⇒ [])"

subsection ‹Shift Rows (SR) Layer and Inverse›

definition shift_rows_map :: "nat list" where
  "shift_rows_map = [0, 1, 2, 3, 5, 6, 7, 4, 10, 11, 8, 9, 15, 12, 13, 14]"

definition shift_rows_inv_map :: "nat list" where
  "shift_rows_inv_map = [0, 1, 2, 3, 7, 4, 5, 6, 10, 11, 8, 9, 13, 14, 15, 12]"

definition shift_rows :: "state ⇒ state" where
  "shift_rows s =
    (let
      cells = map (λi. get_cell i s) [0..<NUM_CELLS];
      permuted = map (λi. cells ! i) shift_rows_map
    in
      foldr (λ(i,c) acc. set_cell i c acc) (zip [0..<NUM_CELLS] permuted) 0)"

definition shift_rows_inv :: "state ⇒ state" where
  "shift_rows_inv s =
    (let
      cells = map (λi. get_cell i s) [0..<NUM_CELLS];
      permuted = map (λi. cells ! i) shift_rows_inv_map
    in
      foldr (λ(i,c) acc. set_cell i c acc) (zip [0..<NUM_CELLS] permuted) 0)"

lemma shift_rows_inverse [simp]: "shift_rows_inv (shift_rows s) = s" sorry

subsection ‹Mix Columns (MC) Layer and Inverse›

type_synonym column = "cell list"

definition mc_column_transform :: "column ⇒ column" where
"mc_column_transform cs =
  (let c0 = cs ! 0; c1 = cs ! 1; c2 = cs ! 2; c3 = cs ! 3 in
    [xor (xor c0 c2) c3, c0, xor c1 c2, xor c0 c2])"

definition mc_column_inv_transform :: "column ⇒ column" where
"mc_column_inv_transform cs =
  (let c0 = cs ! 0; c1 = cs ! 1; c2 = cs ! 2; c3 = cs ! 3 in
    [c1, xor (xor (xor c0 c1) c2) c3, xor (xor c0 c2) c3, xor c0 c1])"

definition mix_columns :: "state ⇒ state" where
"mix_columns s =
  (let
    get_col = λj. [get_cell j s, get_cell (j+4) s, get_cell (j+8) s, get_cell (j+12) s];

    col_0' = mc_column_transform (get_col 0);
    col_1' = mc_column_transform (get_col 1);
    col_2' = mc_column_transform (get_col 2);
    col_3' = mc_column_transform (get_col 3);

    new_cells = [col_0'!0, col_1'!0, col_2'!0, col_3'!0,
                 col_0'!1, col_1'!1, col_2'!1, col_3'!1,
                 col_0'!2, col_1'!2, col_2'!2, col_3'!2,
                 col_0'!3, col_1'!3, col_2'!3, col_3'!3]
  in
    foldr (λ(i,c) acc. set_cell i c acc) (zip [0..<NUM_CELLS] new_cells) 0)"

definition mix_columns_inv :: "state ⇒ state" where
"mix_columns_inv s =
  (let
    get_col = λj. [get_cell j s, get_cell (j+4) s, get_cell (j+8) s, get_cell (j+12) s];

    col_0' = mc_column_inv_transform (get_col 0);
    col_1' = mc_column_inv_transform (get_col 1);
    col_2' = mc_column_inv_transform (get_col 2);
    col_3' = mc_column_inv_transform (get_col 3);

    new_cells = [col_0'!0, col_1'!0, col_2'!0, col_3'!0,
                 col_0'!1, col_1'!1, col_2'!1, col_3'!1,
                 col_0'!2, col_1'!2, col_2'!2, col_3'!2,
                 col_0'!3, col_1'!3, col_2'!3, col_3'!3]
  in
    foldr (λ(i,c) acc. set_cell i c acc) (zip [0..<NUM_CELLS] new_cells) 0)"

lemma mix_columns_inverse [simp]: "mix_columns_inv (mix_columns s) = s" sorry

subsection ‹Tweak-Key Schedule and Cipher Implementation›

definition skinny_round :: "state ⇒ nat ⇒ tweak_key_list ⇒ state" where
"skinny_round ste r_num tk_list =
  mix_columns (shift_rows (add_tweak_key_call (add_round_constant r_num (sub_cells ste)) tk_list))"

definition skinny_round_inv :: "state ⇒ nat ⇒ tweak_key_list ⇒ state" where
"skinny_round_inv ste r_num tk_list =
  sub_cells_inv (
    add_round_constant r_num (
      add_tweak_key_call_inv (
        shift_rows_inv (
          mix_columns_inv ste
        )
      ) tk_list
    )
  )"

fun skinny_encrypt_iterate :: "state ⇒ tweak_key_list list ⇒ nat ⇒ state" where
  "skinny_encrypt_iterate state [] _ = state"
| "skinny_encrypt_iterate state (tk_list#tks) r_num =
    (if r_num = NUM_ROUNDS then state
    else skinny_encrypt_iterate (skinny_round state r_num tk_list) tks (r_num + 1))"

definition skinny_encrypt :: "state ⇒ tweak_key_list ⇒ state" where
  "skinny_encrypt plaintext tk_list =
    skinny_encrypt_iterate plaintext (key_schedule tk_list) 0"

fun skinny_decrypt_iterate :: "state ⇒ tweak_key_list list ⇒ nat ⇒ state" where
  "skinny_decrypt_iterate state [] _ = state"
| "skinny_decrypt_iterate state (tk_list#tks) r_num =
    (if r_num = NUM_ROUNDS then state
    else skinny_decrypt_iterate (skinny_round_inv state r_num tk_list) tks (r_num + 1))"

definition skinny_decrypt :: "state ⇒ tweak_key_list ⇒ state" where
  "skinny_decrypt ciphertext tk_list =
    skinny_decrypt_iterate ciphertext (rev (key_schedule tk_list)) 0"

theorem skinny_correctness:
  "skinny_decrypt (skinny_encrypt s k) k = s"
  sorry

end
