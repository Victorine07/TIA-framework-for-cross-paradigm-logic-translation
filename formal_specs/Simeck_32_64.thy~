theory Simeck_32_64
  imports
    "HOL-Library.Word"
    "HOL.Bit_Operations"
begin

section \<open>Simeck 32/64: Explicitly Named Definitions\<close>

subsection \<open>Sequence Generation\<close>

fun simeck_32_64_get_sequence_rec :: "nat \<Rightarrow> nat \<Rightarrow> bool list \<Rightarrow> bool list" where
  "simeck_32_64_get_sequence_rec 0 idx states = states"
| "simeck_32_64_get_sequence_rec (Suc n) idx states = (
    let feedback = (states ! idx) \<noteq> (states ! (idx + 2))
    in simeck_32_64_get_sequence_rec n (idx + 1) (states @ [feedback]))"


definition simeck_32_64_round_constants_sequence :: "bool list" where
  "simeck_32_64_round_constants_sequence = simeck_32_64_get_sequence_rec (32 - 5) 0 (replicate 5 True)"


subsection \<open>Core Round Functions\<close>

definition simeck_32_64_F_function :: "16 word \<Rightarrow> 16 word" where
  "simeck_32_64_F_function x = xor (and x (word_rotl 5 x)) (word_rotl 1 x)"


definition simeck_32_64_encrypt_round :: "16 word \<Rightarrow> 16 word \<times> 16 word \<Rightarrow> 16 word \<times> 16 word" where
  "simeck_32_64_encrypt_round k xy = (
    let (left, right) = xy in 
    (xor (xor (simeck_32_64_F_function left) right) k, left))"


definition simeck_32_64_decrypt_round_inverse :: "16 word \<Rightarrow> 16 word \<times> 16 word \<Rightarrow> 16 word \<times> 16 word" where
  "simeck_32_64_decrypt_round_inverse k xy_new = (
    let (left_new, right_new) = xy_new in 
    (right_new, xor (xor left_new k) (simeck_32_64_F_function right_new)))"


subsection \<open>Key Schedule Functions\<close>

definition simeck_32_64_key_schedule_constant :: "16 word" where
  "simeck_32_64_key_schedule_constant = 0xFFFC"


fun simeck_32_64_gen_key_schedule_rec :: "16 word list \<Rightarrow> bool list \<Rightarrow> 16 word list" where
  "simeck_32_64_gen_key_schedule_rec states [] = []"
| "simeck_32_64_gen_key_schedule_rec states (c#cs) = (
    let k_0 = states ! 0;
        left = states ! 1;
        right = states ! 0;
        round_const = xor simeck_32_64_key_schedule_constant (if c then 1 else 0);
        (new_left, new_right) = simeck_32_64_encrypt_round round_const (left, right);
        new_states = (tl states) @ [new_left]
    in k_0 # simeck_32_64_gen_key_schedule_rec (new_states[0 := new_right]) cs)"


definition simeck_32_64_generate_key_schedule :: "16 word list \<Rightarrow> 16 word list" where
  "simeck_32_64_generate_key_schedule initial_keys = 
     simeck_32_64_gen_key_schedule_rec initial_keys simeck_32_64_round_constants_sequence"


subsection \<open>Iteration Logic\<close>

fun simeck_32_64_encrypt_iterate :: "16 word \<times> 16 word \<Rightarrow> 16 word list \<Rightarrow> 16 word \<times> 16 word" where
  "simeck_32_64_encrypt_iterate state [] = state"
| "simeck_32_64_encrypt_iterate state (k#ks) = simeck_32_64_encrypt_iterate (simeck_32_64_encrypt_round k state) ks"


fun simeck_32_64_decrypt_iterate :: "16 word \<times> 16 word \<Rightarrow> 16 word list \<Rightarrow> 16 word \<times> 16 word" where
  "simeck_32_64_decrypt_iterate state ks = foldl (\<lambda>st_new k. simeck_32_64_decrypt_round_inverse k st_new) state (rev ks)"


subsection \<open>Block Encryption and Decryption\<close>

definition simeck_32_64_encrypt_block :: "16 word \<times> 16 word \<Rightarrow> 16 word list \<Rightarrow> 16 word \<times> 16 word" where
  "simeck_32_64_encrypt_block plaintext keys = simeck_32_64_encrypt_iterate plaintext keys"


definition simeck_32_64_decrypt_block :: "16 word \<times> 16 word \<Rightarrow> 16 word list \<Rightarrow> 16 word \<times> 16 word" where
  "simeck_32_64_decrypt_block ciphertext keys = simeck_32_64_decrypt_iterate ciphertext keys"


text \<open>Top-level functions using ucast and drop_bit/push_bit for slicing.\<close>

definition simeck_32_64_encrypt :: "32 word \<Rightarrow> 16 word list \<Rightarrow> 32 word" where
  "simeck_32_64_encrypt plaintext keys = (
    let left = ucast (drop_bit 16 plaintext);
        right = ucast plaintext;
        (c_left, c_right) = simeck_32_64_encrypt_block (left, right) keys
    in or (push_bit 16 (ucast c_left)) (ucast c_right))"


definition simeck_32_64_decrypt :: "32 word \<Rightarrow> 16 word list \<Rightarrow> 32 word" where
  "simeck_32_64_decrypt ciphertext keys = (
    let left = ucast (drop_bit 16 ciphertext);
        right = ucast ciphertext;
        (p_left, p_right) = simeck_32_64_decrypt_block (left, right) keys
    in or (push_bit 16 (ucast p_left)) (ucast p_right))"


end

