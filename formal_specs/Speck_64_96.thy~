theory Speck_64_96
  imports
    "HOL-Library.Word"
    "HOL.Bit_Operations"
begin

section ‹Speck 64/96: Core Definitions›

text ‹Configuration for 64/96: word_size = 32, alpha = 8, beta = 3, rounds = 26, m = 3›

definition speck_64_96_alpha :: nat where "speck_64_96_alpha = 8"


definition speck_64_96_beta :: nat where "speck_64_96_beta = 3"


definition speck_64_96_encrypt_round :: "32 word ⇒ 32 word × 32 word ⇒ 32 word × 32 word" where
  "speck_64_96_encrypt_round k xy = (
    let (x, y) = xy;
        rs_x = word_rotr speck_64_96_alpha x;
        add_xy = rs_x + y;
        new_x = xor add_xy k;
        ls_y = word_rotl speck_64_96_beta y;
        new_y = xor new_x ls_y
    in (new_x, new_y))"


definition speck_64_96_decrypt_round_inverse :: "32 word ⇒ 32 word × 32 word ⇒ 32 word × 32 word" where
  "speck_64_96_decrypt_round_inverse k xy_new = (
    let (x, y) = xy_new;
        xor_xy = xor x y;
        new_y = word_rotr speck_64_96_beta xor_xy;
        xor_xk = xor x k;
        msub = xor_xk - new_y;
        new_x = word_rotl speck_64_96_alpha msub
    in (new_x, new_y))"


function speck_64_96_gen_key_schedule_rec :: "32 word list ⇒ 32 word list ⇒ nat ⇒ 32 word list" where
  "speck_64_96_gen_key_schedule_rec l_keys k_keys i = (
     if i ≥ (26 - 1) then k_keys
     else
       let (new_l, new_k) = speck_64_96_encrypt_round (word_of_nat i) (l_keys ! i, k_keys ! i)
       in speck_64_96_gen_key_schedule_rec (l_keys @ [new_l]) (k_keys @ [new_k]) (i + 1))"
  by pat_completeness auto
termination by (relation "measure (λ(l, k, i). 25 - i)") auto


definition speck_64_96_generate_key_schedule :: "32 word list ⇒ 32 word list" where
  "speck_64_96_generate_key_schedule initial_key_words = (
     let k0 = [initial_key_words ! 0];
         l0 = [initial_key_words ! 1, initial_key_words ! 2]
     in speck_64_96_gen_key_schedule_rec l0 k0 0)"


subsection ‹Iteration, Block, and Top-Level Wrappers (64-bit Block)›

fun speck_64_96_encrypt_iterate :: "32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word" where
  "speck_64_96_encrypt_iterate state [] = state"
| "speck_64_96_encrypt_iterate state (k#ks) = speck_64_96_encrypt_iterate (speck_64_96_encrypt_round k state) ks"


fun speck_64_96_decrypt_iterate :: "32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word" where
  "speck_64_96_decrypt_iterate state ks = foldl (λst_new k. speck_64_96_decrypt_round_inverse k st_new) state (rev ks)"


definition speck_64_96_encrypt_block :: "32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word" where
  "speck_64_96_encrypt_block state keys = speck_64_96_encrypt_iterate state keys"


definition speck_64_96_decrypt_block :: "32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word" where
  "speck_64_96_decrypt_block state keys = speck_64_96_decrypt_iterate state keys"


definition speck_64_96_encrypt :: "64 word ⇒ 32 word list ⇒ 64 word" where
  "speck_64_96_encrypt plaintext keys = (
    let left = ucast (drop_bit 32 plaintext);
        right = ucast plaintext;
        (c_l, c_r) = speck_64_96_encrypt_block (left, right) keys
    in or (push_bit 32 (ucast c_l)) (ucast c_r))"


definition speck_64_96_decrypt :: "64 word ⇒ 32 word list ⇒ 64 word" where
  "speck_64_96_decrypt ciphertext keys = (
    let left = ucast (drop_bit 32 ciphertext);
        right = ucast ciphertext;
        (p_l, p_r) = speck_64_96_decrypt_block (left, right) keys
    in or (push_bit 32 (ucast p_l)) (ucast p_r))"


end