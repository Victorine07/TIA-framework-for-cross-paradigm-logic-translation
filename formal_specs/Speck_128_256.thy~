theory Speck_128_256
  imports
    "HOL-Library.Word"
    "HOL.Bit_Operations"
begin

section ‹Speck 128/256: Core Definitions›

text ‹Configuration for 128/256: word_size = 64, alpha = 8, beta = 3, rounds = 34, m = 4›

definition speck_128_256_alpha :: nat where "speck_128_256_alpha = 8"


definition speck_128_256_beta :: nat where "speck_128_256_beta = 3"


definition speck_128_256_encrypt_round :: "64 word ⇒ 64 word × 64 word ⇒ 64 word × 64 word" where
  "speck_128_256_encrypt_round k xy = (
    let (x, y) = xy;
        rs_x = word_rotr speck_128_256_alpha x;
        add_xy = rs_x + y;
        new_x = xor add_xy k;
        ls_y = word_rotl speck_128_256_beta y;
        new_y = xor new_x ls_y
    in (new_x, new_y))"


definition speck_128_256_decrypt_round_inverse :: "64 word ⇒ 64 word × 64 word ⇒ 64 word × 64 word" where
  "speck_128_256_decrypt_round_inverse k xy_new = (
    let (x, y) = xy_new;
        xor_xy = xor x y;
        new_y = word_rotr speck_128_256_beta xor_xy;
        xor_xk = xor x k;
        msub = xor_xk - new_y;
        new_x = word_rotl speck_128_256_alpha msub
    in (new_x, new_y))"


function speck_128_256_gen_key_schedule_rec :: "64 word list ⇒ 64 word list ⇒ nat ⇒ 64 word list" where
  "speck_128_256_gen_key_schedule_rec l_keys k_keys i = (
     if i ≥ (34 - 1) then k_keys
     else
       let (new_l, new_k) = speck_128_256_encrypt_round (word_of_nat i) (l_keys ! i, k_keys ! i)
       in speck_128_256_gen_key_schedule_rec (l_keys @ [new_l]) (k_keys @ [new_k]) (i + 1))"
  by pat_completeness auto
termination by (relation "measure (λ(l, k, i). 33 - i)") auto


definition speck_128_256_generate_key_schedule :: "64 word list ⇒ 64 word list" where
  "speck_128_256_generate_key_schedule initial_key_words = (
     let k0 = [initial_key_words ! 0];
         l0 = [initial_key_words ! 1, initial_key_words ! 2, initial_key_words ! 3]
     in speck_128_256_gen_key_schedule_rec l0 k0 0)"



subsection ‹Iteration, Block, and Top-Level Wrappers (128-bit Block)›

fun speck_128_256_encrypt_iterate :: "64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word" where
  "speck_128_256_encrypt_iterate state [] = state"
| "speck_128_256_encrypt_iterate state (k#ks) = speck_128_256_encrypt_iterate (speck_128_256_encrypt_round k state) ks"


fun speck_128_256_decrypt_iterate :: "64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word" where
  "speck_128_256_decrypt_iterate state ks = foldl (λst_new k. speck_128_256_decrypt_round_inverse k st_new) state (rev ks)"


definition speck_128_256_encrypt_block :: "64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word" where
  "speck_128_256_encrypt_block state keys = speck_128_256_encrypt_iterate state keys"


definition speck_128_256_decrypt_block :: "64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word" where
  "speck_128_256_decrypt_block state keys = speck_128_256_decrypt_iterate state keys"


definition speck_128_256_encrypt :: "128 word ⇒ 64 word list ⇒ 128 word" where
  "speck_128_256_encrypt plaintext keys = (
    let left = ucast (drop_bit 64 plaintext);
        right = ucast plaintext;
        (c_l, c_r) = speck_128_256_encrypt_block (left, right) keys
    in or (push_bit 64 (ucast c_l)) (ucast c_r))"


definition speck_128_256_decrypt :: "128 word ⇒ 64 word list ⇒ 128 word" where
  "speck_128_256_decrypt ciphertext keys = (
    let left = ucast (drop_bit 64 ciphertext);
        right = ucast ciphertext;
        (p_l, p_r) = speck_128_256_decrypt_block (left, right) keys
    in or (push_bit 64 (ucast p_l)) (ucast p_r))"


end