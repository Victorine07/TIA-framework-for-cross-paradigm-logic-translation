{"instruction": "Translate the LEA-128/128 Word Size Constant from Python to Isabelle/HOL. Apply these transformations: Use nat type for natural numbers, Define as explicit constant value.", "input": "# Word size in bits for LEA-128/128\nword_size = 32", "output": "definition lea_128_128_word_size :: nat where \"lea_128_128_word_size = 32\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "Word Size Constant", "variant": {"block_size": 128, "key_size": 128, "word_size": 32, "rounds": 24, "m": 4, "delta_count": 4}, "algorithm_params": {"has_self": false, "has_bitwise": false, "has_shifts": false, "has_loops": false, "has_conditionals": false, "has_arithmetic": true, "line_count": 2, "complexity": "low"}, "transformations": [], "difficulty": "easy", "extraction_time": "2026-01-24T13:11:27.397146"}}
{"instruction": "Translate the LEA-128/128 Rounds Constant from Python to Isabelle/HOL. Apply these transformations: Use nat type for natural numbers, Define as explicit constant value. Note: LEA uses parallel ARX operations (three updates in parallel).", "input": "# Number of rounds for LEA-128/128\nrounds = 24", "output": "definition lea_128_128_rounds    :: nat where \"lea_128_128_rounds = 24\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "Rounds Constant", "variant": {"block_size": 128, "key_size": 128, "word_size": 32, "rounds": 24, "m": 4, "delta_count": 4}, "algorithm_params": {"has_self": false, "has_bitwise": false, "has_shifts": false, "has_loops": false, "has_conditionals": false, "has_arithmetic": true, "line_count": 2, "complexity": "low"}, "transformations": [], "difficulty": "easy", "extraction_time": "2026-01-24T13:11:27.397595"}}
{"instruction": "Translate the LEA-128/128 M Constant from Python to Isabelle/HOL. Apply these transformations: Use nat type for natural numbers, Define as explicit constant value.", "input": "# Number of key words (m) for LEA-128/128\nm = 4", "output": "definition lea_128_128_m :: nat where \"lea_128_128_m = 4\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "M Constant", "variant": {"block_size": 128, "key_size": 128, "word_size": 32, "rounds": 24, "m": 4, "delta_count": 4}, "algorithm_params": {"has_self": false, "has_bitwise": false, "has_shifts": false, "has_loops": false, "has_conditionals": false, "has_arithmetic": true, "line_count": 2, "complexity": "low"}, "transformations": [], "difficulty": "easy", "extraction_time": "2026-01-24T13:11:27.398006"}}
{"instruction": "Translate the LEA-128/128 Rotation Primitive (Left) from Python to Isabelle/HOL. Apply these transformations: Use word_rotl for left rotation, Rotation amount is explicit parameter.", "input": "def lea_rol(x, r):\n    \"\"\"Left rotation of 32-bit word\"\"\"\n    mask = 0xFFFFFFFF\n    return ((x << r) | (x >> (32 - r))) & mask", "output": "definition  lea_128_128_rol :: \"32 word \\<Rightarrow> nat \\<Rightarrow> 32 word\" where\n  \" lea_128_128_rol x r = word_rotl r x\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "Rotation Primitive (Left)", "variant": {"block_size": 128, "key_size": 128, "word_size": 32, "rounds": 24, "m": 4, "delta_count": 4}, "algorithm_params": {"has_self": false, "has_bitwise": true, "has_shifts": true, "has_loops": false, "has_conditionals": false, "has_arithmetic": true, "line_count": 4, "complexity": "low"}, "transformations": [], "difficulty": "easy", "extraction_time": "2026-01-24T13:11:27.398491"}}
{"instruction": "Translate the LEA-128/128 Rotation Primitive (Right) from Python to Isabelle/HOL. Apply these transformations: Use word_rotr for right rotation, Rotation amount is explicit parameter.", "input": "def lea_ror(x, r):\n    \"\"\"Right rotation of 32-bit word\"\"\"\n    mask = 0xFFFFFFFF\n    return ((x >> r) | (x << (32 - r))) & mask", "output": "definition  lea_128_128_ror :: \"32 word \\<Rightarrow> nat \\<Rightarrow> 32 word\" where\n  \" lea_128_128_ror x r = word_rotr r x\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "Rotation Primitive (Right)", "variant": {"block_size": 128, "key_size": 128, "word_size": 32, "rounds": 24, "m": 4, "delta_count": 4}, "algorithm_params": {"has_self": false, "has_bitwise": true, "has_shifts": true, "has_loops": false, "has_conditionals": false, "has_arithmetic": true, "line_count": 4, "complexity": "low"}, "transformations": [], "difficulty": "easy", "extraction_time": "2026-01-24T13:11:27.398512"}}
{"instruction": "Translate the LEA-128/128 Delta Constants (128-bit subset) from Python to Isabelle/HOL. Apply these transformations: Use take function to get first n elements, Take 4 elements for this key size.", "input": "# LEA delta constants for 128-bit key (first 4 constants)\nDELTA_128 = DELTA[:4]", "output": "definition lea_128_128_delta_128 :: \"32 word list\" where\n  \"lea_128_128_delta_128 = take 4 lea_128_128_delta\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "Delta Constants (128-bit subset)", "variant": {"block_size": 128, "key_size": 128, "word_size": 32, "rounds": 24, "m": 4, "delta_count": 4}, "algorithm_params": {"has_self": false, "has_bitwise": false, "has_shifts": false, "has_loops": false, "has_conditionals": false, "has_arithmetic": true, "line_count": 2, "complexity": "low"}, "transformations": [], "difficulty": "easy", "extraction_time": "2026-01-24T13:11:27.399393"}}
{"instruction": "Translate the LEA-128/128 Key Extraction from Python to Isabelle/HOL. Apply these transformations: Use ucast for bit extraction, Use drop_bit for shifting right, Little-endian word order: least significant word first.", "input": "def lea_extract_key_words_128(key):\n    \"\"\"Extract 4 32-bit words from 128-bit key (little-endian)\"\"\"\n    mask = 0xFFFFFFFF\n    return [\n        key & 0xFFFFFFFF,               # Word 0 (LSB)\n        (key >> 32) & 0xFFFFFFFF,      # Word 1\n        (key >> 64) & 0xFFFFFFFF,      # Word 2\n        (key >> 96) & 0xFFFFFFFF       # Word 3 (MSB)\n    ]", "output": "definition lea_128_128_extract_key_words :: \"128 word \\<Rightarrow> 32 word list\" where\n  \"lea_128_128_extract_key_words k = \n    [ ucast k, \n      ucast (drop_bit 32 k), \n      ucast (drop_bit 64 k), \n      ucast (drop_bit 96 k) ]\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "Key Extraction", "variant": {"block_size": 128, "key_size": 128, "word_size": 32, "rounds": 24, "m": 4, "delta_count": 4}, "algorithm_params": {"has_self": false, "has_bitwise": true, "has_shifts": true, "has_loops": false, "has_conditionals": false, "has_arithmetic": true, "line_count": 9, "complexity": "medium"}, "transformations": [], "difficulty": "medium", "extraction_time": "2026-01-24T13:11:27.400242"}}
{"instruction": "Translate the LEA(128/128) Key Expansion Step from Python to Isabelle/HOL.", "input": "def lea_key_expansion_step_128(t, i):\n    \"\"\"LEA key expansion step for 128-bit key\"\"\"\n    # delta_count = 4\n    # Use delta[i % 4]\n    d = DELTA[i % 4]\n    \n    # Update key state with rotations\n    t0 = lea_rol((t[0] + lea_rol(d, i)) & 0xFFFFFFFF, 1)\n    t1 = lea_rol((t[1] + lea_rol(d, i + 1)) & 0xFFFFFFFF, 3)\n    t2 = lea_rol((t[2] + lea_rol(d, i + 2)) & 0xFFFFFFFF, 6)\n    t3 = lea_rol((t[3] + lea_rol(d, i + 3)) & 0xFFFFFFFF, 11)\n    \n    # Generate round key (LEA-128 specific pattern)\n    rk = [t0, t1, t2, t1, t3, t1]\n    \n    # Return round key and updated state\n    return rk, [t0, t1, t2, t3]", "output": "definition lea_128_128_step_key_expansion :: \"32 word list \\<Rightarrow> nat \\<Rightarrow> (32 word list \\<times> 32 word list)\" where\n  \"lea_128_128_step_key_expansion t i = (\n    let d = lea_128_128_delta_128 ! (i mod 4);\n        t0 =  lea_128_128_rol (t!0 +  lea_128_128_rol d i) 1;\n        t1 =  lea_128_128_rol (t!1 +  lea_128_128_rol d (i+1)) 3;\n        t2 =  lea_128_128_rol (t!2 +  lea_128_128_rol d (i+2)) 6;\n        t3 =  lea_128_128_rol (t!3 +  lea_128_128_rol d (i+3)) 11;\n        rk = [t0, t1, t2, t1, t3, t1]\n    in (rk, [t0, t1, t2, t3]))\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "Key Expansion Step", "variant": {"block_size": 128, "key_size": 128, "rounds": 24, "m": 4, "delta_size": 4, "word_size": 64, "block_words": 4, "round_keys_per_round": 6, "parallel_operations": 3, "rotation_offsets": [1, 3, 6, 11], "delta_sequence_index": [0, 1, 2, 3]}, "algorithm_params": {"has_self": false, "has_bitwise": true, "has_shifts": false, "has_loops": false, "has_conditionals": false, "has_arithmetic": true, "line_count": 17, "complexity": "high"}, "transformations": [], "difficulty": "medium", "extraction_time": "2026-01-24T13:11:27.400583"}}
{"instruction": "Translate the LEA(128/128) Recursive Key Generation from Python to Isabelle/HOL.", "input": "def lea_gen_round_keys_iter(t, i, acc):\n    \"\"\"Recursively generate LEA round keys\"\"\"\n    # rounds = 24\n    if i >= 24:\n        return acc\n    \n    # Generate round key for current round\n    rk, t_next = lea_key_expansion_step(t, i)\n    \n    # Recursive call for next round\n    return lea_gen_round_keys_iter(t_next, i + 1, acc + [rk])", "output": "function lea_128_128_gen_round_keys_iter :: \"32 word list \\<Rightarrow> nat \\<Rightarrow> 32 word list list \\<Rightarrow> 32 word list list\" where\n  \"lea_128_128_gen_round_keys_iter t i acc = (\n    if i \\<ge> lea_128_128_rounds then acc\n    else\n      let (rk, t_next) = lea_128_128_step_key_expansion t i\n      in lea_128_128_gen_round_keys_iter t_next (i + 1) (acc @ [rk]))\"\n  by pat_completeness auto\ntermination by (relation \"measure (\\<lambda>(_, i, _). lea_128_128_rounds - i)\") auto", "metadata": {"cipher": "lea", "family": "ARX", "component": "Recursive Key Generation", "variant": {"block_size": 128, "key_size": 128, "rounds": 24, "m": 4, "delta_size": 4, "word_size": 64, "block_words": 4, "round_keys_per_round": 6, "parallel_operations": 3, "rotation_offsets": [1, 3, 6, 11], "delta_sequence_index": [0, 1, 2, 3]}, "algorithm_params": {"has_self": false, "has_bitwise": false, "has_shifts": false, "has_loops": false, "has_conditionals": true, "has_arithmetic": true, "line_count": 11, "complexity": "medium"}, "transformations": [], "difficulty": "hard", "extraction_time": "2026-01-24T13:11:27.401013"}}
{"instruction": "Translate the LEA(128/128) Key Schedule Wrapper from Python to Isabelle/HOL.", "input": "def lea_generate_round_keys(key):\n    \"\"\"Generate LEA round keys from master key\"\"\"\n    # Extract initial key words\n    t0 = lea_extract_key_words(key)\n    \n    # Generate all round keys recursively\n    return lea_gen_round_keys_iter(t0, 0, [])", "output": "definition lea_128_128_generate_round_keys :: \"128 word \\<Rightarrow> 32 word list list\" where\n  \"lea_128_128_generate_round_keys key = \n    lea_128_128_gen_round_keys_iter (lea_128_128_extract_key_words key) 0 []\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "Key Schedule Wrapper", "variant": {"block_size": 128, "key_size": 128, "rounds": 24, "m": 4, "delta_size": 4, "word_size": 64, "block_words": 4, "round_keys_per_round": 6, "parallel_operations": 3, "rotation_offsets": [1, 3, 6, 11], "delta_sequence_index": [0, 1, 2, 3]}, "algorithm_params": {"has_self": false, "has_bitwise": false, "has_shifts": false, "has_loops": false, "has_conditionals": false, "has_arithmetic": false, "line_count": 7, "complexity": "medium"}, "transformations": [], "difficulty": "medium", "extraction_time": "2026-01-24T13:11:27.401332"}}
{"instruction": "Translate the LEA-128/128 Encrypt Round from Python to Isabelle/HOL. Apply these transformations: Use let expressions for state components, Apply XOR and addition in parallel, Use lea_rol/lea_ror for rotations, Shift x0 to x3 position. Note: LEA uses parallel ARX operations (three updates in parallel).", "input": "def lea_encrypt_round(state, rk):\n    \"\"\"LEA Parallel ARX Encrypt Round\"\"\"\n    x0, x1, x2, x3 = state\n    \n    # Three parallel ARX operations\n    next_x0 = lea_rol(((x0 ^ rk[0]) + (x1 ^ rk[1])) & 0xFFFFFFFF, 9)\n    next_x1 = lea_ror(((x1 ^ rk[2]) + (x2 ^ rk[3])) & 0xFFFFFFFF, 5)\n    next_x2 = lea_ror(((x2 ^ rk[4]) + (x3 ^ rk[5])) & 0xFFFFFFFF, 3)\n    \n    # Word shift: x0 moves to x3 position\n    next_x3 = x0\n    \n    return [next_x0, next_x1, next_x2, next_x3]", "output": "definition lea_128_128_encrypt_round :: \"32 word list \\<Rightarrow> 32 word list \\<Rightarrow> 32 word list\" where\n  \"lea_128_128_encrypt_round state rk = (\n    let x0 = state!0; x1 = state!1; x2 = state!2; x3 = state!3;\n        y0 =  lea_128_128_rol ((xor x0 (rk!0)) + (xor x1 (rk!1))) 9;\n        y1 =  lea_128_128_ror ((xor x1 (rk!2)) + (xor x2 (rk!3))) 5;\n        y2 =  lea_128_128_ror ((xor x2 (rk!4)) + (xor x3 (rk!5))) 3;\n        y3 = x0\n    in [y0, y1, y2, y3])\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "Encrypt Round", "variant": {"block_size": 128, "key_size": 128, "word_size": 32, "rounds": 24, "m": 4, "delta_count": 4}, "algorithm_params": {"has_self": false, "has_bitwise": true, "has_shifts": false, "has_loops": false, "has_conditionals": false, "has_arithmetic": true, "line_count": 13, "complexity": "medium"}, "transformations": [], "difficulty": "medium", "extraction_time": "2026-01-24T13:11:27.401957"}}
{"instruction": "Translate the LEA-128/128 Decrypt Round from Python to Isabelle/HOL. Apply these transformations: Note: decryption uses subtraction instead of addition, Apply inverse rotations (rol↔ror), Recover x0 from x3 position, Solve equations algebraically. Note: LEA uses parallel ARX operations (three updates in parallel).", "input": "def lea_decrypt_round(state, rk):\n    \"\"\"LEA Parallel ARX Decrypt Round (Inverse)\"\"\"\n    y0, y1, y2, y3 = state\n    \n    # Recover x0 from x3 position\n    x0 = y3\n    \n    # Solve parallel equations in reverse order\n    x1 = ((lea_ror(y0, 9) - (x0 ^ rk[0])) & 0xFFFFFFFF) ^ rk[1]\n    x2 = ((lea_rol(y1, 5) - (x1 ^ rk[2])) & 0xFFFFFFFF) ^ rk[3]\n    x3 = ((lea_rol(y2, 3) - (x2 ^ rk[4])) & 0xFFFFFFFF) ^ rk[5]\n    \n    return [x0, x1, x2, x3]", "output": "definition lea_128_128_decrypt_round :: \"32 word list \\<Rightarrow> 32 word list \\<Rightarrow> 32 word list\" where\n  \"lea_128_128_decrypt_round state rk = (\n    let y0 = state!0; y1 = state!1; y2 = state!2; y3 = state!3;\n        x0 = y3;\n        x1 = xor ( lea_128_128_ror y0 9 - (xor x0 (rk!0))) (rk!1);\n        x2 = xor ( lea_128_128_rol y1 5 - (xor x1 (rk!2))) (rk!3);\n        x3 = xor ( lea_128_128_rol y2 3 - (xor x2 (rk!4))) (rk!5)\n    in [x0, x1, x2, x3])\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "Decrypt Round", "variant": {"block_size": 128, "key_size": 128, "word_size": 32, "rounds": 24, "m": 4, "delta_count": 4}, "algorithm_params": {"has_self": false, "has_bitwise": true, "has_shifts": false, "has_loops": false, "has_conditionals": false, "has_arithmetic": true, "line_count": 13, "complexity": "medium"}, "transformations": [], "difficulty": "medium", "extraction_time": "2026-01-24T13:11:27.404089"}}
{"instruction": "Translate the LEA-128/128 Encrypt Block from Python to Isabelle/HOL. Apply these transformations: Python: (x >> (32*i)) & mask ↔ Isabelle: ucast (drop_bit (32*i) x), Python: (y << (32*i)) ↔ Isabelle: or (push_bit (32*i) (ucast y)), Little-endian word order: LSB is word[0].", "input": "def lea_encrypt_block(plaintext, rks):\n    \"\"\"LEA block encryption - matching Isabelle pattern\"\"\"\n    mask = 0xFFFFFFFF\n    # Python: (plaintext >> (32*i)) & 0xFFFFFFFF \n    mask = 0xFFFFFFFF\n    state = [\n        plaintext & 0xFFFFFFFF,                    \n        (plaintext >> 32) & 0xFFFFFFFF,           \n        (plaintext >> 64) & 0xFFFFFFFF,          \n        (plaintext >> 96) & 0xFFFFFFFF            \n    ]\n    \n    # Apply encryption rounds\n    cipher_state = lea_encrypt_iter(state, rks)\n    \n    # Python: (cipher_state[i] << (32*i))\n    # Isabelle: or (push_bit (32*i) (ucast (cipher_state[i])))\n    return (cipher_state[3] << 96) |            (cipher_state[2] << 64) |            (cipher_state[1] << 32) |            cipher_state[0]", "output": "definition lea_128_128_encrypt_block :: \n  \"128 word \\<Rightarrow> 32 word list list \\<Rightarrow> 128 word\" where\n  \"lea_128_128_encrypt_block plaintext rks = (\n    let state = [ucast plaintext, \n                 ucast (drop_bit 32 plaintext), \n                 ucast (drop_bit 64 plaintext), \n                 ucast (drop_bit 96 plaintext)];\n        res = lea_128_128_encrypt_iter state rks\n    in or (push_bit 96 (ucast (res!3))) \n          (or (push_bit 64 (ucast (res!2))) \n              (or (push_bit 32 (ucast (res!1))) \n                  (ucast (res!0)))))\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "Encrypt Block", "variant": {"block_size": 128, "key_size": 128, "word_size": 32, "rounds": 24, "m": 4, "delta_count": 4}, "algorithm_params": {"has_self": false, "has_bitwise": true, "has_shifts": true, "has_loops": false, "has_conditionals": false, "has_arithmetic": true, "line_count": 18, "complexity": "high"}, "transformations": [], "difficulty": "medium", "extraction_time": "2026-01-24T13:11:27.404636"}}
{"instruction": "Translate the LEA-128/128 Decrypt Block from Python to Isabelle/HOL. Apply these transformations: Same block splitting pattern as encryption, Same block combining pattern as encryption, Only difference is lea_decrypt_iter vs lea_encrypt_iter.", "input": "def lea_decrypt_block(ciphertext, rks):\n    \"\"\"LEA block decryption - matching Isabelle pattern\"\"\"\n    mask = 0xFFFFFFFF\n    # Same splitting as encryption\n    # Python: (plaintext >> (32*i)) & 0xFFFFFFFF \n    \n    mask = 0xFFFFFFFF\n    state = [\n        ciphertext & 0xFFFFFFFF,                    \n        (ciphertext >> 32) & 0xFFFFFFFF,           \n        (ciphertext >> 64) & 0xFFFFFFFF,           \n        (ciphertext >> 96) & 0xFFFFFFFF            \n    ]\n    \n    # Apply decryption rounds (reverse order): 96, 64, 32\n    plain_state = lea_decrypt_iter(state, rks)\n    \n    # Same combining as encryption\n    return (plain_state[3] << 96) |            (plain_state[2] << 64) |            (plain_state[1] << 32) |            plain_state[0]", "output": "definition lea_128_128_decrypt_block :: \n  \"128 word \\<Rightarrow> 32 word list list \\<Rightarrow> 128 word\" where\n  \"lea_128_128_decrypt_block ciphertext rks = (\n    let state = [ucast ciphertext, \n                 ucast (drop_bit 32 ciphertext), \n                 ucast (drop_bit 64 ciphertext), \n                 ucast (drop_bit 96 ciphertext)];\n        res = lea_128_128_decrypt_iter state rks\n    in or (push_bit 96 (ucast (res!3))) \n          (or (push_bit 64 (ucast (res!2))) \n              (or (push_bit 32 (ucast (res!1))) \n                  (ucast (res!0)))))\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "Decrypt Block", "variant": {"block_size": 128, "key_size": 128, "word_size": 32, "rounds": 24, "m": 4, "delta_count": 4}, "algorithm_params": {"has_self": false, "has_bitwise": true, "has_shifts": true, "has_loops": false, "has_conditionals": false, "has_arithmetic": true, "line_count": 19, "complexity": "high"}, "transformations": [], "difficulty": "medium", "extraction_time": "2026-01-24T13:11:27.405093"}}
{"instruction": "Translate the LEA-128/128 Encrypt Iteration from Python to Isabelle/HOL. Apply these transformations: Convert Python for-loop to recursive function, Use pattern matching: [] for empty list base case, Process round keys in forward order, Apply round function to head of list.", "input": "def lea_encrypt_iter(state, round_keys):\n    \"\"\"Iterate LEA encryption rounds (recursive)\"\"\"\n    if not round_keys:\n        return state\n    \n    # Apply one round\n    new_state = lea_encrypt_round(state, round_keys[0])\n    \n    # Recursively process remaining rounds\n    return lea_encrypt_iter(new_state, round_keys[1:])", "output": "fun lea_128_128_encrypt_iter :: \"32 word list \\<Rightarrow> 32 word list list \\<Rightarrow> 32 word list\" where\n  \"lea_128_128_encrypt_iter st [] = st\"\n| \"lea_128_128_encrypt_iter st (rk#rks) = lea_128_128_encrypt_iter (lea_128_128_encrypt_round st rk) rks\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "Encrypt Iteration", "variant": {"block_size": 128, "key_size": 128, "word_size": 32, "rounds": 24, "m": 4, "delta_count": 4}, "algorithm_params": {"has_self": false, "has_bitwise": false, "has_shifts": false, "has_loops": false, "has_conditionals": true, "has_arithmetic": false, "line_count": 10, "complexity": "medium"}, "transformations": [], "difficulty": "medium", "extraction_time": "2026-01-24T13:11:27.405374"}}
{"instruction": "Translate the LEA-128/128 Decrypt Iteration from Python to Isabelle/HOL. Apply these transformations: Convert Python reverse for-loop to foldl, Use rev function to reverse round key order, Apply decrypt_round in reverse order, Use foldl for iterative application.", "input": "def lea_decrypt_iter(state, round_keys):\n    \"\"\"Iterate LEA decryption rounds (foldl pattern)\"\"\"\n    # Process rounds in reverse order using foldl\n    from functools import reduce\n    \n    def apply_round(state, rk):\n        return lea_decrypt_round(state, rk)\n    \n    return reduce(apply_round, reversed(round_keys), state)", "output": "fun lea_128_128_decrypt_iter :: \"32 word list \\<Rightarrow> 32 word list list \\<Rightarrow> 32 word list\" where\n  \"lea_128_128_decrypt_iter st rks = foldl lea_128_128_decrypt_round st (rev rks)\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "Decrypt Iteration", "variant": {"block_size": 128, "key_size": 128, "word_size": 32, "rounds": 24, "m": 4, "delta_count": 4}, "algorithm_params": {"has_self": false, "has_bitwise": false, "has_shifts": false, "has_loops": false, "has_conditionals": false, "has_arithmetic": false, "line_count": 9, "complexity": "medium"}, "transformations": [], "difficulty": "medium", "extraction_time": "2026-01-24T13:11:27.405594"}}
{"instruction": "Translate the LEA-128/128 Top-Level Encrypt from Python to Isabelle/HOL. Apply these transformations: Generate round keys first, Call encrypt_block with round keys, Single function call for encryption.", "input": "def lea_encrypt(plaintext, key):\n    \"\"\"Top-level LEA encryption\"\"\"\n    # Generate round keys\n    round_keys = lea_generate_round_keys(key)\n    \n    # Encrypt block using pre-generated keys\n    return lea_encrypt_block(plaintext, round_keys)", "output": "definition lea_128_128_encrypt :: \n  \"128 word \\<Rightarrow> 128 word \\<Rightarrow> 128 word\" where\n  \"lea_128_128_encrypt plaintext key = \n    lea_128_128_encrypt_block plaintext (lea_128_128_generate_round_keys key)\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "Top-Level Encrypt", "variant": {"block_size": 128, "key_size": 128, "word_size": 32, "rounds": 24, "m": 4, "delta_count": 4}, "algorithm_params": {"has_self": false, "has_bitwise": false, "has_shifts": false, "has_loops": false, "has_conditionals": false, "has_arithmetic": true, "line_count": 7, "complexity": "medium"}, "transformations": [], "difficulty": "medium", "extraction_time": "2026-01-24T13:11:27.405821"}}
{"instruction": "Translate the LEA-128/128 Top-Level Decrypt from Python to Isabelle/HOL. Apply these transformations: Generate round keys (same as encryption), Call decrypt_block with round keys, Single function call for decryption.", "input": "def lea_decrypt(ciphertext, key):\n    \"\"\"Top-level LEA decryption\"\"\"\n    # Generate round keys (same as encryption)\n    round_keys = lea_generate_round_keys(key)\n    \n    # Decrypt block using pre-generated keys\n    return lea_decrypt_block(ciphertext, round_keys)", "output": "definition lea_128_128_decrypt :: \n  \"128 word \\<Rightarrow> 128 word \\<Rightarrow> 128 word\" where\n  \"lea_128_128_decrypt ciphertext key = \n    lea_128_128_decrypt_block ciphertext (lea_128_128_generate_round_keys key)\"", "metadata": {"cipher": "lea", "family": "ARX", "component": "Top-Level Decrypt", "variant": {"block_size": 128, "key_size": 128, "word_size": 32, "rounds": 24, "m": 4, "delta_count": 4}, "algorithm_params": {"has_self": false, "has_bitwise": false, "has_shifts": false, "has_loops": false, "has_conditionals": false, "has_arithmetic": true, "line_count": 7, "complexity": "medium"}, "transformations": [], "difficulty": "medium", "extraction_time": "2026-01-24T13:11:27.406038"}}
