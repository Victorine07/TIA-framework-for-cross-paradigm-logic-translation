{"instruction": "Translate the XTEA(64/128) Delta Constant from Python to Isabelle/HOL. Apply these transformations: Use hexadecimal notation, Define as 32-bit word. Note: Delta = 0x9E3779B9 = (√5-1)×2³¹ ≈ golden ratio × 2³¹.", "input": "delta = 0x9E3779B9  # XTEA constant", "output": "definition xtea_64_128_delta :: \"32 word\" where\n  \"xtea_64_128_delta = 0x9E3779B9\"", "metadata": {"component_type": "Delta Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "XTEA", "family": "Feistel", "extraction_time": "2026-01-24T13:11:27.526460", "variant": {"block_size": 64, "key_size": 128, "rounds": 32, "cycles_per_round": 2, "delta_constant": "0x9E3779B9", "word_size": 32, "key_words": 4, "structure": "Feistel-like with sum accumulation"}, "algorithm_params": {"cipher_family": "Block Cipher", "structure": "Modified Feistel Network", "operations": ["addition", "xor", "shift", "modular_addition"], "delta_usage": "Accumulated sum for key selection", "key_schedule": "Simple key splitting (no expansion)", "mix_function": "(x << 4) ^ (x >> 5)", "key_selection": "sum_val & 3 and (sum_val >> 11) & 3"}, "transformation_patterns": ["golden_ratio_constant", "hexadecimal_definition"]}}
{"instruction": "Translate the XTEA(64/128) Cycle Count from Python to Isabelle/HOL. Apply these transformations: Use nat type for cycles, Define as natural number. Note: XTEA uses 32 cycles (64 half-rounds) with sum accumulation.", "input": "num_cycles = 32  # Standard XTEA cycles", "output": "definition xtea_64_128_num_cycles :: nat where\n  \"xtea_64_128_num_cycles = 32\"", "metadata": {"component_type": "Cycle Count", "difficulty": "easy", "semantic_group": "constants", "cipher": "XTEA", "family": "Feistel", "extraction_time": "2026-01-24T13:11:27.526657", "variant": {"block_size": 64, "key_size": 128, "rounds": 32, "cycles_per_round": 2, "delta_constant": "0x9E3779B9", "word_size": 32, "key_words": 4, "structure": "Feistel-like with sum accumulation"}, "algorithm_params": {"cipher_family": "Block Cipher", "structure": "Modified Feistel Network", "operations": ["addition", "xor", "shift", "modular_addition"], "delta_usage": "Accumulated sum for key selection", "key_schedule": "Simple key splitting (no expansion)", "mix_function": "(x << 4) ^ (x >> 5)", "key_selection": "sum_val & 3 and (sum_val >> 11) & 3"}, "transformation_patterns": []}}
{"instruction": "Translate the XTEA(64/128) Key Splitting from Python to Isabelle/HOL. Apply these transformations: Convert Python list to Isabelle list, Use ucast for bit extraction, Use drop_bit for right shifts. Note: XTEA key is 128-bit, split into four 32-bit words with no expansion.", "input": "def split_key_128_to_32(key):\n    \"\"\"XTEA key schedule: split 128-bit key into four 32-bit words\"\"\"\n    mask = 0xFFFFFFFF\n    key_words = [\n        (key >> 96) & 0xFFFFFFFF,\n        (key >> 64) & 0xFFFFFFFF,\n        (key >> 32) & 0xFFFFFFFF,\n        key & mask\n    ]\n    return key_words", "output": "definition xtea_64_128_split_key :: \"128 word \\<Rightarrow> 32 word list\" where\n  \"xtea_64_128_split_key key = [\n    ucast (drop_bit 96 key),\n    ucast (drop_bit 64 key),\n    ucast (drop_bit 32 key),\n    ucast key\n  ]\"", "metadata": {"component_type": "Key Splitting", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "XTEA", "family": "Feistel", "extraction_time": "2026-01-24T13:11:27.527196", "variant": {"block_size": 64, "key_size": 128, "rounds": 32, "cycles_per_round": 2, "delta_constant": "0x9E3779B9", "word_size": 32, "key_words": 4, "structure": "Feistel-like with sum accumulation"}, "algorithm_params": {"cipher_family": "Block Cipher", "structure": "Modified Feistel Network", "operations": ["addition", "xor", "shift", "modular_addition"], "delta_usage": "Accumulated sum for key selection", "key_schedule": "Simple key splitting (no expansion)", "mix_function": "(x << 4) ^ (x >> 5)", "key_selection": "sum_val & 3 and (sum_val >> 11) & 3"}, "transformation_patterns": ["key_word_extraction", "bit_shifting_masking"]}}
{"instruction": "Translate the XTEA(64/128) Mix Function from Python to Isabelle/HOL. Apply these transformations: Use push_bit for left shift, Use drop_bit for right shift, Use xor for bitwise XOR. Note: Mix function: (x << 4) XOR (x >> 5) creates non-linearity.", "input": "def xtea_mix_function(x):\n    \"\"\"XTEA mix function: (x << 4) ^ (x >> 5)\"\"\"\n    return ((x << 4) ^ (x >> 5)) & 0xFFFFFFFF", "output": "definition xtea_64_128_mix_function :: \"32 word \\<Rightarrow> 32 word\" where\n  \"xtea_64_128_mix_function x = xor (push_bit 4 x) (drop_bit 5 x)\"", "metadata": {"component_type": "Mix Function", "difficulty": "easy", "semantic_group": "primitives", "cipher": "XTEA", "family": "Feistel", "extraction_time": "2026-01-24T13:11:27.527411", "variant": {"block_size": 64, "key_size": 128, "rounds": 32, "cycles_per_round": 2, "delta_constant": "0x9E3779B9", "word_size": 32, "key_words": 4, "structure": "Feistel-like with sum accumulation"}, "algorithm_params": {"cipher_family": "Block Cipher", "structure": "Modified Feistel Network", "operations": ["addition", "xor", "shift", "modular_addition"], "delta_usage": "Accumulated sum for key selection", "key_schedule": "Simple key splitting (no expansion)", "mix_function": "(x << 4) ^ (x >> 5)", "key_selection": "sum_val & 3 and (sum_val >> 11) & 3"}, "transformation_patterns": ["shift_xor_combination", "bitwise_operations"]}}
{"instruction": "Translate the XTEA(64/128) Encrypt Round from Python to Isabelle/HOL. Apply these transformations: Use let expressions for intermediate values, Convert Python list indexing to Isabelle ! operator, Use unat for converting words to natural numbers, Use and for bitwise AND with constants. Note: Each XTEA round consists of two half-rounds updating v0 and v1.", "input": "def xtea_encrypt_round(key_words, v0, v1, s_val):\n    \"\"\"Single XTEA cycle (2 half-rounds)\"\"\"\n    delta = 0x9E3779B9\n    mask = 0xFFFFFFFF\n    \n    # First half-round: update v0\n    k0 = key_words[s_val & 3]\n    v0 = (v0 + ((((v1 << 4) ^ (v1 >> 5)) + v1) ^ (s_val + k0))) & 0xFFFFFFFF\n    \n    # Update sum\n    new_sum = (s_val + 0x9E3779B9) & 0xFFFFFFFF\n    \n    # Second half-round: update v1\n    k1 = key_words[(new_sum >> 11) & 3]\n    v1 = (v1 + ((((v0 << 4) ^ (v0 >> 5)) + v0) ^ (new_sum + k1))) & 0xFFFFFFFF\n    \n    return v0, v1, new_sum", "output": "definition xtea_64_128_encrypt_round :: \n  \"32 word list \\<Rightarrow> 32 word \\<Rightarrow> 32 word \\<Rightarrow> 32 word \\<Rightarrow> (32 word \\<times> 32 word \\<times> 32 word)\" where\n  \"xtea_64_128_encrypt_round key_words v0 v1 s_val = (\n    let k0 = key_words ! (unat (and s_val 3));\n        mix_v1 = xtea_64_128_mix_function v1;\n        v0_new = v0 + (xor (mix_v1 + v1) (s_val + k0));\n        s_new = s_val + xtea_64_128_delta;\n        k1 = key_words ! (unat (and (drop_bit 11 s_new) 3));\n        mix_v0_new = xtea_64_128_mix_function v0_new;\n        v1_new = v1 + (xor (mix_v0_new + v0_new) (s_new + k1))\n    in (v0_new, v1_new, s_new))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "XTEA", "family": "Feistel", "extraction_time": "2026-01-24T13:11:27.527986", "variant": {"block_size": 64, "key_size": 128, "rounds": 32, "cycles_per_round": 2, "delta_constant": "0x9E3779B9", "word_size": 32, "key_words": 4, "structure": "Feistel-like with sum accumulation"}, "algorithm_params": {"cipher_family": "Block Cipher", "structure": "Modified Feistel Network", "operations": ["addition", "xor", "shift", "modular_addition"], "delta_usage": "Accumulated sum for key selection", "key_schedule": "Simple key splitting (no expansion)", "mix_function": "(x << 4) ^ (x >> 5)", "key_selection": "sum_val & 3 and (sum_val >> 11) & 3"}, "transformation_patterns": ["two_half_rounds", "sum_accumulation", "key_word_selection"]}}
{"instruction": "Translate the XTEA(64/128) Decrypt Round from Python to Isabelle/HOL. Apply these transformations: Note subtraction instead of addition, Same indexing pattern as encrypt round, Use previous sum (s_prev) for key selection. Note: Each XTEA round consists of two half-rounds updating v0 and v1.", "input": "def xtea_decrypt_round(key_words, v0, v1, s_val):\n    \"\"\"Inverse XTEA cycle (2 half-rounds)\"\"\"\n    delta = 0x9E3779B9\n    mask = 0xFFFFFFFF\n    \n    # First half-round: reverse v1\n    k1 = key_words[(s_val >> 11) & 3]\n    v1 = (v1 - ((((v0 << 4) ^ (v0 >> 5)) + v0) ^ (s_val + k1))) & 0xFFFFFFFF\n    \n    # Reverse sum\n    prev_sum = (s_val - 0x9E3779B9) & 0xFFFFFFFF\n    \n    # Second half-round: reverse v0\n    k0 = key_words[prev_sum & 3]\n    v0 = (v0 - ((((v1 << 4) ^ (v1 >> 5)) + v1) ^ (prev_sum + k0))) & 0xFFFFFFFF\n    \n    return v0, v1, prev_sum", "output": "definition xtea_64_128_decrypt_round :: \n  \"32 word list \\<Rightarrow> 32 word \\<Rightarrow> 32 word \\<Rightarrow> 32 word \\<Rightarrow> (32 word \\<times> 32 word \\<times> 32 word)\" where\n  \"xtea_64_128_decrypt_round key_words v0 v1 s_val = (\n    let k1 = key_words ! (unat (and (drop_bit 11 s_val) 3));\n        mix_v0 = xtea_64_128_mix_function v0;\n        v1_prev = v1 - (xor (mix_v0 + v0) (s_val + k1));\n        s_prev = s_val - xtea_64_128_delta;\n        k0 = key_words ! (unat (and s_prev 3));\n        mix_v1_prev = xtea_64_128_mix_function v1_prev;\n        v0_prev = v0 - (xor (mix_v1_prev + v1_prev) (s_prev + k0))\n    in (v0_prev, v1_prev, s_prev))\"", "metadata": {"component_type": "Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "XTEA", "family": "Feistel", "extraction_time": "2026-01-24T13:11:27.528545", "variant": {"block_size": 64, "key_size": 128, "rounds": 32, "cycles_per_round": 2, "delta_constant": "0x9E3779B9", "word_size": 32, "key_words": 4, "structure": "Feistel-like with sum accumulation"}, "algorithm_params": {"cipher_family": "Block Cipher", "structure": "Modified Feistel Network", "operations": ["addition", "xor", "shift", "modular_addition"], "delta_usage": "Accumulated sum for key selection", "key_schedule": "Simple key splitting (no expansion)", "mix_function": "(x << 4) ^ (x >> 5)", "key_selection": "sum_val & 3 and (sum_val >> 11) & 3"}, "transformation_patterns": ["two_half_rounds", "sum_accumulation", "key_word_selection"]}}
{"instruction": "Translate the XTEA(64/128) Encrypt Iteration from Python to Isabelle/HOL. Apply these transformations: Convert Python for-loop to recursive function, Use pattern matching for base case (0 cycles), Use Suc n for recursive case, Extract round results using let expression. Note: Encryption: sum starts at 0, accumulates delta. Decryption: starts at delta×32.", "input": "def xtea_encrypt_iterate(key_words, cycles, v0, v1, s_val=0):\n    \"\"\"Recursively apply XTEA encryption cycles\"\"\"\n    if cycles == 0:\n        return v0, v1\n    \n    # Apply one cycle\n    v0, v1, new_s = xtea_encrypt_round(key_words, v0, v1, s_val)\n    \n    # Recursive call for remaining cycles\n    return xtea_encrypt_iterate(key_words, cycles - 1, v0, v1, new_s)", "output": "fun xtea_64_128_encrypt_iterate :: \n  \"32 word list \\<Rightarrow> nat \\<Rightarrow> 32 word \\<Rightarrow> 32 word \\<Rightarrow> 32 word \\<Rightarrow> (32 word \\<times> 32 word)\" where\n  \"xtea_64_128_encrypt_iterate key_words 0 v0 v1 s = (v0, v1)\"\n| \"xtea_64_128_encrypt_iterate key_words (Suc n) v0 v1 s = (\n    let (v0', v1', s') = xtea_64_128_encrypt_round key_words v0 v1 s\n    in xtea_64_128_encrypt_iterate key_words n v0' v1' s')\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "XTEA", "family": "Feistel", "extraction_time": "2026-01-24T13:11:27.528813", "variant": {"block_size": 64, "key_size": 128, "rounds": 32, "cycles_per_round": 2, "delta_constant": "0x9E3779B9", "word_size": 32, "key_words": 4, "structure": "Feistel-like with sum accumulation"}, "algorithm_params": {"cipher_family": "Block Cipher", "structure": "Modified Feistel Network", "operations": ["addition", "xor", "shift", "modular_addition"], "delta_usage": "Accumulated sum for key selection", "key_schedule": "Simple key splitting (no expansion)", "mix_function": "(x << 4) ^ (x >> 5)", "key_selection": "sum_val & 3 and (sum_val >> 11) & 3"}, "transformation_patterns": ["loop_to_recursion", "sum_parameter_passing"]}}
{"instruction": "Translate the XTEA(64/128) Decrypt Iteration from Python to Isabelle/HOL. Apply these transformations: Convert Python for-loop to recursive function, Start with initial sum = delta * cycles, Use same recursive structure as encrypt iteration, Note: decryption uses decrypt_round instead of encrypt_round. Note: Encryption: sum starts at 0, accumulates delta. Decryption: starts at delta×32.", "input": "def xtea_decrypt_iterate(key_words, cycles, v0, v1, initial_sum):\n    \"\"\"Recursively apply XTEA decryption cycles\"\"\"\n    if cycles == 0:\n        return v0, v1\n    \n    # Apply one cycle\n    v0, v1, new_sum = xtea_decrypt_round(key_words, v0, v1, initial_sum)\n    \n    # Recursive call for remaining cycles\n    return xtea_decrypt_iterate(key_words, cycles - 1, v0, v1, new_sum)", "output": "fun xtea_64_128_decrypt_iterate :: \n  \"32 word list \\<Rightarrow> nat \\<Rightarrow> 32 word \\<Rightarrow> 32 word \\<Rightarrow> 32 word \\<Rightarrow> (32 word \\<times> 32 word)\" where\n  \"xtea_64_128_decrypt_iterate key_words 0 v0 v1 s = (v0, v1)\"\n| \"xtea_64_128_decrypt_iterate key_words (Suc n) v0 v1 s = (\n    let (v0', v1', s') = xtea_64_128_decrypt_round key_words v0 v1 s\n    in xtea_64_128_decrypt_iterate key_words n v0' v1' s')\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "XTEA", "family": "Feistel", "extraction_time": "2026-01-24T13:11:27.529055", "variant": {"block_size": 64, "key_size": 128, "rounds": 32, "cycles_per_round": 2, "delta_constant": "0x9E3779B9", "word_size": 32, "key_words": 4, "structure": "Feistel-like with sum accumulation"}, "algorithm_params": {"cipher_family": "Block Cipher", "structure": "Modified Feistel Network", "operations": ["addition", "xor", "shift", "modular_addition"], "delta_usage": "Accumulated sum for key selection", "key_schedule": "Simple key splitting (no expansion)", "mix_function": "(x << 4) ^ (x >> 5)", "key_selection": "sum_val & 3 and (sum_val >> 11) & 3"}, "transformation_patterns": ["loop_to_recursion", "sum_parameter_passing"]}}
{"instruction": "Translate the XTEA(64/128) Encrypt Block from Python to Isabelle/HOL. Apply these transformations: Split block using ucast and drop_bit, Call encrypt_iterate with initial sum = 0, Combine results using or and push_bit, Use let expressions to structure computation. Note: XTEA processes 64-bit blocks as two 32-bit words (v0, v1).", "input": "def xtea_encrypt_block(key, plaintext):\n    \"\"\"XTEA block encryption (64-bit block, 128-bit key)\"\"\"\n    # Split key\n    key_words = split_key_128_to_32(key)\n    \n    # Split plaintext\n    mask = 0xFFFFFFFF\n    v0 = (plaintext >> 32) & 0xFFFFFFFF\n    v1 = plaintext & 0xFFFFFFFF\n    \n    # Encrypt\n    v0_final, v1_final = xtea_encrypt_iterate(split_key_128_to_32(key), 32, v0, v1)\n    \n    # Combine\n    return (v0_final << 32) | v1_final", "output": "definition xtea_64_128_encrypt_block :: \n  \"128 word \\<Rightarrow> 64 word \\<Rightarrow> 64 word\" where\n  \"xtea_64_128_encrypt_block key plaintext = (\n    let key_words = xtea_64_128_split_key key;\n        v0 = ucast (drop_bit 32 plaintext);\n        v1 = ucast plaintext;\n        (v0_final, v1_final) = xtea_64_128_encrypt_iterate key_words xtea_64_128_num_cycles v0 v1 0\n    in or (push_bit 32 (ucast v0_final)) (ucast v1_final))\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "XTEA", "family": "Feistel", "extraction_time": "2026-01-24T13:11:27.529533", "variant": {"block_size": 64, "key_size": 128, "rounds": 32, "cycles_per_round": 2, "delta_constant": "0x9E3779B9", "word_size": 32, "key_words": 4, "structure": "Feistel-like with sum accumulation"}, "algorithm_params": {"cipher_family": "Block Cipher", "structure": "Modified Feistel Network", "operations": ["addition", "xor", "shift", "modular_addition"], "delta_usage": "Accumulated sum for key selection", "key_schedule": "Simple key splitting (no expansion)", "mix_function": "(x << 4) ^ (x >> 5)", "key_selection": "sum_val & 3 and (sum_val >> 11) & 3"}, "transformation_patterns": ["word_splitting_combining", "32_bit_word_operations"]}}
{"instruction": "Translate the XTEA(64/128) Decrypt Block from Python to Isabelle/HOL. Apply these transformations: Initial sum = delta * num_cycles, Use word_of_nat to convert nat to word, Same block splitting pattern as encryption, Call decrypt_iterate instead of encrypt_iterate. Note: XTEA processes 64-bit blocks as two 32-bit words (v0, v1).", "input": "def xtea_decrypt_block(key, ciphertext):\n    \"\"\"XTEA block decryption (64-bit block, 128-bit key)\"\"\"\n    # Split key\n    key_words = split_key_128_to_32(key)\n    \n    # Split ciphertext\n    mask = 0xFFFFFFFF\n    v0 = (ciphertext >> 32) & 0xFFFFFFFF\n    v1 = ciphertext & 0xFFFFFFFF\n    \n    # Decrypt\n    v0_final, v1_final = xtea_decrypt_iterate(split_key_128_to_32(key), 32, v0, v1)\n    \n    # Combine\n    return (v0_final << 32) | v1_final", "output": "definition xtea_64_128_decrypt_block :: \n  \"128 word \\<Rightarrow> 64 word \\<Rightarrow> 64 word\" where\n  \"xtea_64_128_decrypt_block key ciphertext = (\n    let key_words = xtea_64_128_split_key key;\n        v0 = ucast (drop_bit 32 ciphertext);\n        v1 = ucast ciphertext;\n        initial_sum = xtea_64_128_delta * (word_of_nat xtea_64_128_num_cycles);\n        (v0_final, v1_final) = xtea_64_128_decrypt_iterate key_words xtea_64_128_num_cycles v0 v1 initial_sum\n    in or (push_bit 32 (ucast v0_final)) (ucast v1_final))\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "XTEA", "family": "Feistel", "extraction_time": "2026-01-24T13:11:27.530083", "variant": {"block_size": 64, "key_size": 128, "rounds": 32, "cycles_per_round": 2, "delta_constant": "0x9E3779B9", "word_size": 32, "key_words": 4, "structure": "Feistel-like with sum accumulation"}, "algorithm_params": {"cipher_family": "Block Cipher", "structure": "Modified Feistel Network", "operations": ["addition", "xor", "shift", "modular_addition"], "delta_usage": "Accumulated sum for key selection", "key_schedule": "Simple key splitting (no expansion)", "mix_function": "(x << 4) ^ (x >> 5)", "key_selection": "sum_val & 3 and (sum_val >> 11) & 3"}, "transformation_patterns": ["word_splitting_combining", "32_bit_word_operations"]}}
{"instruction": "Translate the XTEA(64/128) Top-Level Encrypt from Python to Isabelle/HOL. Apply these transformations: Simple wrapper function, Direct parameter mapping. Note: XTEA is a block cipher designed for simplicity and security with 32 cycles.", "input": "def xtea_encrypt(key, plaintext):\n    \"\"\"Wrapper that calls encrypt_block\"\"\"\n    return xtea_encrypt_block(key, plaintext)", "output": "definition xtea_64_128_encrypt :: \n  \"128 word \\<Rightarrow> 64 word \\<Rightarrow> 64 word\" where\n  \"xtea_64_128_encrypt key plaintext = \n    xtea_64_128_encrypt_block key plaintext\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "easy", "semantic_group": "top_level", "cipher": "XTEA", "family": "Feistel", "extraction_time": "2026-01-24T13:11:27.530317", "variant": {"block_size": 64, "key_size": 128, "rounds": 32, "cycles_per_round": 2, "delta_constant": "0x9E3779B9", "word_size": 32, "key_words": 4, "structure": "Feistel-like with sum accumulation"}, "algorithm_params": {"cipher_family": "Block Cipher", "structure": "Modified Feistel Network", "operations": ["addition", "xor", "shift", "modular_addition"], "delta_usage": "Accumulated sum for key selection", "key_schedule": "Simple key splitting (no expansion)", "mix_function": "(x << 4) ^ (x >> 5)", "key_selection": "sum_val & 3 and (sum_val >> 11) & 3"}, "transformation_patterns": []}}
{"instruction": "Translate the XTEA(64/128) Top-Level Decrypt from Python to Isabelle/HOL. Apply these transformations: Wrapper function that calls decrypt_block, Direct mapping of parameters, No additional logic needed. Note: XTEA is a block cipher designed for simplicity and security with 32 cycles.", "input": "def xtea_decrypt(key, plaintext):\n    \"\"\"Wrapper that calls decrypt_block\"\"\"\n    return xtea_decrypt_block(key, plaintext)", "output": "definition xtea_64_128_decrypt :: \n  \"128 word \\<Rightarrow> 64 word \\<Rightarrow> 64 word\" where\n  \"xtea_64_128_decrypt key ciphertext = \n    xtea_64_128_decrypt_block key ciphertext\"", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "easy", "semantic_group": "top_level", "cipher": "XTEA", "family": "Feistel", "extraction_time": "2026-01-24T13:11:27.530525", "variant": {"block_size": 64, "key_size": 128, "rounds": 32, "cycles_per_round": 2, "delta_constant": "0x9E3779B9", "word_size": 32, "key_words": 4, "structure": "Feistel-like with sum accumulation"}, "algorithm_params": {"cipher_family": "Block Cipher", "structure": "Modified Feistel Network", "operations": ["addition", "xor", "shift", "modular_addition"], "delta_usage": "Accumulated sum for key selection", "key_schedule": "Simple key splitting (no expansion)", "mix_function": "(x << 4) ^ (x >> 5)", "key_selection": "sum_val & 3 and (sum_val >> 11) & 3"}, "transformation_patterns": []}}
