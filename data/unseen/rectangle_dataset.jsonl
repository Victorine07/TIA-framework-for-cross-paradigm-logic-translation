{"instruction": "Translate this Rounds Constant from RECTANGLE-64/80 Python to Isabelle/HOL.", "input": "# Number of encryption rounds\nrounds = 25", "output": "definition rectangle_64_80_rounds :: nat where \n  \"rectangle_64_80_rounds = 25\"", "metadata": {"component_type": "Rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.534917", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Block Size Constant from RECTANGLE-64/80 Python to Isabelle/HOL.", "input": "# Block size in bits\nblock_size = 64", "output": "definition rectangle_64_80_block_size :: nat where \n  \"rectangle_64_80_block_size = 64\"", "metadata": {"component_type": "Block Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.535300", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Key Size Constant from RECTANGLE-64/80 Python to Isabelle/HOL.", "input": "# Key size in bits\nkey_size = 80", "output": "definition rectangle_64_80_key_size :: nat where \n  \"rectangle_64_80_key_size = 80\"", "metadata": {"component_type": "Key Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.535610", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this S-Box Table from RECTANGLE-64/80 Python to Isabelle/HOL.", "input": "# RECTANGLE S-Box (4-bit substitution)\nSBOX_TABLE = [0x6, 0x5, 0xc, 0xa, 0x1, 0xe, 0x7, 0x9, \n              0xb, 0x0, 0x3, 0xd, 0x8, 0xf, 0x4, 0x2]", "output": "definition rectangle_64_80_sbox_table :: \"nat list\" where\n  \"rectangle_64_80_sbox_table =\n   [0x6, 0x5, 0xC, 0xA, 0x1, 0xE, 0x7, 0x9,\n    0xB, 0x0, 0x3, 0xD, 0x8, 0xF, 0x4, 0x2]\"", "metadata": {"component_type": "S-Box Table", "difficulty": "easy", "semantic_group": "tables", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.535909", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Inverse S-Box Table from RECTANGLE-64/80 Python to Isabelle/HOL.", "input": "# RECTANGLE Inverse S-Box\nINV_SBOX_TABLE = [0x9, 0x4, 0xf, 0xa, 0xe, 0x1, 0x0, 0x6,\n                  0xc, 0x7, 0x3, 0x8, 0x2, 0xb, 0x5, 0xd]", "output": "definition rectangle_64_80_sbox_inv_table :: \"nat list\" where\n  \"rectangle_64_80_sbox_inv_table =\n   [0x9, 0x4, 0xF, 0xA, 0xE, 0x1, 0x0, 0x6,\n    0xC, 0x7, 0x3, 0x8, 0x2, 0xB, 0x5, 0xD]\"", "metadata": {"component_type": "Inverse S-Box Table", "difficulty": "easy", "semantic_group": "tables", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.536171", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Round Constants Table from RECTANGLE-64/80 Python to Isabelle/HOL.", "input": "# RECTANGLE Round Constants (25 rounds)\nRC = [\n    0x01, 0x02, 0x04, 0x09, 0x12, 0x05, 0x0B, 0x16, 0x0C, 0x19,\n    0x13, 0x07, 0x0F, 0x1F, 0x1E, 0x1C, 0x18, 0x11, 0x03, 0x06,\n    0x0D, 0x1B, 0x17, 0x0E, 0x1D\n]", "output": "definition rectangle_64_80_rc :: \"nat list\" where\n  \"rectangle_64_80_rc =\n   [0x01, 0x02, 0x04, 0x09, 0x12, 0x05, 0x0B, 0x16, 0x0C, 0x19,\n    0x13, 0x07, 0x0F, 0x1F, 0x1E, 0x1C, 0x18, 0x11, 0x03, 0x06,\n    0x0D, 0x1B, 0x17, 0x0E, 0x1D]\"", "metadata": {"component_type": "Round Constants Table", "difficulty": "easy", "semantic_group": "tables", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.536408", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Get Key Word from RECTANGLE-64/80 Python to Isabelle/HOL. Apply: use Isabelle bit operations.", "input": "def get_key_word(k: int, i: int) -> int:\n    \"\"\"Extract 16-bit word i from 80-bit key\"\"\"\n    return (k >> (16 * i)) & 0xFFFF", "output": "definition get_key_word :: \"80 word \\<Rightarrow> nat \\<Rightarrow> 16 word\" where\n  \"get_key_word k i = ucast (drop_bit (16 * i) (take_bit (16 * (i+1)) k))\"", "metadata": {"component_type": "Get Key Word", "difficulty": "medium", "semantic_group": "helpers", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.537115", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Get State Word from RECTANGLE-64/80 Python to Isabelle/HOL. Apply: use Isabelle bit operations.", "input": "def get_state_word(s: int, i: int) -> int:\n    \"\"\"Extract 16-bit word i from 64-bit state\"\"\"\n    return (s >> (16 * i)) & 0xFFFF", "output": "definition get_state_word :: \"64 word \\<Rightarrow> nat \\<Rightarrow> 16 word\" where\n  \"get_state_word s i = ucast (drop_bit (16 * i) (take_bit (16 * (i+1)) s))\"", "metadata": {"component_type": "Get State Word", "difficulty": "medium", "semantic_group": "helpers", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.537760", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Combine State from RECTANGLE-64/80 Python to Isabelle/HOL. Apply: use Isabelle bit operations.", "input": "def combine_state(r0: int, r1: int, r2: int, r3: int) -> int:\n    \"\"\"Combine four 16-bit words into a 64-bit state\"\"\"\n    return (r0) | (r1 << 16) | (r2 << 32) | (r3 << 48)", "output": "definition combine_state :: \"16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 64 word\" where\n  \"combine_state r0 r1 r2 r3 = \n    or (or (or (ucast r0) (push_bit 16 (ucast r1))) \n           (push_bit 32 (ucast r2))) \n       (push_bit 48 (ucast r3))\"", "metadata": {"component_type": "Combine State", "difficulty": "medium", "semantic_group": "helpers", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.538405", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Key to State from RECTANGLE-64/80 Python to Isabelle/HOL. Apply: convert loops to fold operations, use Isabelle bit operations.", "input": "def key_to_state(k: int) -> tuple:\n    \"\"\"Convert 80-bit key to 5 words\"\"\"\n    return tuple((k >> (16 * i)) & 0xFFFF for i in range(5))", "output": "definition rectangle_64_80_key_to_state :: \"80 word \\<Rightarrow> (16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word)\" where\n  \"rectangle_64_80_key_to_state k = (\n    get_key_word k 0,\n    get_key_word k 1,\n    get_key_word k 2,\n    get_key_word k 3,\n    get_key_word k 4\n  )\"", "metadata": {"component_type": "Key to State", "difficulty": "medium", "semantic_group": "helpers", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.538734", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Bitsliced S-Box Table Lookup from RECTANGLE-64/80 Python to Isabelle/HOL. Apply: implement bitsliced S-box using bit extraction and table lookup, convert loops to fold operations, use Isabelle bit operations.", "input": "def sub_column_table(table: list, r0: int, r1: int, r2: int, r3: int) -> tuple:\n    \"\"\"Bitsliced S-box using table lookup\"\"\"\n    nr0, nr1, nr2, nr3 = 0, 0, 0, 0\n    for i in range(16):\n        col = ((r0 >> i) & 1) | (((r1 >> i) & 1) << 1) | \\\n              (((r2 >> i) & 1) << 2) | (((r3 >> i) & 1) << 3)\n        out_col = table[col]\n        nr0 |= ((out_col & 1) << i)\n        nr1 |= (((out_col >> 1) & 1) << i)\n        nr2 |= (((out_col >> 2) & 1) << i)\n        nr3 |= (((out_col >> 3) & 1) << i)\n    return nr0 & 0xFFFF, nr1 & 0xFFFF, nr2 & 0xFFFF, nr3 & 0xFFFF", "output": "definition rectangle_64_80_sub_column_table ::\n  \"nat list \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> (16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word)\" where\n  \"rectangle_64_80_sub_column_table table r0 r1 r2 r3 = (\n    let \n      build_word = (\\<lambda>b. word_of_int (\n        \\<Sum>i<16. \n          if bit (word_of_int (int (table ! \n            (((if bit r0 i then 1 else 0) +\n              (if bit r1 i then 2 else 0) +\n              (if bit r2 i then 4 else 0) +\n              (if bit r3 i then 8 else 0)) mod 16))) :: 4 word) b\n          then 2^i else 0\n      ))\n    in\n      (build_word 0, build_word 1, build_word 2, build_word 3)\n  )\"", "metadata": {"component_type": "Bitsliced S-Box Table Lookup", "difficulty": "hard", "semantic_group": "sbox_operations", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.538994", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Sub Column (Forward) from RECTANGLE-64/80 Python to Isabelle/HOL. Apply: convert loops to fold operations.", "input": "def sub_column(r0: int, r1: int, r2: int, r3: int) -> tuple:\n    \"\"\"Forward bitsliced S-box\"\"\"\n    return sub_column_table(SBOX_TABLE, r0, r1, r2, r3)", "output": "definition rectangle_64_80_sub_column ::\n  \"16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> (16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word)\" where\n  \"rectangle_64_80_sub_column = rectangle_64_80_sub_column_table rectangle_64_80_sbox_table\"", "metadata": {"component_type": "Sub Column (Forward)", "difficulty": "hard", "semantic_group": "sbox_operations", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.539242", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Sub Column (Inverse) from RECTANGLE-64/80 Python to Isabelle/HOL.", "input": "def sub_column_inv(r0: int, r1: int, r2: int, r3: int) -> tuple:\n    \"\"\"Inverse bitsliced S-box\"\"\"\n    return sub_column_table(INV_SBOX_TABLE, r0, r1, r2, r3)", "output": "definition rectangle_64_80_sub_column_inv ::\n  \"16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> (16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word)\" where\n  \"rectangle_64_80_sub_column_inv = rectangle_64_80_sub_column_table rectangle_64_80_sbox_inv_table\"", "metadata": {"component_type": "Sub Column (Inverse)", "difficulty": "hard", "semantic_group": "sbox_operations", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.539506", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Shift Rows from RECTANGLE-64/80 Python to Isabelle/HOL. Apply: use Isabelle word rotation operations, use Isabelle bit operations.", "input": "def shift_rows(r0: int, r1: int, r2: int, r3: int) -> tuple:\n    \"\"\"Shift rows: rotate by (0, 1, 12, 13)\"\"\"\n    r1 = ((r1 << 1) | (r1 >> 15)) & 0xFFFF\n    r2 = ((r2 << 12) | (r2 >> 4)) & 0xFFFF\n    r3 = ((r3 << 13) | (r3 >> 3)) & 0xFFFF\n    return r0, r1, r2, r3", "output": "definition rectangle_64_80_shift_rows ::\n  \"16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> (16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word)\" where\n  \"rectangle_64_80_shift_rows r0 r1 r2 r3 = (r0, word_rotl 1 r1, word_rotl 12 r2, word_rotl 13 r3)\"", "metadata": {"component_type": "Shift Rows", "difficulty": "medium", "semantic_group": "linear_operations", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.539829", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Shift Rows Inverse from RECTANGLE-64/80 Python to Isabelle/HOL. Apply: use Isabelle word rotation operations, use Isabelle bit operations.", "input": "def shift_rows_inv(r0: int, r1: int, r2: int, r3: int) -> tuple:\n    \"\"\"Inverse shift rows\"\"\"\n    r1 = ((r1 >> 1) | (r1 << 15)) & 0xFFFF\n    r2 = ((r2 >> 12) | (r2 << 4)) & 0xFFFF\n    r3 = ((r3 >> 13) | (r3 << 3)) & 0xFFFF\n    return r0, r1, r2, r3", "output": "definition rectangle_64_80_shift_rows_inv ::\n  \"16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> (16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word)\" where\n  \"rectangle_64_80_shift_rows_inv r0 r1 r2 r3 = (r0, word_rotr 1 r1, word_rotr 12 r2, word_rotr 13 r3)\"", "metadata": {"component_type": "Shift Rows Inverse", "difficulty": "medium", "semantic_group": "linear_operations", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.540122", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Add Round Key from RECTANGLE-64/80 Python to Isabelle/HOL. Apply: use Isabelle bit operations.", "input": "def add_round_key(r0: int, r1: int, r2: int, r3: int,\n                 k0: int, k1: int, k2: int, k3: int) -> tuple:\n    \"\"\"XOR state with round key\"\"\"\n    return r0 ^ k0, r1 ^ k1, r2 ^ k2, r3 ^ k3", "output": "definition rectangle_64_80_add_round_key ::\n  \"16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow>\n   16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow>\n   (16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word)\" where\n  \"rectangle_64_80_add_round_key r0 r1 r2 r3 k0 k1 k2 k3 = \n    (xor r0 k0, xor r1 k1, xor r2 k2, xor r3 k3)\"", "metadata": {"component_type": "Add Round Key", "difficulty": "medium", "semantic_group": "linear_operations", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.540412", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Key Update (80-bit) from RECTANGLE-64/80 Python to Isabelle/HOL. Apply: implement Feistel-like key update with rotations, convert loops to fold operations, use Isabelle bit operations.", "input": "def key_update_80(k: list, r_idx: int) -> list:\n    \"\"\"Update 80-bit key state for next round\"\"\"\n    # 1. S-box on first nibble\n    s_in = k[0] & 0xF\n    k[0] = (k[0] & 0xFFF0) | SBOX_TABLE[s_in]\n    \n    # 2. Feistel-like 5-word 8-bit rotation\n    # key_rotation = 8 \n    row0, row1, row2, row3, row4 = k\n    new_row0 = ((row0 << 8) | (row1 >> (16-8))) & 0xFFFF\n    new_row1 = ((row1 << 8) | (row2 >> (16-8))) & 0xFFFF\n    new_row2 = ((row2 << 8) | (row3 >> (16-8))) & 0xFFFF\n    new_row3 = ((row3 << 8) | (row4 >> (16-8))) & 0xFFFF\n    new_row4 = ((row4 << 8) | (k[0] >> (16-8))) & 0xFFFF\n    \n    # 3. Round Constant XOR rc_bits = (5 bits)\n    new_row0 ^= (RC[r_idx] & 0x1F)\n    \n    return [new_row0, new_row1, new_row2, new_row3, new_row4]", "output": "definition rectangle_64_80_key_update_80 ::\n  \"16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> nat \\<Rightarrow>\n   (16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word)\" where\n  \"rectangle_64_80_key_update_80 w0 w1 w2 w3 w4 r = (\n    let\n      s_in = unat (and w0 (word_of_int 0xF));\n      s_out = rectangle_64_80_sbox_table ! s_in;\n      w0_cleared = and w0 (word_of_int 0xFFF0);\n      w0_sboxed = or w0_cleared (word_of_int (int s_out));\n      new_w0 = xor (word_rotl 8 w0_sboxed) (word_rotr 8 w1);\n      new_w1 = xor (word_rotl 8 w1) (word_rotr 8 w2);\n      new_w2 = xor (word_rotl 8 w2) (word_rotr 8 w3);\n      new_w3 = xor (word_rotl 8 w3) (word_rotr 8 w4);\n      new_w4 = xor (word_rotl 8 w4) (word_rotr 8 w0_sboxed);\n      rc_val = and (word_of_int (int (rectangle_64_80_rc ! r))) (word_of_int 0x1F)\n    in\n      (xor new_w0 rc_val, new_w1, new_w2, new_w3, new_w4)\n  )\"", "metadata": {"component_type": "Key Update (80-bit)", "difficulty": "hard", "semantic_group": "key_schedule", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.540741", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Key to State from RECTANGLE-64/80 Python to Isabelle/HOL. Apply: convert loops to fold operations, use Isabelle bit operations.", "input": "def key_to_state(k: int) -> tuple:\n    \"\"\"Convert 80-bit key to 5 words\"\"\"\n    return tuple((k >> (16 * i)) & 0xFFFF for i in range(5))", "output": "definition rectangle_64_80_key_to_state :: \"80 word \\<Rightarrow> (16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word)\" where\n  \"rectangle_64_80_key_to_state k = (\n    get_key_word k 0,\n    get_key_word k 1,\n    get_key_word k 2,\n    get_key_word k 3,\n    get_key_word k 4\n  )\"", "metadata": {"component_type": "Key to State", "difficulty": "medium", "semantic_group": "key_schedule", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.540920", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Generate All Round Keys from RECTANGLE-64/80 Python to Isabelle/HOL. Apply: convert loops to fold operations.", "input": "def generate_all_round_keys(key: int) -> list:\n    \"\"\"Generate all round keys (recursive/fold implementation)\"\"\"\n    k_state = key_to_state(key)\n    round_keys = []\n    \n    for r in range(26):\n        round_keys.append(k_state[:4])\n        k_state = key_update_80(k_state, r)\n    \n    return round_keys", "output": "definition rectangle_64_80_generate_all_round_keys :: \"80 word \\<Rightarrow> ((16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word) list)\" where\n  \"rectangle_64_80_generate_all_round_keys key = (\n    let\n      init_state = rectangle_64_80_key_to_state key;\n      rounds_list = [0..<Suc rectangle_64_80_rounds] \n    in\n      snd (foldl\n        (\\<lambda>(state, keys) r. \n          let\n            (w0, w1, w2, w3, w4) = state;\n            round_key = (w0, w1, w2, w3);\n            new_state = rectangle_64_80_key_update_80 w0 w1 w2 w3 w4 r\n          in\n            (new_state, round_key # keys))\n        (init_state, [])\n        rounds_list)\n  )\"", "metadata": {"component_type": "Generate All Round Keys", "difficulty": "hard", "semantic_group": "key_schedule", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.541277", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Encrypt Round from RECTANGLE-64/80 Python to Isabelle/HOL.", "input": "def encrypt_round(r0: int, r1: int, r2: int, r3: int,\n                 k0: int, k1: int, k2: int, k3: int) -> tuple:\n    \"\"\"RECTANGLE encryption round: AddRoundKey → SubColumn → ShiftRows\"\"\"\n    # AddRoundKey\n    s0, s1, s2, s3 = add_round_key(r0, r1, r2, r3, k0, k1, k2, k3)\n    # SubColumn (S-box)\n    t0, t1, t2, t3 = sub_column(s0, s1, s2, s3)\n    # ShiftRows\n    u0, u1, u2, u3 = shift_rows(t0, t1, t2, t3)\n    return u0, u1, u2, u3", "output": "definition rectangle_64_80_encrypt_round ::\n  \"16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow>\n   16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow>\n   (16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word)\" where\n  \"rectangle_64_80_encrypt_round r0 r1 r2 r3 k0 k1 k2 k3 = (\n    let\n      (s0, s1, s2, s3) = rectangle_64_80_add_round_key r0 r1 r2 r3 k0 k1 k2 k3;\n      (t0, t1, t2, t3) = rectangle_64_80_sub_column s0 s1 s2 s3;\n      (u0, u1, u2, u3) = rectangle_64_80_shift_rows t0 t1 t2 t3\n    in (u0, u1, u2, u3))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "hard", "semantic_group": "round_operations", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.542536", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Decrypt Round from RECTANGLE-64/80 Python to Isabelle/HOL.", "input": "def decrypt_round(r0: int, r1: int, r2: int, r3: int,\n                 k0: int, k1: int, k2: int, k3: int) -> tuple:\n    \"\"\"RECTANGLE decryption round: ShiftRows⁻¹ → SubColumn⁻¹ → AddRoundKey\"\"\"\n    # ShiftRows Inverse\n    s0, s1, s2, s3 = shift_rows_inv(r0, r1, r2, r3)\n    # SubColumn Inverse\n    t0, t1, t2, t3 = sub_column_inv(s0, s1, s2, s3)\n    # AddRoundKey\n    u0, u1, u2, u3 = add_round_key(t0, t1, t2, t3, k0, k1, k2, k3)\n    return u0, u1, u2, u3", "output": "definition rectangle_64_80_decrypt_round ::\n  \"16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow>\n   16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow>\n   (16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word)\" where\n  \"rectangle_64_80_decrypt_round r0 r1 r2 r3 k0 k1 k2 k3 =(\n    let\n      (s0, s1, s2, s3) = rectangle_64_80_shift_rows_inv r0 r1 r2 r3;\n      (t0, t1, t2, t3) = rectangle_64_80_sub_column_inv s0 s1 s2 s3;\n      (u0, u1, u2, u3) = rectangle_64_80_add_round_key t0 t1 t2 t3 k0 k1 k2 k3\n    in (u0, u1, u2, u3))\"", "metadata": {"component_type": "Decrypt Round", "difficulty": "hard", "semantic_group": "round_operations", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.542981", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Encrypt Block from RECTANGLE-64/80 Python to Isabelle/HOL. Apply: convert loops to fold operations, use Isabelle bit operations.", "input": "def encrypt_block(plaintext: int, round_keys: list) -> int:\n    \"\"\"Encrypt a single block using round keys\"\"\"\n    # Split into rows\n    rows = [(plaintext >> (16 * i)) & 0xFFFF for i in range(4)]\n    \n    # Apply 25 rounds\n    for i in range(25):\n        k0, k1, k2, k3 = round_keys[i]\n        rows = encrypt_round(rows[0], rows[1], rows[2], rows[3], k0, k1, k2, k3)\n    \n    # Final whitening\n    wk0, wk1, wk2, wk3 = round_keys[25]\n    rows = [rows[0] ^ wk0, rows[1] ^ wk1, rows[2] ^ wk2, rows[3] ^ wk3]\n    \n    # Combine back\n    return combine_state(*rows)", "output": "definition rectangle_64_80_encrypt_block :: \"64 word \\<Rightarrow> ((16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word) list) \\<Rightarrow> 64 word\" where\n  \"rectangle_64_80_encrypt_block plaintext round_keys =(\n    let\n      r0 = get_state_word plaintext 0;\n      r1 = get_state_word plaintext 1;\n      r2 = get_state_word plaintext 2;\n      r3 = get_state_word plaintext 3;\n      rounds_to_apply = take rectangle_64_80_rounds round_keys;\n      (final_r0, final_r1, final_r2, final_r3) =\n        foldl (\\<lambda>(s0,s1,s2,s3) (k0,k1,k2,k3). rectangle_64_80_encrypt_round s0 s1 s2 s3 k0 k1 k2 k3)\n              (r0,r1,r2,r3)\n              rounds_to_apply;\n      whitening_key = hd (drop rectangle_64_80_rounds round_keys);\n      (wk0,wk1,wk2,wk3) = whitening_key\n    in\n      combine_state (xor final_r0 wk0) (xor final_r1 wk1) (xor final_r2 wk2) (xor final_r3 wk3))\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "hard", "semantic_group": "block_operations", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.543414", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Decrypt Block from RECTANGLE-64/80 Python to Isabelle/HOL. Apply: convert loops to fold operations, use Isabelle bit operations.", "input": "def decrypt_block(ciphertext: int, round_keys: list) -> int:\n    \"\"\"Decrypt a single block using round keys\"\"\"\n    # Split into rows\n    rows = [(ciphertext >> (16 * i)) & 0xFFFF for i in range(4)]\n    \n    # Remove whitening\n    wk0, wk1, wk2, wk3 = round_keys[25]\n    rows = [rows[0] ^ wk0, rows[1] ^ wk1, rows[2] ^ wk2, rows[3] ^ wk3]\n    \n    # Apply 25 inverse rounds\n    for i in range(24, -1, -1):\n        k0, k1, k2, k3 = round_keys[i]\n        rows = decrypt_round(rows[0], rows[1], rows[2], rows[3], k0, k1, k2, k3)\n    \n    # Combine back\n    return combine_state(*rows)", "output": "definition rectangle_64_80_decrypt_block :: \"64 word \\<Rightarrow> ((16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word) list) \\<Rightarrow> 64 word\" where\n  \"rectangle_64_80_decrypt_block ciphertext round_keys = (\n    let\n      r0 = get_state_word ciphertext 0;\n      r1 = get_state_word ciphertext 1;\n      r2 = get_state_word ciphertext 2;\n      r3 = get_state_word ciphertext 3;\n      whitening_key = hd (drop rectangle_64_80_rounds round_keys);\n      (wk0,wk1,wk2,wk3) = whitening_key;\n      s0 = xor r0 wk0;\n      s1 = xor r1 wk1;\n      s2 = xor r2 wk2;\n      s3 = xor r3 wk3;\n      rounds_to_apply = rev (take rectangle_64_80_rounds round_keys);\n      (final_r0, final_r1, final_r2, final_r3) =\n        foldl (\\<lambda>(s0,s1,s2,s3) (k0,k1,k2,k3). rectangle_64_80_decrypt_round s0 s1 s2 s3 k0 k1 k2 k3)\n              (s0,s1,s2,s3)\n              rounds_to_apply\n    in\n      combine_state final_r0 final_r1 final_r2 final_r3)\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "hard", "semantic_group": "block_operations", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.543887", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Generate All Round Keys (Complete) from RECTANGLE-64/80 Python to Isabelle/HOL. Apply: convert loops to fold operations, use Isabelle bit operations.", "input": "def generate_all_round_keys(key: int) -> list:\n    \"\"\"Generate complete key schedule (all round keys)\"\"\"\n    k_rows = [(key >> (16 * i)) & 0xFFFF for i in range(5)]\n    round_keys = []\n    \n    for r in range(26):\n        round_keys.append(k_rows[:4])\n        k_rows = key_update_80(k_rows, r)\n    \n    return round_keys", "output": "definition rectangle_64_80_generate_all_round_keys :: \"80 word \\<Rightarrow> ((16 word \\<times> 16 word \\<times> 16 word \\<times> 16 word) list)\" where\n  \"rectangle_64_80_generate_all_round_keys key = (\n    let\n      init_state = rectangle_64_80_key_to_state key;\n      rounds_list = [0..<Suc rectangle_64_80_rounds] \n    in\n      snd (foldl\n        (\\<lambda>(state, keys) r. \n          let\n            (w0, w1, w2, w3, w4) = state;\n            round_key = (w0, w1, w2, w3);\n            new_state = rectangle_64_80_key_update_80 w0 w1 w2 w3 w4 r\n          in\n            (new_state, round_key # keys))\n        (init_state, [])\n        rounds_list)\n  )\"", "metadata": {"component_type": "Generate All Round Keys (Complete)", "difficulty": "hard", "semantic_group": "block_operations", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.544092", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Encrypt (Top-level) from RECTANGLE-64/80 Python to Isabelle/HOL.", "input": "def encrypt(plaintext: int, key: int) -> int:\n    \"\"\"Top-level encryption\"\"\"\n    round_keys = generate_all_round_keys(key)\n    return encrypt_block(plaintext, round_keys)", "output": "definition rectangle_64_80_encrypt :: \"64 word \\<Rightarrow> 80 word \\<Rightarrow> 64 word\" where\n  \"rectangle_64_80_encrypt plaintext key = (\n    let round_keys = rectangle_64_80_generate_all_round_keys key\n    in rectangle_64_80_encrypt_block plaintext round_keys)\"", "metadata": {"component_type": "Encrypt (Top-level)", "difficulty": "medium", "semantic_group": "top_level", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.544647", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Decrypt (Top-level) from RECTANGLE-64/80 Python to Isabelle/HOL.", "input": "def decrypt(ciphertext: int, key: int) -> int:\n    \"\"\"Top-level decryption\"\"\"\n    round_keys = generate_all_round_keys(key)\n    return decrypt_block(ciphertext, round_keys)", "output": "definition rectangle_64_80_decrypt :: \"64 word \\<Rightarrow> 80 word \\<Rightarrow> 64 word\" where\n  \"rectangle_64_80_decrypt ciphertext key = (\n    let round_keys = rectangle_64_80_generate_all_round_keys key\n    in rectangle_64_80_decrypt_block ciphertext round_keys)\"", "metadata": {"component_type": "Decrypt (Top-level)", "difficulty": "medium", "semantic_group": "top_level", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.545118", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Test Key from RECTANGLE-64/80 Python to Isabelle/HOL.", "input": "# Test key (80-bit)\ntest_key = 0xFFEEDDCCBBAA99887766", "output": "definition test_key :: \"80 word\" where\n  \"test_key = 0xFFEEDDCCBBAA99887766\"", "metadata": {"component_type": "Test Key", "difficulty": "easy", "semantic_group": "test", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.546207", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
{"instruction": "Translate this Test Plaintext from RECTANGLE-64/80 Python to Isabelle/HOL.", "input": "# Test plaintext (64-bit)\ntest_plaintext = 0x0123456789ABCDEF", "output": "definition test_plaintext :: \"64 word\" where\n  \"test_plaintext = 0x0123456789ABCDEF\"\n\n\nend", "metadata": {"component_type": "Test Plaintext", "difficulty": "easy", "semantic_group": "test", "cipher": "RECTANGLE", "family": "SPN", "extraction_time": "2026-01-24T13:11:27.547141", "variant": {"block_size": 64, "key_size": 80, "rounds": 25}, "algorithm_params": {"rows": 4, "key_words": 5, "bitsliced": true, "word_size": 16, "sbox_size": 4, "rotations": [0, 1, 12, 13], "key_rotation": 8, "rc_bits": 5}}}
