{"instruction": "Translate this alpha Constant from SPECK-128/192 Python to Isabelle/HOL. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck alpha rotation constant (8-bit right rotate)\nalpha = 8", "output": "definition speck_128_192_alpha :: nat where \"speck_128_192_alpha = 8\"", "metadata": {"component_type": "alpha Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:47.965289"}}
{"instruction": "Translate this beta Constant from SPECK-128/192 Python to Isabelle/HOL. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck beta rotation constant (3-bit left rotate)\nbeta = 3", "output": "definition speck_128_192_beta :: nat where \"speck_128_192_beta = 3\"", "metadata": {"component_type": "beta Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:47.965652"}}
{"instruction": "Translate this rounds Constant from SPECK-128/192 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Number of rounds for SPECK(128/192)\nrounds = 33", "output": "definition speck_128_192_rounds :: nat where \"speck_128_192_rounds = 33\"", "metadata": {"component_type": "rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:47.966274"}}
{"instruction": "Translate this word_size Constant from SPECK-128/192 Python to Isabelle/HOL. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Word size in bits for SPECK(128/192)\nword_size = 64", "output": "definition speck_128_192_word_size :: nat where \"speck_128_192_word_size = 64\"", "metadata": {"component_type": "word_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:47.967055"}}
{"instruction": "Translate this block_size Constant from SPECK-128/192 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 128-bit block size\nblock_size = 128", "output": "definition speck_128_192_block_size :: nat where \"speck_128_192_block_size = 128\"", "metadata": {"component_type": "block_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:47.967537"}}
{"instruction": "Translate this key_size Constant from SPECK-128/192 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 192-bit key size\nkey_size = 192", "output": "definition speck_128_192_key_size :: nat where \"speck_128_192_key_size = 192\"", "metadata": {"component_type": "key_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:47.968021"}}
{"instruction": "Translate this Encrypt Round from SPECK-128/192 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_round(x, y, k, word_size = 64, mod_mask):\n    \"\"\"SPECK ARX encrypt round: (ROR_α(x) + y) ⊕ k, then x ⊕ ROL_β(y)\"\"\"\n    # Right rotate by alpha=(8 bits)\n    rs_x = ((x >> 8) | (x << (word_size - 8))) & mod_mask\n    \n    # Modular addition\n    add_sxy = (rs_x + y) & mod_mask\n    \n    # XOR with round key\n    new_x = k ^ add_sxy\n    \n    # Left rotate by beta=(3 bits)\n    ls_y = ((y << 3) | (y >> (word_size - 3))) & mod_mask\n    \n    # Final XOR\n    new_y = new_x ^ ls_y\n    \n    return new_x, new_y", "output": "definition speck_128_192_encrypt_round :: \"64 word ⇒ 64 word × 64 word ⇒ 64 word × 64 word\" where\n  \"speck_128_192_encrypt_round k xy = (\n    let (x, y) = xy;\n        rs_x = word_rotr speck_128_192_alpha x;\n        add_xy = rs_x + y;\n        new_x = xor add_xy k;\n        ls_y = word_rotl speck_128_192_beta y;\n        new_y = xor new_x ls_y\n    in (new_x, new_y))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.968388"}}
{"instruction": "Translate this Decrypt Round from SPECK-128/192 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_round(x, y, k, word_size = 64, mod_mask, mod_mask_sub):\n    \"\"\"SPECK ARX decrypt round (inverse operations)\"\"\"\n    # Recover original y: ROR_β(x ⊕ y)\n    # alpha = 8\n    # beta = 3\n    xor_xy = x ^ y\n    new_y = ((xor_xy >> 3) | (xor_xy << (word_size - 3))) & mod_mask\n    \n    # Recover original x: ROL_α((x ⊕ k) - y)\n    xor_xk = x ^ k\n    msub = (xor_xk - new_y) % mod_mask_sub\n    new_x = ((msub << 8) | (msub >> (word_size - 8))) & mod_mask\n    \n    return new_x, new_y", "output": "definition speck_128_192_decrypt_round_inverse :: \"64 word ⇒ 64 word × 64 word ⇒ 64 word × 64 word\" where\n  \"speck_128_192_decrypt_round_inverse k xy_new = (\n    let (x, y) = xy_new;\n        xor_xy = xor x y;\n        new_y = word_rotr speck_128_192_beta xor_xy;\n        xor_xk = xor x k;\n        msub = xor_xk - new_y;\n        new_x = word_rotl speck_128_192_alpha msub\n    in (new_x, new_y))\"", "metadata": {"component_type": "Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.968707"}}
{"instruction": "Translate this Key Schedule Recursive from SPECK-128/192 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_gen_key_schedule_rec(l_keys, k_keys, i, max_rounds= 33):\n    \"\"\"Recursive SPECK key schedule generation\"\"\"\n    max_rounds = 33\n    if i >= 33:\n        return k_keys\n    \n    # Apply round function to generate next key\n    # word_size = 64\n    new_l, new_k = speck_encrypt_round(\n        l_keys[i % len(l_keys)], \n        k_keys[i], \n        i,  # Round constant as key\n        64,\n        (1 << 64) - 1\n    )\n\n    # Append and recurse\n    l_keys.append(new_l)\n    k_keys.append(new_k)\n    \n    return speck_gen_key_schedule_rec(l_keys, k_keys, i + 1, max_rounds)", "output": "function speck_128_192_gen_key_schedule_rec :: \"64 word list ⇒ 64 word list ⇒ nat ⇒ 64 word list\" where\n  \"speck_128_192_gen_key_schedule_rec l_keys k_keys i = (\n     if i ≥ (33 - 1) then k_keys\n     else\n       let (new_l, new_k) = speck_128_192_encrypt_round (word_of_nat i) (l_keys ! i, k_keys ! i)\n       in speck_128_192_gen_key_schedule_rec (l_keys @ [new_l]) (k_keys @ [new_k]) (i + 1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(l, k, i). 32 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.969039"}}
{"instruction": "Translate this Key Schedule Wrapper from SPECK-128/192 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_generate_key_schedule(master_key):\n    \"\"\"Generate SPECK round keys from master key\"\"\"\n    # Extract key words\n    # word_size = 64\n    key_words = []\n    for i in range(3):\n        key_words.append((master_key >> (64 * i)) & ((1 << 64 - 1))\n    \n    # Initialize L and K arrays\n    l_keys = key_words[1:]  # All except first\n    k_keys = [key_words[0]]  # First word\n    \n    # Generate round keys\n    return speck_gen_key_schedule_rec(l_keys, k_keys, 0, 33)", "output": "definition speck_128_192_generate_key_schedule :: \"64 word list ⇒ 64 word list\" where\n  \"speck_128_192_generate_key_schedule initial_key_words = (\n     let k0 = [initial_key_words ! 0];\n         l0 = [initial_key_words ! 1, initial_key_words ! 2]\n     in speck_128_192_gen_key_schedule_rec l0 k0 0)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.969386"}}
{"instruction": "Translate this Encrypt Iteration from SPECK-128/192 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply SPECK encryption rounds\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    # word_size = 64\n    new_x, new_y = speck_encrypt_round(\n        x, y, k, \n        64, \n        (1 << 64) - 1\n    )\n    \n    # Recursive call for next round\n    return speck_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun speck_128_192_encrypt_iterate :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"speck_128_192_encrypt_iterate state [] = state\"\n| \"speck_128_192_encrypt_iterate state (k#ks) = speck_128_192_encrypt_iterate (speck_128_192_encrypt_round k state) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.969747"}}
{"instruction": "Translate this Decrypt Iteration from SPECK-128/192 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply SPECK decryption rounds (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    # word_size = 64\n    new_x, new_y = speck_decrypt_round(\n        x, y, k,\n        64,\n        (1 << 64) - 1,\n        (1 << 64)\n    )\n    \n    # Recursive call for previous round\n    return speck_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun speck_128_192_decrypt_iterate :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"speck_128_192_decrypt_iterate state ks = foldl (λst_new k. speck_128_192_decrypt_round_inverse k st_new) state (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.970076"}}
{"instruction": "Translate this Encrypt Block from SPECK-128/192 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_block(plaintext, key_schedule):\n    \"\"\"SPECK block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 64\n    left = (plaintext >> 64) & ((1 << 64) - 1)\n    right = plaintext & ((1 << 64) - 1)\n    \n    # Apply all rounds\n    cipher_left, cipher_right = speck_encrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # word_size = 64\n    # Combine back\n    return (cipher_left << 64) | cipher_right", "output": "definition speck_128_192_encrypt_block :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"speck_128_192_encrypt_block state keys = speck_128_192_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.970513"}}
{"instruction": "Translate this Decrypt Block from SPECK-128/192 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SPECK block decryption\"\"\"\n    # Split into left and right halves\n    left = (ciphertext >> 64) & ((1 << 64) - 1)\n    right = ciphertext & ((1 << 64) - 1)\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = speck_decrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 64) | plain_right", "output": "definition speck_128_192_decrypt_block :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"speck_128_192_decrypt_block state keys = speck_128_192_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.971031"}}
{"instruction": "Translate this Block Splitting from SPECK-128/192 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_split_block(block):\n    \"\"\"Split 128-bit block into two 64-bit words\"\"\"\n    # word_size = 64\n    \n    mask = (1 << 64) - 1\n    left = (block >> 64) & (1 << 64) - 1\n    right = block & (1 << 64) - 1\n    return left, right", "output": "definition speck_128_192_split_block :: \"128 word ⇒ (64 word × 64 word)\" where\n  \"speck_128_192_split_block block = (\n    let left = ucast (drop_bit 64 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.971934"}}
{"instruction": "Translate this Block Combining from SPECK-128/192 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_combine_block(left, right):\n    \"\"\"Combine two 64-bit words into 128-bit block\"\"\"\n    # word_size = 64\n    \n    return (left << 64) | right", "output": "definition speck_128_192_combine_block :: \"64 word × 64 word ⇒ 128 word\" where\n  \"speck_128_192_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 64 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.972758"}}
{"instruction": "Translate this Top-Level Encrypt from SPECK-128/192 Python to Isabelle/HOL. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt(plaintext, master_key):\n    \"\"\"Top-level SPECK encryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return speck_encrypt_block(plaintext, key_schedule)", "output": "definition speck_128_192_encrypt :: \"128 word ⇒ 64 word list ⇒ 128 word\" where\n  \"speck_128_192_encrypt plaintext keys = (\n    let left = ucast (drop_bit 64 plaintext);\n        right = ucast plaintext;\n        (c_l, c_r) = speck_128_192_encrypt_block (left, right) keys\n    in or (push_bit 64 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.973121"}}
{"instruction": "Translate this Top-Level Decrypt from SPECK-128/192 Python to Isabelle/HOL. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SPECK decryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return speck_decrypt_block(ciphertext, key_schedule)", "output": "definition speck_128_192_decrypt :: \"128 word ⇒ 64 word list ⇒ 128 word\" where\n  \"speck_128_192_decrypt ciphertext keys = (\n    let left = ucast (drop_bit 64 ciphertext);\n        right = ucast ciphertext;\n        (p_l, p_r) = speck_128_192_decrypt_block (left, right) keys\n    in or (push_bit 64 (ucast p_l)) (ucast p_r))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.973539"}}
{"instruction": "Translate this Modular Mask from SPECK-128/192 Python to Isabelle/HOL. Note: SPECK-128/192  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_mod_mask(word_size=64):\n    \"\"\"Create mask for 64-bit words\"\"\"\n    # word_size = 64\n    \n    return (1 <<  64) - 1", "output": "definition speck_128_192_mod_mask :: \"64 word\" where\n  \"speck_128_192_mod_mask = 18446744073709551615\"", "metadata": {"component_type": "Modular Mask", "difficulty": "easy", "semantic_group": "helpers", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 192, "rounds": 33}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.974559"}}
{"instruction": "Translate this alpha Constant from SPECK-128/256 Python to Isabelle/HOL. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck alpha rotation constant (8-bit right rotate)\nalpha = 8", "output": "definition speck_128_256_alpha :: nat where \"speck_128_256_alpha = 8\"", "metadata": {"component_type": "alpha Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:47.977848"}}
{"instruction": "Translate this beta Constant from SPECK-128/256 Python to Isabelle/HOL. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck beta rotation constant (3-bit left rotate)\nbeta = 3", "output": "definition speck_128_256_beta :: nat where \"speck_128_256_beta = 3\"", "metadata": {"component_type": "beta Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:47.978134"}}
{"instruction": "Translate this rounds Constant from SPECK-128/256 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Number of rounds for SPECK(128/256)\nrounds = 34", "output": "definition speck_128_256_rounds :: nat where \"speck_128_256_rounds = 34\"", "metadata": {"component_type": "rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:47.978504"}}
{"instruction": "Translate this word_size Constant from SPECK-128/256 Python to Isabelle/HOL. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Word size in bits for SPECK(128/256)\nword_size = 64", "output": "definition speck_128_256_word_size :: nat where \"speck_128_256_word_size = 64\"", "metadata": {"component_type": "word_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:47.978879"}}
{"instruction": "Translate this block_size Constant from SPECK-128/256 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 128-bit block size\nblock_size = 128", "output": "definition speck_128_256_block_size :: nat where \"speck_128_256_block_size = 128\"", "metadata": {"component_type": "block_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:47.979297"}}
{"instruction": "Translate this key_size Constant from SPECK-128/256 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 256-bit key size\nkey_size = 256", "output": "definition speck_128_256_key_size :: nat where \"speck_128_256_key_size = 256\"", "metadata": {"component_type": "key_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:47.979961"}}
{"instruction": "Translate this Encrypt Round from SPECK-128/256 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_round(x, y, k, word_size = 64, mod_mask):\n    \"\"\"SPECK ARX encrypt round: (ROR_α(x) + y) ⊕ k, then x ⊕ ROL_β(y)\"\"\"\n    # Right rotate by alpha=(8 bits)\n    rs_x = ((x >> 8) | (x << (word_size - 8))) & mod_mask\n    \n    # Modular addition\n    add_sxy = (rs_x + y) & mod_mask\n    \n    # XOR with round key\n    new_x = k ^ add_sxy\n    \n    # Left rotate by beta=(3 bits)\n    ls_y = ((y << 3) | (y >> (word_size - 3))) & mod_mask\n    \n    # Final XOR\n    new_y = new_x ^ ls_y\n    \n    return new_x, new_y", "output": "definition speck_128_256_encrypt_round :: \"64 word ⇒ 64 word × 64 word ⇒ 64 word × 64 word\" where\n  \"speck_128_256_encrypt_round k xy = (\n    let (x, y) = xy;\n        rs_x = word_rotr speck_128_256_alpha x;\n        add_xy = rs_x + y;\n        new_x = xor add_xy k;\n        ls_y = word_rotl speck_128_256_beta y;\n        new_y = xor new_x ls_y\n    in (new_x, new_y))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.980394"}}
{"instruction": "Translate this Decrypt Round from SPECK-128/256 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_round(x, y, k, word_size = 64, mod_mask, mod_mask_sub):\n    \"\"\"SPECK ARX decrypt round (inverse operations)\"\"\"\n    # Recover original y: ROR_β(x ⊕ y)\n    # alpha = 8\n    # beta = 3\n    xor_xy = x ^ y\n    new_y = ((xor_xy >> 3) | (xor_xy << (word_size - 3))) & mod_mask\n    \n    # Recover original x: ROL_α((x ⊕ k) - y)\n    xor_xk = x ^ k\n    msub = (xor_xk - new_y) % mod_mask_sub\n    new_x = ((msub << 8) | (msub >> (word_size - 8))) & mod_mask\n    \n    return new_x, new_y", "output": "definition speck_128_256_decrypt_round_inverse :: \"64 word ⇒ 64 word × 64 word ⇒ 64 word × 64 word\" where\n  \"speck_128_256_decrypt_round_inverse k xy_new = (\n    let (x, y) = xy_new;\n        xor_xy = xor x y;\n        new_y = word_rotr speck_128_256_beta xor_xy;\n        xor_xk = xor x k;\n        msub = xor_xk - new_y;\n        new_x = word_rotl speck_128_256_alpha msub\n    in (new_x, new_y))\"", "metadata": {"component_type": "Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.980823"}}
{"instruction": "Translate this Key Schedule Recursive from SPECK-128/256 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_gen_key_schedule_rec(l_keys, k_keys, i, max_rounds= 34):\n    \"\"\"Recursive SPECK key schedule generation\"\"\"\n    max_rounds = 34\n    if i >= 34:\n        return k_keys\n    \n    # Apply round function to generate next key\n    # word_size = 64\n    new_l, new_k = speck_encrypt_round(\n        l_keys[i % len(l_keys)], \n        k_keys[i], \n        i,  # Round constant as key\n        64,\n        (1 << 64) - 1\n    )\n\n    # Append and recurse\n    l_keys.append(new_l)\n    k_keys.append(new_k)\n    \n    return speck_gen_key_schedule_rec(l_keys, k_keys, i + 1, max_rounds)", "output": "function speck_128_256_gen_key_schedule_rec :: \"64 word list ⇒ 64 word list ⇒ nat ⇒ 64 word list\" where\n  \"speck_128_256_gen_key_schedule_rec l_keys k_keys i = (\n     if i ≥ (34 - 1) then k_keys\n     else\n       let (new_l, new_k) = speck_128_256_encrypt_round (word_of_nat i) (l_keys ! i, k_keys ! i)\n       in speck_128_256_gen_key_schedule_rec (l_keys @ [new_l]) (k_keys @ [new_k]) (i + 1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(l, k, i). 33 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.981270"}}
{"instruction": "Translate this Key Schedule Wrapper from SPECK-128/256 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_generate_key_schedule(master_key):\n    \"\"\"Generate SPECK round keys from master key\"\"\"\n    # Extract key words\n    # word_size = 64\n    key_words = []\n    for i in range(4):\n        key_words.append((master_key >> (64 * i)) & ((1 << 64 - 1))\n    \n    # Initialize L and K arrays\n    l_keys = key_words[1:]  # All except first\n    k_keys = [key_words[0]]  # First word\n    \n    # Generate round keys\n    return speck_gen_key_schedule_rec(l_keys, k_keys, 0, 34)", "output": "definition speck_128_256_generate_key_schedule :: \"64 word list ⇒ 64 word list\" where\n  \"speck_128_256_generate_key_schedule initial_key_words = (\n     let k0 = [initial_key_words ! 0];\n         l0 = [initial_key_words ! 1, initial_key_words ! 2, initial_key_words ! 3]\n     in speck_128_256_gen_key_schedule_rec l0 k0 0)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.981656"}}
{"instruction": "Translate this Encrypt Iteration from SPECK-128/256 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply SPECK encryption rounds\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    # word_size = 64\n    new_x, new_y = speck_encrypt_round(\n        x, y, k, \n        64, \n        (1 << 64) - 1\n    )\n    \n    # Recursive call for next round\n    return speck_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun speck_128_256_encrypt_iterate :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"speck_128_256_encrypt_iterate state [] = state\"\n| \"speck_128_256_encrypt_iterate state (k#ks) = speck_128_256_encrypt_iterate (speck_128_256_encrypt_round k state) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.982099"}}
{"instruction": "Translate this Decrypt Iteration from SPECK-128/256 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply SPECK decryption rounds (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    # word_size = 64\n    new_x, new_y = speck_decrypt_round(\n        x, y, k,\n        64,\n        (1 << 64) - 1,\n        (1 << 64)\n    )\n    \n    # Recursive call for previous round\n    return speck_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun speck_128_256_decrypt_iterate :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"speck_128_256_decrypt_iterate state ks = foldl (λst_new k. speck_128_256_decrypt_round_inverse k st_new) state (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.982503"}}
{"instruction": "Translate this Encrypt Block from SPECK-128/256 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_block(plaintext, key_schedule):\n    \"\"\"SPECK block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 64\n    left = (plaintext >> 64) & ((1 << 64) - 1)\n    right = plaintext & ((1 << 64) - 1)\n    \n    # Apply all rounds\n    cipher_left, cipher_right = speck_encrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # word_size = 64\n    # Combine back\n    return (cipher_left << 64) | cipher_right", "output": "definition speck_128_256_encrypt_block :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"speck_128_256_encrypt_block state keys = speck_128_256_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.982935"}}
{"instruction": "Translate this Decrypt Block from SPECK-128/256 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SPECK block decryption\"\"\"\n    # Split into left and right halves\n    left = (ciphertext >> 64) & ((1 << 64) - 1)\n    right = ciphertext & ((1 << 64) - 1)\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = speck_decrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 64) | plain_right", "output": "definition speck_128_256_decrypt_block :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"speck_128_256_decrypt_block state keys = speck_128_256_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.983468"}}
{"instruction": "Translate this Block Splitting from SPECK-128/256 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_split_block(block):\n    \"\"\"Split 128-bit block into two 64-bit words\"\"\"\n    # word_size = 64\n    \n    mask = (1 << 64) - 1\n    left = (block >> 64) & (1 << 64) - 1\n    right = block & (1 << 64) - 1\n    return left, right", "output": "definition speck_128_256_split_block :: \"128 word ⇒ (64 word × 64 word)\" where\n  \"speck_128_256_split_block block = (\n    let left = ucast (drop_bit 64 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.984825"}}
{"instruction": "Translate this Block Combining from SPECK-128/256 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_combine_block(left, right):\n    \"\"\"Combine two 64-bit words into 128-bit block\"\"\"\n    # word_size = 64\n    \n    return (left << 64) | right", "output": "definition speck_128_256_combine_block :: \"64 word × 64 word ⇒ 128 word\" where\n  \"speck_128_256_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 64 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.986049"}}
{"instruction": "Translate this Top-Level Encrypt from SPECK-128/256 Python to Isabelle/HOL. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt(plaintext, master_key):\n    \"\"\"Top-level SPECK encryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return speck_encrypt_block(plaintext, key_schedule)", "output": "definition speck_128_256_encrypt :: \"128 word ⇒ 64 word list ⇒ 128 word\" where\n  \"speck_128_256_encrypt plaintext keys = (\n    let left = ucast (drop_bit 64 plaintext);\n        right = ucast plaintext;\n        (c_l, c_r) = speck_128_256_encrypt_block (left, right) keys\n    in or (push_bit 64 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.986539"}}
{"instruction": "Translate this Top-Level Decrypt from SPECK-128/256 Python to Isabelle/HOL. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SPECK decryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return speck_decrypt_block(ciphertext, key_schedule)", "output": "definition speck_128_256_decrypt :: \"128 word ⇒ 64 word list ⇒ 128 word\" where\n  \"speck_128_256_decrypt ciphertext keys = (\n    let left = ucast (drop_bit 64 ciphertext);\n        right = ucast ciphertext;\n        (p_l, p_r) = speck_128_256_decrypt_block (left, right) keys\n    in or (push_bit 64 (ucast p_l)) (ucast p_r))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.987029"}}
{"instruction": "Translate this Modular Mask from SPECK-128/256 Python to Isabelle/HOL. Note: SPECK-128/256  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_mod_mask(word_size=64):\n    \"\"\"Create mask for 64-bit words\"\"\"\n    # word_size = 64\n    \n    return (1 <<  64) - 1", "output": "definition speck_128_256_mod_mask :: \"64 word\" where\n  \"speck_128_256_mod_mask = 18446744073709551615\"", "metadata": {"component_type": "Modular Mask", "difficulty": "easy", "semantic_group": "helpers", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "rounds": 34}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.988412"}}
{"instruction": "Translate this alpha Constant from SPECK-96/96 Python to Isabelle/HOL. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck alpha rotation constant (8-bit right rotate)\nalpha = 8", "output": "definition speck_96_96_alpha :: nat where \"speck_96_96_alpha = 8\"", "metadata": {"component_type": "alpha Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:47.992002"}}
{"instruction": "Translate this beta Constant from SPECK-96/96 Python to Isabelle/HOL. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck beta rotation constant (3-bit left rotate)\nbeta = 3", "output": "definition speck_96_96_beta :: nat where \"speck_96_96_beta = 3\"", "metadata": {"component_type": "beta Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:47.992239"}}
{"instruction": "Translate this rounds Constant from SPECK-96/96 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Number of rounds for SPECK(96/96)\nrounds = 28", "output": "definition speck_96_96_rounds :: nat where \"speck_96_96_rounds = 28\"", "metadata": {"component_type": "rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:47.992610"}}
{"instruction": "Translate this word_size Constant from SPECK-96/96 Python to Isabelle/HOL. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Word size in bits for SPECK(96/96)\nword_size = 48", "output": "definition speck_96_96_word_size :: nat where \"speck_96_96_word_size = 48\"", "metadata": {"component_type": "word_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:47.993075"}}
{"instruction": "Translate this block_size Constant from SPECK-96/96 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 96-bit block size\nblock_size = 96", "output": "definition speck_96_96_block_size :: nat where \"speck_96_96_block_size = 96\"", "metadata": {"component_type": "block_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:47.993759"}}
{"instruction": "Translate this key_size Constant from SPECK-96/96 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 96-bit key size\nkey_size = 96", "output": "definition speck_96_96_key_size :: nat where \"speck_96_96_key_size = 96\"", "metadata": {"component_type": "key_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:47.994282"}}
{"instruction": "Translate this Encrypt Round from SPECK-96/96 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_round(x, y, k, word_size = 48, mod_mask):\n    \"\"\"SPECK ARX encrypt round: (ROR_α(x) + y) ⊕ k, then x ⊕ ROL_β(y)\"\"\"\n    # Right rotate by alpha=(8 bits)\n    rs_x = ((x >> 8) | (x << (word_size - 8))) & mod_mask\n    \n    # Modular addition\n    add_sxy = (rs_x + y) & mod_mask\n    \n    # XOR with round key\n    new_x = k ^ add_sxy\n    \n    # Left rotate by beta=(3 bits)\n    ls_y = ((y << 3) | (y >> (word_size - 3))) & mod_mask\n    \n    # Final XOR\n    new_y = new_x ^ ls_y\n    \n    return new_x, new_y", "output": "definition speck_96_96_encrypt_round :: \"48 word ⇒ 48 word × 48 word ⇒ 48 word × 48 word\" where\n  \"speck_96_96_encrypt_round k xy = (\n    let (x, y) = xy;\n        rs_x = word_rotr speck_96_96_alpha x;\n        add_xy = rs_x + y;\n        new_x = xor add_xy k;\n        ls_y = word_rotl speck_96_96_beta y;\n        new_y = xor new_x ls_y\n    in (new_x, new_y))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.994732"}}
{"instruction": "Translate this Decrypt Round from SPECK-96/96 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_round(x, y, k, word_size = 48, mod_mask, mod_mask_sub):\n    \"\"\"SPECK ARX decrypt round (inverse operations)\"\"\"\n    # Recover original y: ROR_β(x ⊕ y)\n    # alpha = 8\n    # beta = 3\n    xor_xy = x ^ y\n    new_y = ((xor_xy >> 3) | (xor_xy << (word_size - 3))) & mod_mask\n    \n    # Recover original x: ROL_α((x ⊕ k) - y)\n    xor_xk = x ^ k\n    msub = (xor_xk - new_y) % mod_mask_sub\n    new_x = ((msub << 8) | (msub >> (word_size - 8))) & mod_mask\n    \n    return new_x, new_y", "output": "definition speck_96_96_decrypt_round_inverse :: \"48 word ⇒ 48 word × 48 word ⇒ 48 word × 48 word\" where\n  \"speck_96_96_decrypt_round_inverse k xy_new = (\n    let (x, y) = xy_new;\n        xor_xy = xor x y;\n        new_y = word_rotr speck_96_96_beta xor_xy;\n        xor_xk = xor x k;\n        msub = xor_xk - new_y;\n        new_x = word_rotl speck_96_96_alpha msub\n    in (new_x, new_y))\"", "metadata": {"component_type": "Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.995117"}}
{"instruction": "Translate this Key Schedule Recursive from SPECK-96/96 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_gen_key_schedule_rec(l_keys, k_keys, i, max_rounds= 28):\n    \"\"\"Recursive SPECK key schedule generation\"\"\"\n    max_rounds = 28\n    if i >= 28:\n        return k_keys\n    \n    # Apply round function to generate next key\n    # word_size = 48\n    new_l, new_k = speck_encrypt_round(\n        l_keys[i % len(l_keys)], \n        k_keys[i], \n        i,  # Round constant as key\n        48,\n        (1 << 48) - 1\n    )\n\n    # Append and recurse\n    l_keys.append(new_l)\n    k_keys.append(new_k)\n    \n    return speck_gen_key_schedule_rec(l_keys, k_keys, i + 1, max_rounds)", "output": "function speck_96_96_gen_key_schedule_rec :: \"48 word list ⇒ 48 word list ⇒ nat ⇒ 48 word list\" where\n  \"speck_96_96_gen_key_schedule_rec l_keys k_keys i = (\n     if i ≥ (28 - 1) then k_keys\n     else\n       let (new_l, new_k) = speck_96_96_encrypt_round (word_of_nat i) (l_keys ! i, k_keys ! i)\n       in speck_96_96_gen_key_schedule_rec (l_keys @ [new_l]) (k_keys @ [new_k]) (i + 1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(l, k, i). 27 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.995585"}}
{"instruction": "Translate this Key Schedule Wrapper from SPECK-96/96 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_generate_key_schedule(master_key):\n    \"\"\"Generate SPECK round keys from master key\"\"\"\n    # Extract key words\n    # word_size = 48\n    key_words = []\n    for i in range(2):\n        key_words.append((master_key >> (48 * i)) & ((1 << 48 - 1))\n    \n    # Initialize L and K arrays\n    l_keys = key_words[1:]  # All except first\n    k_keys = [key_words[0]]  # First word\n    \n    # Generate round keys\n    return speck_gen_key_schedule_rec(l_keys, k_keys, 0, 28)", "output": "definition speck_96_96_generate_key_schedule :: \"48 word list ⇒ 48 word list\" where\n  \"speck_96_96_generate_key_schedule initial_key_words = (\n     let k0 = [initial_key_words ! 0];\n         l0 = [initial_key_words ! 1]\n     in speck_96_96_gen_key_schedule_rec l0 k0 0)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.996034"}}
{"instruction": "Translate this Encrypt Iteration from SPECK-96/96 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply SPECK encryption rounds\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    # word_size = 48\n    new_x, new_y = speck_encrypt_round(\n        x, y, k, \n        48, \n        (1 << 48) - 1\n    )\n    \n    # Recursive call for next round\n    return speck_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun speck_96_96_encrypt_iterate :: \"48 word × 48 word ⇒ 48 word list ⇒ 48 word × 48 word\" where\n  \"speck_96_96_encrypt_iterate state [] = state\"\n| \"speck_96_96_encrypt_iterate state (k#ks) = speck_96_96_encrypt_iterate (speck_96_96_encrypt_round k state) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.996446"}}
{"instruction": "Translate this Decrypt Iteration from SPECK-96/96 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply SPECK decryption rounds (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    # word_size = 48\n    new_x, new_y = speck_decrypt_round(\n        x, y, k,\n        48,\n        (1 << 48) - 1,\n        (1 << 48)\n    )\n    \n    # Recursive call for previous round\n    return speck_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun speck_96_96_decrypt_iterate :: \"48 word × 48 word ⇒ 48 word list ⇒ 48 word × 48 word\" where\n  \"speck_96_96_decrypt_iterate state ks = foldl (λst_new k. speck_96_96_decrypt_round_inverse k st_new) state (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.996883"}}
{"instruction": "Translate this Encrypt Block from SPECK-96/96 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_block(plaintext, key_schedule):\n    \"\"\"SPECK block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 48\n    left = (plaintext >> 48) & ((1 << 48) - 1)\n    right = plaintext & ((1 << 48) - 1)\n    \n    # Apply all rounds\n    cipher_left, cipher_right = speck_encrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # word_size = 48\n    # Combine back\n    return (cipher_left << 48) | cipher_right", "output": "definition speck_96_96_encrypt_block :: \"48 word × 48 word ⇒ 48 word list ⇒ 48 word × 48 word\" where\n  \"speck_96_96_encrypt_block state keys = speck_96_96_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.997744"}}
{"instruction": "Translate this Decrypt Block from SPECK-96/96 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SPECK block decryption\"\"\"\n    # Split into left and right halves\n    left = (ciphertext >> 48) & ((1 << 48) - 1)\n    right = ciphertext & ((1 << 48) - 1)\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = speck_decrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 48) | plain_right", "output": "definition speck_96_96_decrypt_block :: \"48 word × 48 word ⇒ 48 word list ⇒ 48 word × 48 word\" where\n  \"speck_96_96_decrypt_block state keys = speck_96_96_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.998123"}}
{"instruction": "Translate this Block Splitting from SPECK-96/96 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_split_block(block):\n    \"\"\"Split 96-bit block into two 48-bit words\"\"\"\n    # word_size = 48\n    \n    mask = (1 << 48) - 1\n    left = (block >> 48) & (1 << 48) - 1\n    right = block & (1 << 48) - 1\n    return left, right", "output": "definition speck_96_96_split_block :: \"96 word ⇒ (48 word × 48 word)\" where\n  \"speck_96_96_split_block block = (\n    let left = ucast (drop_bit 48 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:47.999744"}}
{"instruction": "Translate this Block Combining from SPECK-96/96 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_combine_block(left, right):\n    \"\"\"Combine two 48-bit words into 96-bit block\"\"\"\n    # word_size = 48\n    \n    return (left << 48) | right", "output": "definition speck_96_96_combine_block :: \"48 word × 48 word ⇒ 96 word\" where\n  \"speck_96_96_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 48 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.000985"}}
{"instruction": "Translate this Top-Level Encrypt from SPECK-96/96 Python to Isabelle/HOL. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt(plaintext, master_key):\n    \"\"\"Top-level SPECK encryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return speck_encrypt_block(plaintext, key_schedule)", "output": "definition speck_96_96_encrypt :: \"96 word ⇒ 48 word list ⇒ 96 word\" where\n  \"speck_96_96_encrypt plaintext keys = (\n    let left = ucast (drop_bit 48 plaintext);\n        right = ucast plaintext;\n        (c_l, c_r) = speck_96_96_encrypt_block (left, right) keys\n    in or (push_bit 48 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.001397"}}
{"instruction": "Translate this Top-Level Decrypt from SPECK-96/96 Python to Isabelle/HOL. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SPECK decryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return speck_decrypt_block(ciphertext, key_schedule)", "output": "definition speck_96_96_decrypt :: \"96 word ⇒ 48 word list ⇒ 96 word\" where\n  \"speck_96_96_decrypt ciphertext keys = (\n    let left = ucast (drop_bit 48 ciphertext);\n        right = ucast ciphertext;\n        (p_l, p_r) = speck_96_96_decrypt_block (left, right) keys\n    in or (push_bit 48 (ucast p_l)) (ucast p_r))\"\n\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.001992"}}
{"instruction": "Translate this Modular Mask from SPECK-96/96 Python to Isabelle/HOL. Note: SPECK-96/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_mod_mask(word_size=48):\n    \"\"\"Create mask for 48-bit words\"\"\"\n    # word_size = 48\n    \n    return (1 <<  48) - 1", "output": "definition speck_96_96_mod_mask :: \"48 word\" where\n  \"speck_96_96_mod_mask = 281474976710655\"", "metadata": {"component_type": "Modular Mask", "difficulty": "easy", "semantic_group": "helpers", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 96, "rounds": 28}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.003349"}}
{"instruction": "Translate this alpha Constant from SPECK-48/72 Python to Isabelle/HOL. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck alpha rotation constant (8-bit right rotate)\nalpha = 8", "output": "definition speck_48_72_alpha :: nat where \"speck_48_72_alpha = 8\"", "metadata": {"component_type": "alpha Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.007358"}}
{"instruction": "Translate this beta Constant from SPECK-48/72 Python to Isabelle/HOL. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck beta rotation constant (3-bit left rotate)\nbeta = 3", "output": "definition speck_48_72_beta :: nat where \"speck_48_72_beta = 3\"", "metadata": {"component_type": "beta Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.007735"}}
{"instruction": "Translate this rounds Constant from SPECK-48/72 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Number of rounds for SPECK(48/72)\nrounds = 22", "output": "definition speck_48_72_rounds :: nat where \"speck_48_72_rounds = 22\"", "metadata": {"component_type": "rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:48.008325"}}
{"instruction": "Translate this word_size Constant from SPECK-48/72 Python to Isabelle/HOL. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Word size in bits for SPECK(48/72)\nword_size = 24", "output": "definition speck_48_72_word_size :: nat where \"speck_48_72_word_size = 24\"", "metadata": {"component_type": "word_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:48.008905"}}
{"instruction": "Translate this block_size Constant from SPECK-48/72 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 48-bit block size\nblock_size = 48", "output": "definition speck_48_72_block_size :: nat where \"speck_48_72_block_size = 48\"", "metadata": {"component_type": "block_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.009507"}}
{"instruction": "Translate this key_size Constant from SPECK-48/72 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 72-bit key size\nkey_size = 72", "output": "definition speck_48_72_key_size :: nat where \"speck_48_72_key_size = 72\"", "metadata": {"component_type": "key_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.010136"}}
{"instruction": "Translate this Encrypt Round from SPECK-48/72 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_round(x, y, k, word_size = 24, mod_mask):\n    \"\"\"SPECK ARX encrypt round: (ROR_α(x) + y) ⊕ k, then x ⊕ ROL_β(y)\"\"\"\n    # Right rotate by alpha=(8 bits)\n    rs_x = ((x >> 8) | (x << (word_size - 8))) & mod_mask\n    \n    # Modular addition\n    add_sxy = (rs_x + y) & mod_mask\n    \n    # XOR with round key\n    new_x = k ^ add_sxy\n    \n    # Left rotate by beta=(3 bits)\n    ls_y = ((y << 3) | (y >> (word_size - 3))) & mod_mask\n    \n    # Final XOR\n    new_y = new_x ^ ls_y\n    \n    return new_x, new_y", "output": "definition speck_48_72_encrypt_round :: \"24 word ⇒ 24 word × 24 word ⇒ 24 word × 24 word\" where\n  \"speck_48_72_encrypt_round k xy = (\n    let (x, y) = xy;\n        rs_x = word_rotr speck_48_72_alpha x;\n        add_xy = rs_x + y;\n        new_x = xor add_xy k;\n        ls_y = word_rotl speck_48_72_beta y;\n        new_y = xor new_x ls_y\n    in (new_x, new_y))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.010559"}}
{"instruction": "Translate this Decrypt Round from SPECK-48/72 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_round(x, y, k, word_size = 24, mod_mask, mod_mask_sub):\n    \"\"\"SPECK ARX decrypt round (inverse operations)\"\"\"\n    # Recover original y: ROR_β(x ⊕ y)\n    # alpha = 8\n    # beta = 3\n    xor_xy = x ^ y\n    new_y = ((xor_xy >> 3) | (xor_xy << (word_size - 3))) & mod_mask\n    \n    # Recover original x: ROL_α((x ⊕ k) - y)\n    xor_xk = x ^ k\n    msub = (xor_xk - new_y) % mod_mask_sub\n    new_x = ((msub << 8) | (msub >> (word_size - 8))) & mod_mask\n    \n    return new_x, new_y", "output": "definition speck_48_72_decrypt_round_inverse :: \"24 word ⇒ 24 word × 24 word ⇒ 24 word × 24 word\" where\n  \"speck_48_72_decrypt_round_inverse k xy_new = (\n    let (x, y) = xy_new;\n        xor_xy = xor x y;\n        new_y = word_rotr speck_48_72_beta xor_xy;\n        xor_xk = xor x k;\n        msub = xor_xk - new_y;\n        new_x = word_rotl speck_48_72_alpha msub\n    in (new_x, new_y))\"", "metadata": {"component_type": "Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.011518"}}
{"instruction": "Translate this Key Schedule Recursive from SPECK-48/72 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_gen_key_schedule_rec(l_keys, k_keys, i, max_rounds= 22):\n    \"\"\"Recursive SPECK key schedule generation\"\"\"\n    max_rounds = 22\n    if i >= 22:\n        return k_keys\n    \n    # Apply round function to generate next key\n    # word_size = 24\n    new_l, new_k = speck_encrypt_round(\n        l_keys[i % len(l_keys)], \n        k_keys[i], \n        i,  # Round constant as key\n        24,\n        (1 << 24) - 1\n    )\n\n    # Append and recurse\n    l_keys.append(new_l)\n    k_keys.append(new_k)\n    \n    return speck_gen_key_schedule_rec(l_keys, k_keys, i + 1, max_rounds)", "output": "function speck_48_72_gen_key_schedule_rec :: \"24 word list ⇒ 24 word list ⇒ nat ⇒ 24 word list\" where\n  \"speck_48_72_gen_key_schedule_rec l_keys k_keys i = (\n     if i ≥ (22 - 1) then k_keys\n     else\n       let (new_l, new_k) = speck_48_72_encrypt_round (word_of_nat i) (l_keys ! i, k_keys ! i)\n       in speck_48_72_gen_key_schedule_rec (l_keys @ [new_l]) (k_keys @ [new_k]) (i + 1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(l, k, i). 21 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.011886"}}
{"instruction": "Translate this Key Schedule Wrapper from SPECK-48/72 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_generate_key_schedule(master_key):\n    \"\"\"Generate SPECK round keys from master key\"\"\"\n    # Extract key words\n    # word_size = 24\n    key_words = []\n    for i in range(3):\n        key_words.append((master_key >> (24 * i)) & ((1 << 24 - 1))\n    \n    # Initialize L and K arrays\n    l_keys = key_words[1:]  # All except first\n    k_keys = [key_words[0]]  # First word\n    \n    # Generate round keys\n    return speck_gen_key_schedule_rec(l_keys, k_keys, 0, 22)", "output": "definition speck_48_72_generate_key_schedule :: \"24 word list ⇒ 24 word list\" where\n  \"speck_48_72_generate_key_schedule initial_key_words = (\n     let k0 = [initial_key_words ! 0];\n         l0 = [initial_key_words ! 1, initial_key_words ! 2]\n     in speck_48_72_gen_key_schedule_rec l0 k0 0)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.012272"}}
{"instruction": "Translate this Encrypt Iteration from SPECK-48/72 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply SPECK encryption rounds\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    # word_size = 24\n    new_x, new_y = speck_encrypt_round(\n        x, y, k, \n        24, \n        (1 << 24) - 1\n    )\n    \n    # Recursive call for next round\n    return speck_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun speck_48_72_encrypt_iterate :: \"24 word × 24 word ⇒ 24 word list ⇒ 24 word × 24 word\" where\n  \"speck_48_72_encrypt_iterate state [] = state\"\n| \"speck_48_72_encrypt_iterate state (k#ks) = speck_48_72_encrypt_iterate (speck_48_72_encrypt_round k state) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.012621"}}
{"instruction": "Translate this Decrypt Iteration from SPECK-48/72 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply SPECK decryption rounds (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    # word_size = 24\n    new_x, new_y = speck_decrypt_round(\n        x, y, k,\n        24,\n        (1 << 24) - 1,\n        (1 << 24)\n    )\n    \n    # Recursive call for previous round\n    return speck_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun speck_48_72_decrypt_iterate :: \"24 word × 24 word ⇒ 24 word list ⇒ 24 word × 24 word\" where\n  \"speck_48_72_decrypt_iterate state ks = foldl (λst_new k. speck_48_72_decrypt_round_inverse k st_new) state (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.013007"}}
{"instruction": "Translate this Encrypt Block from SPECK-48/72 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_block(plaintext, key_schedule):\n    \"\"\"SPECK block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 24\n    left = (plaintext >> 24) & ((1 << 24) - 1)\n    right = plaintext & ((1 << 24) - 1)\n    \n    # Apply all rounds\n    cipher_left, cipher_right = speck_encrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # word_size = 24\n    # Combine back\n    return (cipher_left << 24) | cipher_right", "output": "definition speck_48_72_encrypt_block :: \"24 word × 24 word ⇒ 24 word list ⇒ 24 word × 24 word\" where\n  \"speck_48_72_encrypt_block state keys = speck_48_72_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.013548"}}
{"instruction": "Translate this Decrypt Block from SPECK-48/72 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SPECK block decryption\"\"\"\n    # Split into left and right halves\n    left = (ciphertext >> 24) & ((1 << 24) - 1)\n    right = ciphertext & ((1 << 24) - 1)\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = speck_decrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 24) | plain_right", "output": "definition speck_48_72_decrypt_block :: \"24 word × 24 word ⇒ 24 word list ⇒ 24 word × 24 word\" where\n  \"speck_48_72_decrypt_block state keys = speck_48_72_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.014114"}}
{"instruction": "Translate this Block Splitting from SPECK-48/72 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_split_block(block):\n    \"\"\"Split 48-bit block into two 24-bit words\"\"\"\n    # word_size = 24\n    \n    mask = (1 << 24) - 1\n    left = (block >> 24) & (1 << 24) - 1\n    right = block & (1 << 24) - 1\n    return left, right", "output": "definition speck_48_72_split_block :: \"48 word ⇒ (24 word × 24 word)\" where\n  \"speck_48_72_split_block block = (\n    let left = ucast (drop_bit 24 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.016013"}}
{"instruction": "Translate this Block Combining from SPECK-48/72 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_combine_block(left, right):\n    \"\"\"Combine two 24-bit words into 48-bit block\"\"\"\n    # word_size = 24\n    \n    return (left << 24) | right", "output": "definition speck_48_72_combine_block :: \"24 word × 24 word ⇒ 48 word\" where\n  \"speck_48_72_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 24 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.017054"}}
{"instruction": "Translate this Top-Level Encrypt from SPECK-48/72 Python to Isabelle/HOL. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt(plaintext, master_key):\n    \"\"\"Top-level SPECK encryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return speck_encrypt_block(plaintext, key_schedule)", "output": "definition speck_48_72_encrypt :: \"48 word ⇒ 24 word list ⇒ 48 word\" where\n  \"speck_48_72_encrypt plaintext keys = (\n    let left = ucast (drop_bit 24 plaintext);\n        right = ucast plaintext;\n        (c_l, c_r) = speck_48_72_encrypt_block (left, right) keys\n    in or (push_bit 24 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.017388"}}
{"instruction": "Translate this Top-Level Decrypt from SPECK-48/72 Python to Isabelle/HOL. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SPECK decryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return speck_decrypt_block(ciphertext, key_schedule)", "output": "definition speck_48_72_decrypt :: \"48 word ⇒ 24 word list ⇒ 48 word\" where\n  \"speck_48_72_decrypt ciphertext keys = (\n    let left = ucast (drop_bit 24 ciphertext);\n        right = ucast ciphertext;\n        (p_l, p_r) = speck_48_72_decrypt_block (left, right) keys\n    in or (push_bit 24 (ucast p_l)) (ucast p_r))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.017661"}}
{"instruction": "Translate this Modular Mask from SPECK-48/72 Python to Isabelle/HOL. Note: SPECK-48/72  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_mod_mask(word_size=24):\n    \"\"\"Create mask for 24-bit words\"\"\"\n    # word_size = 24\n    \n    return (1 <<  24) - 1", "output": "definition speck_48_72_mod_mask :: \"24 word\" where\n  \"speck_48_72_mod_mask = 16777215\"", "metadata": {"component_type": "Modular Mask", "difficulty": "easy", "semantic_group": "helpers", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 72, "rounds": 22}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.018371"}}
{"instruction": "Translate this alpha Constant from SPECK-48/96 Python to Isabelle/HOL. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck alpha rotation constant (8-bit right rotate)\nalpha = 8", "output": "definition speck_48_96_alpha :: nat where \"speck_48_96_alpha = 8\"", "metadata": {"component_type": "alpha Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.021667"}}
{"instruction": "Translate this beta Constant from SPECK-48/96 Python to Isabelle/HOL. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck beta rotation constant (3-bit left rotate)\nbeta = 3", "output": "definition speck_48_96_beta :: nat where \"speck_48_96_beta = 3\"", "metadata": {"component_type": "beta Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.021879"}}
{"instruction": "Translate this rounds Constant from SPECK-48/96 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Number of rounds for SPECK(48/96)\nrounds = 23", "output": "definition speck_48_96_rounds :: nat where \"speck_48_96_rounds = 23\"", "metadata": {"component_type": "rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:48.022231"}}
{"instruction": "Translate this word_size Constant from SPECK-48/96 Python to Isabelle/HOL. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Word size in bits for SPECK(48/96)\nword_size = 24", "output": "definition speck_48_96_word_size :: nat where \"speck_48_96_word_size = 24\"", "metadata": {"component_type": "word_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:48.022565"}}
{"instruction": "Translate this block_size Constant from SPECK-48/96 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 48-bit block size\nblock_size = 48", "output": "definition speck_48_96_block_size :: nat where \"speck_48_96_block_size = 48\"", "metadata": {"component_type": "block_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.022900"}}
{"instruction": "Translate this key_size Constant from SPECK-48/96 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 96-bit key size\nkey_size = 96", "output": "definition speck_48_96_key_size :: nat where \"speck_48_96_key_size = 96\"", "metadata": {"component_type": "key_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.023321"}}
{"instruction": "Translate this Encrypt Round from SPECK-48/96 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_round(x, y, k, word_size = 24, mod_mask):\n    \"\"\"SPECK ARX encrypt round: (ROR_α(x) + y) ⊕ k, then x ⊕ ROL_β(y)\"\"\"\n    # Right rotate by alpha=(8 bits)\n    rs_x = ((x >> 8) | (x << (word_size - 8))) & mod_mask\n    \n    # Modular addition\n    add_sxy = (rs_x + y) & mod_mask\n    \n    # XOR with round key\n    new_x = k ^ add_sxy\n    \n    # Left rotate by beta=(3 bits)\n    ls_y = ((y << 3) | (y >> (word_size - 3))) & mod_mask\n    \n    # Final XOR\n    new_y = new_x ^ ls_y\n    \n    return new_x, new_y", "output": "definition speck_48_96_encrypt_round :: \"24 word ⇒ 24 word × 24 word ⇒ 24 word × 24 word\" where\n  \"speck_48_96_encrypt_round k xy = (\n    let (x, y) = xy;\n        rs_x = word_rotr speck_48_96_alpha x;\n        add_xy = rs_x + y;\n        new_x = xor add_xy k;\n        ls_y = word_rotl speck_48_96_beta y;\n        new_y = xor new_x ls_y\n    in (new_x, new_y))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.023713"}}
{"instruction": "Translate this Decrypt Round from SPECK-48/96 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_round(x, y, k, word_size = 24, mod_mask, mod_mask_sub):\n    \"\"\"SPECK ARX decrypt round (inverse operations)\"\"\"\n    # Recover original y: ROR_β(x ⊕ y)\n    # alpha = 8\n    # beta = 3\n    xor_xy = x ^ y\n    new_y = ((xor_xy >> 3) | (xor_xy << (word_size - 3))) & mod_mask\n    \n    # Recover original x: ROL_α((x ⊕ k) - y)\n    xor_xk = x ^ k\n    msub = (xor_xk - new_y) % mod_mask_sub\n    new_x = ((msub << 8) | (msub >> (word_size - 8))) & mod_mask\n    \n    return new_x, new_y", "output": "definition speck_48_96_decrypt_round_inverse :: \"24 word ⇒ 24 word × 24 word ⇒ 24 word × 24 word\" where\n  \"speck_48_96_decrypt_round_inverse k xy_new = (\n    let (x, y) = xy_new;\n        xor_xy = xor x y;\n        new_y = word_rotr speck_48_96_beta xor_xy;\n        xor_xk = xor x k;\n        msub = xor_xk - new_y;\n        new_x = word_rotl speck_48_96_alpha msub\n    in (new_x, new_y))\"", "metadata": {"component_type": "Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.024162"}}
{"instruction": "Translate this Key Schedule Recursive from SPECK-48/96 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_gen_key_schedule_rec(l_keys, k_keys, i, max_rounds= 23):\n    \"\"\"Recursive SPECK key schedule generation\"\"\"\n    max_rounds = 23\n    if i >= 23:\n        return k_keys\n    \n    # Apply round function to generate next key\n    # word_size = 24\n    new_l, new_k = speck_encrypt_round(\n        l_keys[i % len(l_keys)], \n        k_keys[i], \n        i,  # Round constant as key\n        24,\n        (1 << 24) - 1\n    )\n\n    # Append and recurse\n    l_keys.append(new_l)\n    k_keys.append(new_k)\n    \n    return speck_gen_key_schedule_rec(l_keys, k_keys, i + 1, max_rounds)", "output": "function speck_48_96_gen_key_schedule_rec :: \"24 word list ⇒ 24 word list ⇒ nat ⇒ 24 word list\" where\n  \"speck_48_96_gen_key_schedule_rec l_keys k_keys i = (\n     if i ≥ (23 - 1) then k_keys\n     else\n       let (new_l, new_k) = speck_48_96_encrypt_round (word_of_nat i) (l_keys ! i, k_keys ! i)\n       in speck_48_96_gen_key_schedule_rec (l_keys @ [new_l]) (k_keys @ [new_k]) (i + 1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(l, k, i). 22 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.024595"}}
{"instruction": "Translate this Key Schedule Wrapper from SPECK-48/96 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_generate_key_schedule(master_key):\n    \"\"\"Generate SPECK round keys from master key\"\"\"\n    # Extract key words\n    # word_size = 24\n    key_words = []\n    for i in range(4):\n        key_words.append((master_key >> (24 * i)) & ((1 << 24 - 1))\n    \n    # Initialize L and K arrays\n    l_keys = key_words[1:]  # All except first\n    k_keys = [key_words[0]]  # First word\n    \n    # Generate round keys\n    return speck_gen_key_schedule_rec(l_keys, k_keys, 0, 23)", "output": "definition speck_48_96_generate_key_schedule :: \"24 word list ⇒ 24 word list\" where\n  \"speck_48_96_generate_key_schedule initial_key_words = (\n     let k0 = [initial_key_words ! 0];\n         l0 = [initial_key_words ! 1, initial_key_words ! 2, initial_key_words ! 3]\n     in speck_48_96_gen_key_schedule_rec l0 k0 0)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.024944"}}
{"instruction": "Translate this Encrypt Iteration from SPECK-48/96 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply SPECK encryption rounds\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    # word_size = 24\n    new_x, new_y = speck_encrypt_round(\n        x, y, k, \n        24, \n        (1 << 24) - 1\n    )\n    \n    # Recursive call for next round\n    return speck_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun speck_48_96_encrypt_iterate :: \"24 word × 24 word ⇒ 24 word list ⇒ 24 word × 24 word\" where\n  \"speck_48_96_encrypt_iterate state [] = state\"\n| \"speck_48_96_encrypt_iterate state (k#ks) = speck_48_96_encrypt_iterate (speck_48_96_encrypt_round k state) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.025329"}}
{"instruction": "Translate this Decrypt Iteration from SPECK-48/96 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply SPECK decryption rounds (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    # word_size = 24\n    new_x, new_y = speck_decrypt_round(\n        x, y, k,\n        24,\n        (1 << 24) - 1,\n        (1 << 24)\n    )\n    \n    # Recursive call for previous round\n    return speck_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun speck_48_96_decrypt_iterate :: \"24 word × 24 word ⇒ 24 word list ⇒ 24 word × 24 word\" where\n  \"speck_48_96_decrypt_iterate state ks = foldl (λst_new k. speck_48_96_decrypt_round_inverse k st_new) state (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.025806"}}
{"instruction": "Translate this Encrypt Block from SPECK-48/96 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_block(plaintext, key_schedule):\n    \"\"\"SPECK block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 24\n    left = (plaintext >> 24) & ((1 << 24) - 1)\n    right = plaintext & ((1 << 24) - 1)\n    \n    # Apply all rounds\n    cipher_left, cipher_right = speck_encrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # word_size = 24\n    # Combine back\n    return (cipher_left << 24) | cipher_right", "output": "definition speck_48_96_encrypt_block :: \"24 word × 24 word ⇒ 24 word list ⇒ 24 word × 24 word\" where\n  \"speck_48_96_encrypt_block state keys = speck_48_96_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.026445"}}
{"instruction": "Translate this Decrypt Block from SPECK-48/96 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SPECK block decryption\"\"\"\n    # Split into left and right halves\n    left = (ciphertext >> 24) & ((1 << 24) - 1)\n    right = ciphertext & ((1 << 24) - 1)\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = speck_decrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 24) | plain_right", "output": "definition speck_48_96_decrypt_block :: \"24 word × 24 word ⇒ 24 word list ⇒ 24 word × 24 word\" where\n  \"speck_48_96_decrypt_block state keys = speck_48_96_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.026802"}}
{"instruction": "Translate this Block Splitting from SPECK-48/96 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_split_block(block):\n    \"\"\"Split 48-bit block into two 24-bit words\"\"\"\n    # word_size = 24\n    \n    mask = (1 << 24) - 1\n    left = (block >> 24) & (1 << 24) - 1\n    right = block & (1 << 24) - 1\n    return left, right", "output": "definition speck_48_96_split_block :: \"48 word ⇒ (24 word × 24 word)\" where\n  \"speck_48_96_split_block block = (\n    let left = ucast (drop_bit 24 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.027812"}}
{"instruction": "Translate this Block Combining from SPECK-48/96 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_combine_block(left, right):\n    \"\"\"Combine two 24-bit words into 48-bit block\"\"\"\n    # word_size = 24\n    \n    return (left << 24) | right", "output": "definition speck_48_96_combine_block :: \"24 word × 24 word ⇒ 48 word\" where\n  \"speck_48_96_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 24 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.028861"}}
{"instruction": "Translate this Top-Level Encrypt from SPECK-48/96 Python to Isabelle/HOL. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt(plaintext, master_key):\n    \"\"\"Top-level SPECK encryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return speck_encrypt_block(plaintext, key_schedule)", "output": "definition speck_48_96_encrypt :: \"48 word ⇒ 24 word list ⇒ 48 word\" where\n  \"speck_48_96_encrypt plaintext keys = (\n    let left = ucast (drop_bit 24 plaintext);\n        right = ucast plaintext;\n        (c_l, c_r) = speck_48_96_encrypt_block (left, right) keys\n    in or (push_bit 24 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.029350"}}
{"instruction": "Translate this Top-Level Decrypt from SPECK-48/96 Python to Isabelle/HOL. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SPECK decryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return speck_decrypt_block(ciphertext, key_schedule)", "output": "definition speck_48_96_decrypt :: \"48 word ⇒ 24 word list ⇒ 48 word\" where\n  \"speck_48_96_decrypt ciphertext keys = (\n    let left = ucast (drop_bit 24 ciphertext);\n        right = ucast ciphertext;\n        (p_l, p_r) = speck_48_96_decrypt_block (left, right) keys\n    in or (push_bit 24 (ucast p_l)) (ucast p_r))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.029869"}}
{"instruction": "Translate this Modular Mask from SPECK-48/96 Python to Isabelle/HOL. Note: SPECK-48/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_mod_mask(word_size=24):\n    \"\"\"Create mask for 24-bit words\"\"\"\n    # word_size = 24\n    \n    return (1 <<  24) - 1", "output": "definition speck_48_96_mod_mask :: \"24 word\" where\n  \"speck_48_96_mod_mask = 16777215\"", "metadata": {"component_type": "Modular Mask", "difficulty": "easy", "semantic_group": "helpers", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 48, "key_size": 96, "rounds": 23}, "algorithm_params": {"word_size": 24, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.031470"}}
{"instruction": "Translate this alpha Constant from SPECK-128/128 Python to Isabelle/HOL. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck alpha rotation constant (8-bit right rotate)\nalpha = 8", "output": "definition speck_128_128_alpha :: nat where \"speck_128_128_alpha = 8\"", "metadata": {"component_type": "alpha Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.036194"}}
{"instruction": "Translate this beta Constant from SPECK-128/128 Python to Isabelle/HOL. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck beta rotation constant (3-bit left rotate)\nbeta = 3", "output": "definition speck_128_128_beta :: nat where \"speck_128_128_beta = 3\"", "metadata": {"component_type": "beta Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.036431"}}
{"instruction": "Translate this rounds Constant from SPECK-128/128 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Number of rounds for SPECK(128/128)\nrounds = 32", "output": "definition speck_128_128_rounds :: nat where \"speck_128_128_rounds = 32\"", "metadata": {"component_type": "rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:48.036779"}}
{"instruction": "Translate this word_size Constant from SPECK-128/128 Python to Isabelle/HOL. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Word size in bits for SPECK(128/128)\nword_size = 64", "output": "definition speck_128_128_word_size :: nat where \"speck_128_128_word_size = 64\"", "metadata": {"component_type": "word_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:48.037118"}}
{"instruction": "Translate this block_size Constant from SPECK-128/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 128-bit block size\nblock_size = 128", "output": "definition speck_128_128_block_size :: nat where \"speck_128_128_block_size = 128\"", "metadata": {"component_type": "block_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.037608"}}
{"instruction": "Translate this key_size Constant from SPECK-128/128 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 128-bit key size\nkey_size = 128", "output": "definition speck_128_128_key_size :: nat where \"speck_128_128_key_size = 128\"", "metadata": {"component_type": "key_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.038409"}}
{"instruction": "Translate this Encrypt Round from SPECK-128/128 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_round(x, y, k, word_size = 64, mod_mask):\n    \"\"\"SPECK ARX encrypt round: (ROR_α(x) + y) ⊕ k, then x ⊕ ROL_β(y)\"\"\"\n    # Right rotate by alpha=(8 bits)\n    rs_x = ((x >> 8) | (x << (word_size - 8))) & mod_mask\n    \n    # Modular addition\n    add_sxy = (rs_x + y) & mod_mask\n    \n    # XOR with round key\n    new_x = k ^ add_sxy\n    \n    # Left rotate by beta=(3 bits)\n    ls_y = ((y << 3) | (y >> (word_size - 3))) & mod_mask\n    \n    # Final XOR\n    new_y = new_x ^ ls_y\n    \n    return new_x, new_y", "output": "definition speck_128_128_encrypt_round :: \"64 word ⇒ 64 word × 64 word ⇒ 64 word × 64 word\" where\n  \"speck_128_128_encrypt_round k xy = (\n    let (x, y) = xy;\n        rs_x = word_rotr speck_128_128_alpha x;\n        add_xy = rs_x + y;\n        new_x = xor add_xy k;\n        ls_y = word_rotl speck_128_128_beta y;\n        new_y = xor new_x ls_y\n    in (new_x, new_y))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.038702"}}
{"instruction": "Translate this Decrypt Round from SPECK-128/128 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_round(x, y, k, word_size = 64, mod_mask, mod_mask_sub):\n    \"\"\"SPECK ARX decrypt round (inverse operations)\"\"\"\n    # Recover original y: ROR_β(x ⊕ y)\n    # alpha = 8\n    # beta = 3\n    xor_xy = x ^ y\n    new_y = ((xor_xy >> 3) | (xor_xy << (word_size - 3))) & mod_mask\n    \n    # Recover original x: ROL_α((x ⊕ k) - y)\n    xor_xk = x ^ k\n    msub = (xor_xk - new_y) % mod_mask_sub\n    new_x = ((msub << 8) | (msub >> (word_size - 8))) & mod_mask\n    \n    return new_x, new_y", "output": "definition speck_128_128_decrypt_round_inverse :: \"64 word ⇒ 64 word × 64 word ⇒ 64 word × 64 word\" where\n  \"speck_128_128_decrypt_round_inverse k xy_new = (\n    let (x, y) = xy_new;\n        xor_xy = xor x y;\n        new_y = word_rotr speck_128_128_beta xor_xy;\n        xor_xk = xor x k;\n        msub = xor_xk - new_y;\n        new_x = word_rotl speck_128_128_alpha msub\n    in (new_x, new_y))\"", "metadata": {"component_type": "Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.038961"}}
{"instruction": "Translate this Key Schedule Recursive from SPECK-128/128 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_gen_key_schedule_rec(l_keys, k_keys, i, max_rounds= 32):\n    \"\"\"Recursive SPECK key schedule generation\"\"\"\n    max_rounds = 32\n    if i >= 32:\n        return k_keys\n    \n    # Apply round function to generate next key\n    # word_size = 64\n    new_l, new_k = speck_encrypt_round(\n        l_keys[i % len(l_keys)], \n        k_keys[i], \n        i,  # Round constant as key\n        64,\n        (1 << 64) - 1\n    )\n\n    # Append and recurse\n    l_keys.append(new_l)\n    k_keys.append(new_k)\n    \n    return speck_gen_key_schedule_rec(l_keys, k_keys, i + 1, max_rounds)", "output": "function speck_128_128_gen_key_schedule_rec :: \"64 word list ⇒ 64 word list ⇒ nat ⇒ 64 word list\" where\n  \"speck_128_128_gen_key_schedule_rec l_keys k_keys i = (\n     if i ≥ (32 - 1) then k_keys\n     else\n       let (new_l, new_k) = speck_128_128_encrypt_round (word_of_nat i) (l_keys ! i, k_keys ! i)\n       in speck_128_128_gen_key_schedule_rec (l_keys @ [new_l]) (k_keys @ [new_k]) (i + 1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(l, k, i). 31 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.039358"}}
{"instruction": "Translate this Key Schedule Wrapper from SPECK-128/128 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_generate_key_schedule(master_key):\n    \"\"\"Generate SPECK round keys from master key\"\"\"\n    # Extract key words\n    # word_size = 64\n    key_words = []\n    for i in range(2):\n        key_words.append((master_key >> (64 * i)) & ((1 << 64 - 1))\n    \n    # Initialize L and K arrays\n    l_keys = key_words[1:]  # All except first\n    k_keys = [key_words[0]]  # First word\n    \n    # Generate round keys\n    return speck_gen_key_schedule_rec(l_keys, k_keys, 0, 32)", "output": "definition speck_128_128_generate_key_schedule :: \"64 word list ⇒ 64 word list\" where\n  \"speck_128_128_generate_key_schedule initial_key_words = (\n     let k0 = [initial_key_words ! 0];\n         l0 = [initial_key_words ! 1]\n     in speck_128_128_gen_key_schedule_rec l0 k0 0)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.039730"}}
{"instruction": "Translate this Encrypt Iteration from SPECK-128/128 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply SPECK encryption rounds\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    # word_size = 64\n    new_x, new_y = speck_encrypt_round(\n        x, y, k, \n        64, \n        (1 << 64) - 1\n    )\n    \n    # Recursive call for next round\n    return speck_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun speck_128_128_encrypt_iterate :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"speck_128_128_encrypt_iterate state [] = state\"\n| \"speck_128_128_encrypt_iterate state (k#ks) = speck_128_128_encrypt_iterate (speck_128_128_encrypt_round k state) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.040031"}}
{"instruction": "Translate this Decrypt Iteration from SPECK-128/128 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply SPECK decryption rounds (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    # word_size = 64\n    new_x, new_y = speck_decrypt_round(\n        x, y, k,\n        64,\n        (1 << 64) - 1,\n        (1 << 64)\n    )\n    \n    # Recursive call for previous round\n    return speck_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun speck_128_128_decrypt_iterate :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"speck_128_128_decrypt_iterate state ks = foldl (λst_new k. speck_128_128_decrypt_round_inverse k st_new) state (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.040335"}}
{"instruction": "Translate this Encrypt Block from SPECK-128/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_block(plaintext, key_schedule):\n    \"\"\"SPECK block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 64\n    left = (plaintext >> 64) & ((1 << 64) - 1)\n    right = plaintext & ((1 << 64) - 1)\n    \n    # Apply all rounds\n    cipher_left, cipher_right = speck_encrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # word_size = 64\n    # Combine back\n    return (cipher_left << 64) | cipher_right", "output": "definition speck_128_128_encrypt_block :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"speck_128_128_encrypt_block state keys = speck_128_128_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.040609"}}
{"instruction": "Translate this Decrypt Block from SPECK-128/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SPECK block decryption\"\"\"\n    # Split into left and right halves\n    left = (ciphertext >> 64) & ((1 << 64) - 1)\n    right = ciphertext & ((1 << 64) - 1)\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = speck_decrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 64) | plain_right", "output": "definition speck_128_128_decrypt_block :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"speck_128_128_decrypt_block state keys = speck_128_128_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.040895"}}
{"instruction": "Translate this Block Splitting from SPECK-128/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_split_block(block):\n    \"\"\"Split 128-bit block into two 64-bit words\"\"\"\n    # word_size = 64\n    \n    mask = (1 << 64) - 1\n    left = (block >> 64) & (1 << 64) - 1\n    right = block & (1 << 64) - 1\n    return left, right", "output": "definition speck_128_128_split_block :: \"128 word ⇒ (64 word × 64 word)\" where\n  \"speck_128_128_split_block block = (\n    let left = ucast (drop_bit 64 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.041865"}}
{"instruction": "Translate this Block Combining from SPECK-128/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_combine_block(left, right):\n    \"\"\"Combine two 64-bit words into 128-bit block\"\"\"\n    # word_size = 64\n    \n    return (left << 64) | right", "output": "definition speck_128_128_combine_block :: \"64 word × 64 word ⇒ 128 word\" where\n  \"speck_128_128_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 64 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.042969"}}
{"instruction": "Translate this Top-Level Encrypt from SPECK-128/128 Python to Isabelle/HOL. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt(plaintext, master_key):\n    \"\"\"Top-level SPECK encryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return speck_encrypt_block(plaintext, key_schedule)", "output": "definition speck_128_128_encrypt :: \"128 word ⇒ 64 word list ⇒ 128 word\" where\n  \"speck_128_128_encrypt plaintext keys = (\n    let left = ucast (drop_bit 64 plaintext);\n        right = ucast plaintext;\n        (c_l, c_r) = speck_128_128_encrypt_block (left, right) keys\n    in or (push_bit 64 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.043279"}}
{"instruction": "Translate this Top-Level Decrypt from SPECK-128/128 Python to Isabelle/HOL. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SPECK decryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return speck_decrypt_block(ciphertext, key_schedule)", "output": "definition speck_128_128_decrypt :: \"128 word ⇒ 64 word list ⇒ 128 word\" where\n  \"speck_128_128_decrypt ciphertext keys = (\n    let left = ucast (drop_bit 64 ciphertext);\n        right = ucast ciphertext;\n        (p_l, p_r) = speck_128_128_decrypt_block (left, right) keys\n    in or (push_bit 64 (ucast p_l)) (ucast p_r))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.043555"}}
{"instruction": "Translate this Modular Mask from SPECK-128/128 Python to Isabelle/HOL. Note: SPECK-128/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_mod_mask(word_size=64):\n    \"\"\"Create mask for 64-bit words\"\"\"\n    # word_size = 64\n    \n    return (1 <<  64) - 1", "output": "definition speck_128_128_mod_mask :: \"64 word\" where\n  \"speck_128_128_mod_mask = 18446744073709551615\"", "metadata": {"component_type": "Modular Mask", "difficulty": "easy", "semantic_group": "helpers", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "rounds": 32}, "algorithm_params": {"word_size": 64, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 2, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.044322"}}
{"instruction": "Translate this alpha Constant from SPECK-32/64 Python to Isabelle/HOL. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "# Speck alpha rotation constant (7-bit right rotate)\nalpha = 7", "output": "definition speck_32_64_alpha :: nat where \"speck_32_64_alpha = 7\"", "metadata": {"component_type": "alpha Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.048396"}}
{"instruction": "Translate this beta Constant from SPECK-32/64 Python to Isabelle/HOL. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "# Speck beta rotation constant (2-bit left rotate)\nbeta = 2", "output": "definition speck_32_64_beta :: nat where \"speck_32_64_beta = 2\"", "metadata": {"component_type": "beta Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.048626"}}
{"instruction": "Translate this rounds Constant from SPECK-32/64 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (7-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "# Number of rounds for SPECK(32/64)\nrounds = 22", "output": "definition speck_32_64_rounds :: nat where \"speck_32_64_rounds = 22\"", "metadata": {"component_type": "rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:48.049022"}}
{"instruction": "Translate this word_size Constant from SPECK-32/64 Python to Isabelle/HOL. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "# Word size in bits for SPECK(32/64)\nword_size = 16", "output": "definition speck_32_64_word_size :: nat where \"speck_32_64_word_size = 16\"", "metadata": {"component_type": "word_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:48.050113"}}
{"instruction": "Translate this block_size Constant from SPECK-32/64 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "# 32-bit block size\nblock_size = 32", "output": "definition speck_32_64_block_size :: nat where \"speck_32_64_block_size = 32\"", "metadata": {"component_type": "block_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.050680"}}
{"instruction": "Translate this key_size Constant from SPECK-32/64 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "# 64-bit key size\nkey_size = 64", "output": "definition speck_32_64_key_size :: nat where \"speck_32_64_key_size = 64\"", "metadata": {"component_type": "key_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.051067"}}
{"instruction": "Translate this Encrypt Round from SPECK-32/64 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (7-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "def speck_encrypt_round(x, y, k, word_size = 16, mod_mask):\n    \"\"\"SPECK ARX encrypt round: (ROR_α(x) + y) ⊕ k, then x ⊕ ROL_β(y)\"\"\"\n    # Right rotate by alpha=(7 bits)\n    rs_x = ((x >> 7) | (x << (word_size - 7))) & mod_mask\n    \n    # Modular addition\n    add_sxy = (rs_x + y) & mod_mask\n    \n    # XOR with round key\n    new_x = k ^ add_sxy\n    \n    # Left rotate by beta=(2 bits)\n    ls_y = ((y << 2) | (y >> (word_size - 2))) & mod_mask\n    \n    # Final XOR\n    new_y = new_x ^ ls_y\n    \n    return new_x, new_y", "output": "definition speck_32_64_encrypt_round :: \"16 word ⇒ 16 word × 16 word ⇒ 16 word × 16 word\" where\n  \"speck_32_64_encrypt_round k xy = (\n    let (x, y) = xy;\n        rs_x = word_rotr speck_32_64_alpha x;\n        add_xy = rs_x + y;\n        new_x = xor add_xy k;\n        ls_y = word_rotl speck_32_64_beta y;\n        new_y = xor new_x ls_y\n    in (new_x, new_y))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.051363"}}
{"instruction": "Translate this Decrypt Round from SPECK-32/64 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (7-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "def speck_decrypt_round(x, y, k, word_size = 16, mod_mask, mod_mask_sub):\n    \"\"\"SPECK ARX decrypt round (inverse operations)\"\"\"\n    # Recover original y: ROR_β(x ⊕ y)\n    # alpha = 7\n    # beta = 2\n    xor_xy = x ^ y\n    new_y = ((xor_xy >> 2) | (xor_xy << (word_size - 2))) & mod_mask\n    \n    # Recover original x: ROL_α((x ⊕ k) - y)\n    xor_xk = x ^ k\n    msub = (xor_xk - new_y) % mod_mask_sub\n    new_x = ((msub << 7) | (msub >> (word_size - 7))) & mod_mask\n    \n    return new_x, new_y", "output": "definition speck_32_64_decrypt_round_inverse :: \"16 word ⇒ 16 word × 16 word ⇒ 16 word × 16 word\" where\n  \"speck_32_64_decrypt_round_inverse k xy_new = (\n    let (x, y) = xy_new;\n        xor_xy = xor x y;\n        new_y = word_rotr speck_32_64_beta xor_xy;\n        xor_xk = xor x k;\n        msub = xor_xk - new_y;\n        new_x = word_rotl speck_32_64_alpha msub\n    in (new_x, new_y))\"", "metadata": {"component_type": "Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.051627"}}
{"instruction": "Translate this Key Schedule Recursive from SPECK-32/64 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "def speck_gen_key_schedule_rec(l_keys, k_keys, i, max_rounds= 22):\n    \"\"\"Recursive SPECK key schedule generation\"\"\"\n    max_rounds = 22\n    if i >= 22:\n        return k_keys\n    \n    # Apply round function to generate next key\n    # word_size = 16\n    new_l, new_k = speck_encrypt_round(\n        l_keys[i % len(l_keys)], \n        k_keys[i], \n        i,  # Round constant as key\n        16,\n        (1 << 16) - 1\n    )\n\n    # Append and recurse\n    l_keys.append(new_l)\n    k_keys.append(new_k)\n    \n    return speck_gen_key_schedule_rec(l_keys, k_keys, i + 1, max_rounds)", "output": "function speck_32_64_gen_key_schedule_rec :: \"16 word list ⇒ 16 word list ⇒ nat ⇒ 16 word list\" where\n  \"speck_32_64_gen_key_schedule_rec l_keys k_keys i = (\n     if i ≥ (22 - 1) then k_keys\n     else\n       let (new_l, new_k) = speck_32_64_encrypt_round (word_of_nat i) (l_keys ! i, k_keys ! i)\n       in speck_32_64_gen_key_schedule_rec (l_keys @ [new_l]) (k_keys @ [new_k]) (i + 1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(l, k, i). 21 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.052041"}}
{"instruction": "Translate this Key Schedule Wrapper from SPECK-32/64 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "def speck_generate_key_schedule(master_key):\n    \"\"\"Generate SPECK round keys from master key\"\"\"\n    # Extract key words\n    # word_size = 16\n    key_words = []\n    for i in range(4):\n        key_words.append((master_key >> (16 * i)) & ((1 << 16 - 1))\n    \n    # Initialize L and K arrays\n    l_keys = key_words[1:]  # All except first\n    k_keys = [key_words[0]]  # First word\n    \n    # Generate round keys\n    return speck_gen_key_schedule_rec(l_keys, k_keys, 0, 22)", "output": "definition speck_32_64_generate_key_schedule :: \"16 word list ⇒ 16 word list\" where\n  \"speck_32_64_generate_key_schedule initial_key_words = (\n     let k0 = [initial_key_words ! 0];\n         l0 = [initial_key_words ! 1, initial_key_words ! 2, initial_key_words ! 3]\n     in speck_32_64_gen_key_schedule_rec l0 k0 0)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.052608"}}
{"instruction": "Translate this Encrypt Iteration from SPECK-32/64 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "def speck_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply SPECK encryption rounds\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    # word_size = 16\n    new_x, new_y = speck_encrypt_round(\n        x, y, k, \n        16, \n        (1 << 16) - 1\n    )\n    \n    # Recursive call for next round\n    return speck_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun speck_32_64_encrypt_iterate :: \"16 word × 16 word ⇒ 16 word list ⇒ 16 word × 16 word\" where\n  \"speck_32_64_encrypt_iterate state [] = state\"\n| \"speck_32_64_encrypt_iterate state (k#ks) = speck_32_64_encrypt_iterate (speck_32_64_encrypt_round k state) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.052984"}}
{"instruction": "Translate this Decrypt Iteration from SPECK-32/64 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "def speck_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply SPECK decryption rounds (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    # word_size = 16\n    new_x, new_y = speck_decrypt_round(\n        x, y, k,\n        16,\n        (1 << 16) - 1,\n        (1 << 16)\n    )\n    \n    # Recursive call for previous round\n    return speck_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun speck_32_64_decrypt_iterate :: \"16 word × 16 word ⇒ 16 word list ⇒ 16 word × 16 word\" where\n  \"speck_32_64_decrypt_iterate state ks = foldl (λst_new k. speck_32_64_decrypt_round_inverse k st_new) state (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.053281"}}
{"instruction": "Translate this Encrypt Block from SPECK-32/64 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "def speck_encrypt_block(plaintext, key_schedule):\n    \"\"\"SPECK block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 16\n    left = (plaintext >> 16) & ((1 << 16) - 1)\n    right = plaintext & ((1 << 16) - 1)\n    \n    # Apply all rounds\n    cipher_left, cipher_right = speck_encrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # word_size = 16\n    # Combine back\n    return (cipher_left << 16) | cipher_right", "output": "definition speck_32_64_encrypt_block :: \"16 word × 16 word ⇒ 16 word list ⇒ 16 word × 16 word\" where\n  \"speck_32_64_encrypt_block state keys = speck_32_64_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.053553"}}
{"instruction": "Translate this Decrypt Block from SPECK-32/64 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "def speck_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SPECK block decryption\"\"\"\n    # Split into left and right halves\n    left = (ciphertext >> 16) & ((1 << 16) - 1)\n    right = ciphertext & ((1 << 16) - 1)\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = speck_decrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 16) | plain_right", "output": "definition speck_32_64_decrypt_block :: \"16 word × 16 word ⇒ 16 word list ⇒ 16 word × 16 word\" where\n  \"speck_32_64_decrypt_block state keys = speck_32_64_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.053862"}}
{"instruction": "Translate this Block Splitting from SPECK-32/64 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "def speck_split_block(block):\n    \"\"\"Split 32-bit block into two 16-bit words\"\"\"\n    # word_size = 16\n    \n    mask = (1 << 16) - 1\n    left = (block >> 16) & (1 << 16) - 1\n    right = block & (1 << 16) - 1\n    return left, right", "output": "definition speck_32_64_split_block :: \"32 word ⇒ (16 word × 16 word)\" where\n  \"speck_32_64_split_block block = (\n    let left = ucast (drop_bit 16 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.054690"}}
{"instruction": "Translate this Block Combining from SPECK-32/64 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "def speck_combine_block(left, right):\n    \"\"\"Combine two 16-bit words into 32-bit block\"\"\"\n    # word_size = 16\n    \n    return (left << 16) | right", "output": "definition speck_32_64_combine_block :: \"16 word × 16 word ⇒ 32 word\" where\n  \"speck_32_64_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 16 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.055597"}}
{"instruction": "Translate this Top-Level Encrypt from SPECK-32/64 Python to Isabelle/HOL. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "def speck_encrypt(plaintext, master_key):\n    \"\"\"Top-level SPECK encryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return speck_encrypt_block(plaintext, key_schedule)", "output": "definition speck_32_64_encrypt :: \"32 word ⇒ 16 word list ⇒ 32 word\" where\n  \"speck_32_64_encrypt plaintext keys = (\n    let left = ucast (drop_bit 16 plaintext);\n        right = ucast plaintext;\n        (c_l, c_r) = speck_32_64_encrypt_block (left, right) keys\n    in or (push_bit 16 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.055940"}}
{"instruction": "Translate this Top-Level Decrypt from SPECK-32/64 Python to Isabelle/HOL. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "def speck_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SPECK decryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return speck_decrypt_block(ciphertext, key_schedule)", "output": "definition speck_32_64_decrypt :: \"32 word ⇒ 16 word list ⇒ 32 word\" where\n  \"speck_32_64_decrypt ciphertext keys = (\n    let left = ucast (drop_bit 16 ciphertext);\n        right = ucast ciphertext;\n        (p_l, p_r) = speck_32_64_decrypt_block (left, right) keys\n    in or (push_bit 16 (ucast p_l)) (ucast p_r))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.056239"}}
{"instruction": "Translate this Modular Mask from SPECK-32/64 Python to Isabelle/HOL. Note: SPECK-32/64  is an ARX cipher with 7-bit right and 2-bit left rotations.", "input": "def speck_mod_mask(word_size=16):\n    \"\"\"Create mask for 16-bit words\"\"\"\n    # word_size = 16\n    \n    return (1 <<  16) - 1", "output": "definition speck_32_64_mod_mask :: \"16 word\" where\n  \"speck_32_64_mod_mask = 65535\"", "metadata": {"component_type": "Modular Mask", "difficulty": "easy", "semantic_group": "helpers", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 32, "key_size": 64, "rounds": 22}, "algorithm_params": {"word_size": 16, "alpha_rotation": 7, "beta_rotation": 2, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.057519"}}
{"instruction": "Translate this alpha Constant from SPECK-64/96 Python to Isabelle/HOL. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck alpha rotation constant (8-bit right rotate)\nalpha = 8", "output": "definition speck_64_96_alpha :: nat where \"speck_64_96_alpha = 8\"", "metadata": {"component_type": "alpha Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.060442"}}
{"instruction": "Translate this beta Constant from SPECK-64/96 Python to Isabelle/HOL. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck beta rotation constant (3-bit left rotate)\nbeta = 3", "output": "definition speck_64_96_beta :: nat where \"speck_64_96_beta = 3\"", "metadata": {"component_type": "beta Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.060663"}}
{"instruction": "Translate this rounds Constant from SPECK-64/96 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Number of rounds for SPECK(64/96)\nrounds = 26", "output": "definition speck_64_96_rounds :: nat where \"speck_64_96_rounds = 26\"", "metadata": {"component_type": "rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:48.061004"}}
{"instruction": "Translate this word_size Constant from SPECK-64/96 Python to Isabelle/HOL. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Word size in bits for SPECK(64/96)\nword_size = 32", "output": "definition speck_64_96_word_size :: nat where \"speck_64_96_word_size = 32\"", "metadata": {"component_type": "word_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:48.061464"}}
{"instruction": "Translate this block_size Constant from SPECK-64/96 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 64-bit block size\nblock_size = 64", "output": "definition speck_64_96_block_size :: nat where \"speck_64_96_block_size = 64\"", "metadata": {"component_type": "block_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.062104"}}
{"instruction": "Translate this key_size Constant from SPECK-64/96 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 96-bit key size\nkey_size = 96", "output": "definition speck_64_96_key_size :: nat where \"speck_64_96_key_size = 96\"", "metadata": {"component_type": "key_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.062512"}}
{"instruction": "Translate this Encrypt Round from SPECK-64/96 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_round(x, y, k, word_size = 32, mod_mask):\n    \"\"\"SPECK ARX encrypt round: (ROR_α(x) + y) ⊕ k, then x ⊕ ROL_β(y)\"\"\"\n    # Right rotate by alpha=(8 bits)\n    rs_x = ((x >> 8) | (x << (word_size - 8))) & mod_mask\n    \n    # Modular addition\n    add_sxy = (rs_x + y) & mod_mask\n    \n    # XOR with round key\n    new_x = k ^ add_sxy\n    \n    # Left rotate by beta=(3 bits)\n    ls_y = ((y << 3) | (y >> (word_size - 3))) & mod_mask\n    \n    # Final XOR\n    new_y = new_x ^ ls_y\n    \n    return new_x, new_y", "output": "definition speck_64_96_encrypt_round :: \"32 word ⇒ 32 word × 32 word ⇒ 32 word × 32 word\" where\n  \"speck_64_96_encrypt_round k xy = (\n    let (x, y) = xy;\n        rs_x = word_rotr speck_64_96_alpha x;\n        add_xy = rs_x + y;\n        new_x = xor add_xy k;\n        ls_y = word_rotl speck_64_96_beta y;\n        new_y = xor new_x ls_y\n    in (new_x, new_y))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.062863"}}
{"instruction": "Translate this Decrypt Round from SPECK-64/96 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_round(x, y, k, word_size = 32, mod_mask, mod_mask_sub):\n    \"\"\"SPECK ARX decrypt round (inverse operations)\"\"\"\n    # Recover original y: ROR_β(x ⊕ y)\n    # alpha = 8\n    # beta = 3\n    xor_xy = x ^ y\n    new_y = ((xor_xy >> 3) | (xor_xy << (word_size - 3))) & mod_mask\n    \n    # Recover original x: ROL_α((x ⊕ k) - y)\n    xor_xk = x ^ k\n    msub = (xor_xk - new_y) % mod_mask_sub\n    new_x = ((msub << 8) | (msub >> (word_size - 8))) & mod_mask\n    \n    return new_x, new_y", "output": "definition speck_64_96_decrypt_round_inverse :: \"32 word ⇒ 32 word × 32 word ⇒ 32 word × 32 word\" where\n  \"speck_64_96_decrypt_round_inverse k xy_new = (\n    let (x, y) = xy_new;\n        xor_xy = xor x y;\n        new_y = word_rotr speck_64_96_beta xor_xy;\n        xor_xk = xor x k;\n        msub = xor_xk - new_y;\n        new_x = word_rotl speck_64_96_alpha msub\n    in (new_x, new_y))\"", "metadata": {"component_type": "Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.063149"}}
{"instruction": "Translate this Key Schedule Recursive from SPECK-64/96 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_gen_key_schedule_rec(l_keys, k_keys, i, max_rounds= 26):\n    \"\"\"Recursive SPECK key schedule generation\"\"\"\n    max_rounds = 26\n    if i >= 26:\n        return k_keys\n    \n    # Apply round function to generate next key\n    # word_size = 32\n    new_l, new_k = speck_encrypt_round(\n        l_keys[i % len(l_keys)], \n        k_keys[i], \n        i,  # Round constant as key\n        32,\n        (1 << 32) - 1\n    )\n\n    # Append and recurse\n    l_keys.append(new_l)\n    k_keys.append(new_k)\n    \n    return speck_gen_key_schedule_rec(l_keys, k_keys, i + 1, max_rounds)", "output": "function speck_64_96_gen_key_schedule_rec :: \"32 word list ⇒ 32 word list ⇒ nat ⇒ 32 word list\" where\n  \"speck_64_96_gen_key_schedule_rec l_keys k_keys i = (\n     if i ≥ (26 - 1) then k_keys\n     else\n       let (new_l, new_k) = speck_64_96_encrypt_round (word_of_nat i) (l_keys ! i, k_keys ! i)\n       in speck_64_96_gen_key_schedule_rec (l_keys @ [new_l]) (k_keys @ [new_k]) (i + 1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(l, k, i). 25 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.063615"}}
{"instruction": "Translate this Key Schedule Wrapper from SPECK-64/96 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_generate_key_schedule(master_key):\n    \"\"\"Generate SPECK round keys from master key\"\"\"\n    # Extract key words\n    # word_size = 32\n    key_words = []\n    for i in range(3):\n        key_words.append((master_key >> (32 * i)) & ((1 << 32 - 1))\n    \n    # Initialize L and K arrays\n    l_keys = key_words[1:]  # All except first\n    k_keys = [key_words[0]]  # First word\n    \n    # Generate round keys\n    return speck_gen_key_schedule_rec(l_keys, k_keys, 0, 26)", "output": "definition speck_64_96_generate_key_schedule :: \"32 word list ⇒ 32 word list\" where\n  \"speck_64_96_generate_key_schedule initial_key_words = (\n     let k0 = [initial_key_words ! 0];\n         l0 = [initial_key_words ! 1, initial_key_words ! 2]\n     in speck_64_96_gen_key_schedule_rec l0 k0 0)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.063959"}}
{"instruction": "Translate this Encrypt Iteration from SPECK-64/96 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply SPECK encryption rounds\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    # word_size = 32\n    new_x, new_y = speck_encrypt_round(\n        x, y, k, \n        32, \n        (1 << 32) - 1\n    )\n    \n    # Recursive call for next round\n    return speck_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun speck_64_96_encrypt_iterate :: \"32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word\" where\n  \"speck_64_96_encrypt_iterate state [] = state\"\n| \"speck_64_96_encrypt_iterate state (k#ks) = speck_64_96_encrypt_iterate (speck_64_96_encrypt_round k state) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.064601"}}
{"instruction": "Translate this Decrypt Iteration from SPECK-64/96 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply SPECK decryption rounds (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    # word_size = 32\n    new_x, new_y = speck_decrypt_round(\n        x, y, k,\n        32,\n        (1 << 32) - 1,\n        (1 << 32)\n    )\n    \n    # Recursive call for previous round\n    return speck_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun speck_64_96_decrypt_iterate :: \"32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word\" where\n  \"speck_64_96_decrypt_iterate state ks = foldl (λst_new k. speck_64_96_decrypt_round_inverse k st_new) state (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.065103"}}
{"instruction": "Translate this Encrypt Block from SPECK-64/96 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_block(plaintext, key_schedule):\n    \"\"\"SPECK block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 32\n    left = (plaintext >> 32) & ((1 << 32) - 1)\n    right = plaintext & ((1 << 32) - 1)\n    \n    # Apply all rounds\n    cipher_left, cipher_right = speck_encrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # word_size = 32\n    # Combine back\n    return (cipher_left << 32) | cipher_right", "output": "definition speck_64_96_encrypt_block :: \"32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word\" where\n  \"speck_64_96_encrypt_block state keys = speck_64_96_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.065653"}}
{"instruction": "Translate this Decrypt Block from SPECK-64/96 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SPECK block decryption\"\"\"\n    # Split into left and right halves\n    left = (ciphertext >> 32) & ((1 << 32) - 1)\n    right = ciphertext & ((1 << 32) - 1)\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = speck_decrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 32) | plain_right", "output": "definition speck_64_96_decrypt_block :: \"32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word\" where\n  \"speck_64_96_decrypt_block state keys = speck_64_96_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.066102"}}
{"instruction": "Translate this Block Splitting from SPECK-64/96 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_split_block(block):\n    \"\"\"Split 64-bit block into two 32-bit words\"\"\"\n    # word_size = 32\n    \n    mask = (1 << 32) - 1\n    left = (block >> 32) & (1 << 32) - 1\n    right = block & (1 << 32) - 1\n    return left, right", "output": "definition speck_64_96_split_block :: \"64 word ⇒ (32 word × 32 word)\" where\n  \"speck_64_96_split_block block = (\n    let left = ucast (drop_bit 32 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.067159"}}
{"instruction": "Translate this Block Combining from SPECK-64/96 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_combine_block(left, right):\n    \"\"\"Combine two 32-bit words into 64-bit block\"\"\"\n    # word_size = 32\n    \n    return (left << 32) | right", "output": "definition speck_64_96_combine_block :: \"32 word × 32 word ⇒ 64 word\" where\n  \"speck_64_96_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 32 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.068159"}}
{"instruction": "Translate this Top-Level Encrypt from SPECK-64/96 Python to Isabelle/HOL. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt(plaintext, master_key):\n    \"\"\"Top-level SPECK encryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return speck_encrypt_block(plaintext, key_schedule)", "output": "definition speck_64_96_encrypt :: \"64 word ⇒ 32 word list ⇒ 64 word\" where\n  \"speck_64_96_encrypt plaintext keys = (\n    let left = ucast (drop_bit 32 plaintext);\n        right = ucast plaintext;\n        (c_l, c_r) = speck_64_96_encrypt_block (left, right) keys\n    in or (push_bit 32 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.068476"}}
{"instruction": "Translate this Top-Level Decrypt from SPECK-64/96 Python to Isabelle/HOL. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SPECK decryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return speck_decrypt_block(ciphertext, key_schedule)", "output": "definition speck_64_96_decrypt :: \"64 word ⇒ 32 word list ⇒ 64 word\" where\n  \"speck_64_96_decrypt ciphertext keys = (\n    let left = ucast (drop_bit 32 ciphertext);\n        right = ucast ciphertext;\n        (p_l, p_r) = speck_64_96_decrypt_block (left, right) keys\n    in or (push_bit 32 (ucast p_l)) (ucast p_r))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.068761"}}
{"instruction": "Translate this Modular Mask from SPECK-64/96 Python to Isabelle/HOL. Note: SPECK-64/96  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_mod_mask(word_size=32):\n    \"\"\"Create mask for 32-bit words\"\"\"\n    # word_size = 32\n    \n    return (1 <<  32) - 1", "output": "definition speck_64_96_mod_mask :: \"32 word\" where\n  \"speck_64_96_mod_mask = 4294967295\"", "metadata": {"component_type": "Modular Mask", "difficulty": "easy", "semantic_group": "helpers", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 96, "rounds": 26}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.069589"}}
{"instruction": "Translate this alpha Constant from SPECK-96/144 Python to Isabelle/HOL. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck alpha rotation constant (8-bit right rotate)\nalpha = 8", "output": "definition speck_96_144_alpha :: nat where \"speck_96_144_alpha = 8\"", "metadata": {"component_type": "alpha Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.073677"}}
{"instruction": "Translate this beta Constant from SPECK-96/144 Python to Isabelle/HOL. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck beta rotation constant (3-bit left rotate)\nbeta = 3", "output": "definition speck_96_144_beta :: nat where \"speck_96_144_beta = 3\"", "metadata": {"component_type": "beta Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.073902"}}
{"instruction": "Translate this rounds Constant from SPECK-96/144 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Number of rounds for SPECK(96/144)\nrounds = 29", "output": "definition speck_96_144_rounds :: nat where \"speck_96_144_rounds = 29\"", "metadata": {"component_type": "rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:48.074244"}}
{"instruction": "Translate this word_size Constant from SPECK-96/144 Python to Isabelle/HOL. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Word size in bits for SPECK(96/144)\nword_size = 48", "output": "definition speck_96_144_word_size :: nat where \"speck_96_144_word_size = 48\"", "metadata": {"component_type": "word_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:48.074585"}}
{"instruction": "Translate this block_size Constant from SPECK-96/144 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 96-bit block size\nblock_size = 96", "output": "definition speck_96_144_block_size :: nat where \"speck_96_144_block_size = 96\"", "metadata": {"component_type": "block_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.074931"}}
{"instruction": "Translate this key_size Constant from SPECK-96/144 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 144-bit key size\nkey_size = 144", "output": "definition speck_96_144_key_size :: nat where \"speck_96_144_key_size = 144\"", "metadata": {"component_type": "key_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.075320"}}
{"instruction": "Translate this Encrypt Round from SPECK-96/144 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_round(x, y, k, word_size = 48, mod_mask):\n    \"\"\"SPECK ARX encrypt round: (ROR_α(x) + y) ⊕ k, then x ⊕ ROL_β(y)\"\"\"\n    # Right rotate by alpha=(8 bits)\n    rs_x = ((x >> 8) | (x << (word_size - 8))) & mod_mask\n    \n    # Modular addition\n    add_sxy = (rs_x + y) & mod_mask\n    \n    # XOR with round key\n    new_x = k ^ add_sxy\n    \n    # Left rotate by beta=(3 bits)\n    ls_y = ((y << 3) | (y >> (word_size - 3))) & mod_mask\n    \n    # Final XOR\n    new_y = new_x ^ ls_y\n    \n    return new_x, new_y", "output": "definition speck_96_144_encrypt_round :: \"48 word ⇒ 48 word × 48 word ⇒ 48 word × 48 word\" where\n  \"speck_96_144_encrypt_round k xy = (\n    let (x, y) = xy;\n        rs_x = word_rotr speck_96_144_alpha x;\n        add_xy = rs_x + y;\n        new_x = xor add_xy k;\n        ls_y = word_rotl speck_96_144_beta y;\n        new_y = xor new_x ls_y\n    in (new_x, new_y))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.075680"}}
{"instruction": "Translate this Decrypt Round from SPECK-96/144 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_round(x, y, k, word_size = 48, mod_mask, mod_mask_sub):\n    \"\"\"SPECK ARX decrypt round (inverse operations)\"\"\"\n    # Recover original y: ROR_β(x ⊕ y)\n    # alpha = 8\n    # beta = 3\n    xor_xy = x ^ y\n    new_y = ((xor_xy >> 3) | (xor_xy << (word_size - 3))) & mod_mask\n    \n    # Recover original x: ROL_α((x ⊕ k) - y)\n    xor_xk = x ^ k\n    msub = (xor_xk - new_y) % mod_mask_sub\n    new_x = ((msub << 8) | (msub >> (word_size - 8))) & mod_mask\n    \n    return new_x, new_y", "output": "definition speck_96_144_decrypt_round_inverse :: \"48 word ⇒ 48 word × 48 word ⇒ 48 word × 48 word\" where\n  \"speck_96_144_decrypt_round_inverse k xy_new = (\n    let (x, y) = xy_new;\n        xor_xy = xor x y;\n        new_y = word_rotr speck_96_144_beta xor_xy;\n        xor_xk = xor x k;\n        msub = xor_xk - new_y;\n        new_x = word_rotl speck_96_144_alpha msub\n    in (new_x, new_y))\"", "metadata": {"component_type": "Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.075972"}}
{"instruction": "Translate this Key Schedule Recursive from SPECK-96/144 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_gen_key_schedule_rec(l_keys, k_keys, i, max_rounds= 29):\n    \"\"\"Recursive SPECK key schedule generation\"\"\"\n    max_rounds = 29\n    if i >= 29:\n        return k_keys\n    \n    # Apply round function to generate next key\n    # word_size = 48\n    new_l, new_k = speck_encrypt_round(\n        l_keys[i % len(l_keys)], \n        k_keys[i], \n        i,  # Round constant as key\n        48,\n        (1 << 48) - 1\n    )\n\n    # Append and recurse\n    l_keys.append(new_l)\n    k_keys.append(new_k)\n    \n    return speck_gen_key_schedule_rec(l_keys, k_keys, i + 1, max_rounds)", "output": "function speck_96_144_gen_key_schedule_rec :: \"48 word list ⇒ 48 word list ⇒ nat ⇒ 48 word list\" where\n  \"speck_96_144_gen_key_schedule_rec l_keys k_keys i = (\n     if i ≥ (29 - 1) then k_keys\n     else\n       let (new_l, new_k) = speck_96_144_encrypt_round (word_of_nat i) (l_keys ! i, k_keys ! i)\n       in speck_96_144_gen_key_schedule_rec (l_keys @ [new_l]) (k_keys @ [new_k]) (i + 1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(l, k, i). 28 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.076286"}}
{"instruction": "Translate this Key Schedule Wrapper from SPECK-96/144 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_generate_key_schedule(master_key):\n    \"\"\"Generate SPECK round keys from master key\"\"\"\n    # Extract key words\n    # word_size = 48\n    key_words = []\n    for i in range(3):\n        key_words.append((master_key >> (48 * i)) & ((1 << 48 - 1))\n    \n    # Initialize L and K arrays\n    l_keys = key_words[1:]  # All except first\n    k_keys = [key_words[0]]  # First word\n    \n    # Generate round keys\n    return speck_gen_key_schedule_rec(l_keys, k_keys, 0, 29)", "output": "definition speck_96_144_generate_key_schedule :: \"48 word list ⇒ 48 word list\" where\n  \"speck_96_144_generate_key_schedule initial_key_words = (\n     let k0 = [initial_key_words ! 0];\n         l0 = [initial_key_words ! 1, initial_key_words ! 2]\n     in speck_96_144_gen_key_schedule_rec l0 k0 0)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.076596"}}
{"instruction": "Translate this Encrypt Iteration from SPECK-96/144 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply SPECK encryption rounds\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    # word_size = 48\n    new_x, new_y = speck_encrypt_round(\n        x, y, k, \n        48, \n        (1 << 48) - 1\n    )\n    \n    # Recursive call for next round\n    return speck_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun speck_96_144_encrypt_iterate :: \"48 word × 48 word ⇒ 48 word list ⇒ 48 word × 48 word\" where\n  \"speck_96_144_encrypt_iterate state [] = state\"\n| \"speck_96_144_encrypt_iterate state (k#ks) = speck_96_144_encrypt_iterate (speck_96_144_encrypt_round k state) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.076959"}}
{"instruction": "Translate this Decrypt Iteration from SPECK-96/144 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply SPECK decryption rounds (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    # word_size = 48\n    new_x, new_y = speck_decrypt_round(\n        x, y, k,\n        48,\n        (1 << 48) - 1,\n        (1 << 48)\n    )\n    \n    # Recursive call for previous round\n    return speck_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun speck_96_144_decrypt_iterate :: \"48 word × 48 word ⇒ 48 word list ⇒ 48 word × 48 word\" where\n  \"speck_96_144_decrypt_iterate state ks = foldl (λst_new k. speck_96_144_decrypt_round_inverse k st_new) state (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.077218"}}
{"instruction": "Translate this Encrypt Block from SPECK-96/144 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_block(plaintext, key_schedule):\n    \"\"\"SPECK block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 48\n    left = (plaintext >> 48) & ((1 << 48) - 1)\n    right = plaintext & ((1 << 48) - 1)\n    \n    # Apply all rounds\n    cipher_left, cipher_right = speck_encrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # word_size = 48\n    # Combine back\n    return (cipher_left << 48) | cipher_right", "output": "definition speck_96_144_encrypt_block :: \"48 word × 48 word ⇒ 48 word list ⇒ 48 word × 48 word\" where\n  \"speck_96_144_encrypt_block state keys = speck_96_144_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.077472"}}
{"instruction": "Translate this Decrypt Block from SPECK-96/144 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SPECK block decryption\"\"\"\n    # Split into left and right halves\n    left = (ciphertext >> 48) & ((1 << 48) - 1)\n    right = ciphertext & ((1 << 48) - 1)\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = speck_decrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 48) | plain_right", "output": "definition speck_96_144_decrypt_block :: \"48 word × 48 word ⇒ 48 word list ⇒ 48 word × 48 word\" where\n  \"speck_96_144_decrypt_block state keys = speck_96_144_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.077798"}}
{"instruction": "Translate this Block Splitting from SPECK-96/144 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_split_block(block):\n    \"\"\"Split 96-bit block into two 48-bit words\"\"\"\n    # word_size = 48\n    \n    mask = (1 << 48) - 1\n    left = (block >> 48) & (1 << 48) - 1\n    right = block & (1 << 48) - 1\n    return left, right", "output": "definition speck_96_144_split_block :: \"96 word ⇒ (48 word × 48 word)\" where\n  \"speck_96_144_split_block block = (\n    let left = ucast (drop_bit 48 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.078533"}}
{"instruction": "Translate this Block Combining from SPECK-96/144 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_combine_block(left, right):\n    \"\"\"Combine two 48-bit words into 96-bit block\"\"\"\n    # word_size = 48\n    \n    return (left << 48) | right", "output": "definition speck_96_144_combine_block :: \"48 word × 48 word ⇒ 96 word\" where\n  \"speck_96_144_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 48 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.079219"}}
{"instruction": "Translate this Top-Level Encrypt from SPECK-96/144 Python to Isabelle/HOL. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt(plaintext, master_key):\n    \"\"\"Top-level SPECK encryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return speck_encrypt_block(plaintext, key_schedule)", "output": "definition speck_96_144_encrypt :: \"96 word ⇒ 48 word list ⇒ 96 word\" where\n  \"speck_96_144_encrypt plaintext keys = (\n    let left = ucast (drop_bit 48 plaintext);\n        right = ucast plaintext;\n        (c_l, c_r) = speck_96_144_encrypt_block (left, right) keys\n    in or (push_bit 48 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.079492"}}
{"instruction": "Translate this Top-Level Decrypt from SPECK-96/144 Python to Isabelle/HOL. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SPECK decryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return speck_decrypt_block(ciphertext, key_schedule)", "output": "definition speck_96_144_decrypt :: \"96 word ⇒ 48 word list ⇒ 96 word\" where\n  \"speck_96_144_decrypt ciphertext keys = (\n    let left = ucast (drop_bit 48 ciphertext);\n        right = ucast ciphertext;\n        (p_l, p_r) = speck_96_144_decrypt_block (left, right) keys\n    in or (push_bit 48 (ucast p_l)) (ucast p_r))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.079746"}}
{"instruction": "Translate this Modular Mask from SPECK-96/144 Python to Isabelle/HOL. Note: SPECK-96/144  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_mod_mask(word_size=48):\n    \"\"\"Create mask for 48-bit words\"\"\"\n    # word_size = 48\n    \n    return (1 <<  48) - 1", "output": "definition speck_96_144_mod_mask :: \"48 word\" where\n  \"speck_96_144_mod_mask = 281474976710655\"", "metadata": {"component_type": "Modular Mask", "difficulty": "easy", "semantic_group": "helpers", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 96, "key_size": 144, "rounds": 29}, "algorithm_params": {"word_size": 48, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 3, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.080971"}}
{"instruction": "Translate this alpha Constant from SPECK-64/128 Python to Isabelle/HOL. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck alpha rotation constant (8-bit right rotate)\nalpha = 8", "output": "definition speck_64_128_alpha :: nat where \"speck_64_128_alpha = 8\"", "metadata": {"component_type": "alpha Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.084997"}}
{"instruction": "Translate this beta Constant from SPECK-64/128 Python to Isabelle/HOL. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Speck beta rotation constant (3-bit left rotate)\nbeta = 3", "output": "definition speck_64_128_beta :: nat where \"speck_64_128_beta = 3\"", "metadata": {"component_type": "beta Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.085232"}}
{"instruction": "Translate this rounds Constant from SPECK-64/128 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Number of rounds for SPECK(64/128)\nrounds = 27", "output": "definition speck_64_128_rounds :: nat where \"speck_64_128_rounds = 27\"", "metadata": {"component_type": "rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:48.085581"}}
{"instruction": "Translate this word_size Constant from SPECK-64/128 Python to Isabelle/HOL. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# Word size in bits for SPECK(64/128)\nword_size = 32", "output": "definition speck_64_128_word_size :: nat where \"speck_64_128_word_size = 32\"", "metadata": {"component_type": "word_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion"], "extraction_time": "2026-01-24T13:11:48.085920"}}
{"instruction": "Translate this block_size Constant from SPECK-64/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 64-bit block size\nblock_size = 64", "output": "definition speck_64_128_block_size :: nat where \"speck_64_128_block_size = 64\"", "metadata": {"component_type": "block_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.086281"}}
{"instruction": "Translate this key_size Constant from SPECK-64/128 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "# 128-bit key size\nkey_size = 128", "output": "definition speck_64_128_key_size :: nat where \"speck_64_128_key_size = 128\"", "metadata": {"component_type": "key_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.086733"}}
{"instruction": "Translate this Encrypt Round from SPECK-64/128 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_round(x, y, k, word_size = 32, mod_mask):\n    \"\"\"SPECK ARX encrypt round: (ROR_α(x) + y) ⊕ k, then x ⊕ ROL_β(y)\"\"\"\n    # Right rotate by alpha=(8 bits)\n    rs_x = ((x >> 8) | (x << (word_size - 8))) & mod_mask\n    \n    # Modular addition\n    add_sxy = (rs_x + y) & mod_mask\n    \n    # XOR with round key\n    new_x = k ^ add_sxy\n    \n    # Left rotate by beta=(3 bits)\n    ls_y = ((y << 3) | (y >> (word_size - 3))) & mod_mask\n    \n    # Final XOR\n    new_y = new_x ^ ls_y\n    \n    return new_x, new_y", "output": "definition speck_64_128_encrypt_round :: \"32 word ⇒ 32 word × 32 word ⇒ 32 word × 32 word\" where\n  \"speck_64_128_encrypt_round k xy = (\n    let (x, y) = xy;\n        rs_x = word_rotr speck_64_128_alpha x;\n        add_xy = rs_x + y;\n        new_x = xor add_xy k;\n        ls_y = word_rotl speck_64_128_beta y;\n        new_y = xor new_x ls_y\n    in (new_x, new_y))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.087105"}}
{"instruction": "Translate this Decrypt Round from SPECK-64/128 Python to Isabelle/HOL. Apply: implement ARX operations in sequence: add → rotate (8-bit right) → xor, handle left and right halves separately, use modular arithmetic with word bounds. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_round(x, y, k, word_size = 32, mod_mask, mod_mask_sub):\n    \"\"\"SPECK ARX decrypt round (inverse operations)\"\"\"\n    # Recover original y: ROR_β(x ⊕ y)\n    # alpha = 8\n    # beta = 3\n    xor_xy = x ^ y\n    new_y = ((xor_xy >> 3) | (xor_xy << (word_size - 3))) & mod_mask\n    \n    # Recover original x: ROL_α((x ⊕ k) - y)\n    xor_xk = x ^ k\n    msub = (xor_xk - new_y) % mod_mask_sub\n    new_x = ((msub << 8) | (msub >> (word_size - 8))) & mod_mask\n    \n    return new_x, new_y", "output": "definition speck_64_128_decrypt_round_inverse :: \"32 word ⇒ 32 word × 32 word ⇒ 32 word × 32 word\" where\n  \"speck_64_128_decrypt_round_inverse k xy_new = (\n    let (x, y) = xy_new;\n        xor_xy = xor x y;\n        new_y = word_rotr speck_64_128_beta xor_xy;\n        xor_xk = xor x k;\n        msub = xor_xk - new_y;\n        new_x = word_rotl speck_64_128_alpha msub\n    in (new_x, new_y))\"", "metadata": {"component_type": "Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.087472"}}
{"instruction": "Translate this Key Schedule Recursive from SPECK-64/128 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_gen_key_schedule_rec(l_keys, k_keys, i, max_rounds= 27):\n    \"\"\"Recursive SPECK key schedule generation\"\"\"\n    max_rounds = 27\n    if i >= 27:\n        return k_keys\n    \n    # Apply round function to generate next key\n    # word_size = 32\n    new_l, new_k = speck_encrypt_round(\n        l_keys[i % len(l_keys)], \n        k_keys[i], \n        i,  # Round constant as key\n        32,\n        (1 << 32) - 1\n    )\n\n    # Append and recurse\n    l_keys.append(new_l)\n    k_keys.append(new_k)\n    \n    return speck_gen_key_schedule_rec(l_keys, k_keys, i + 1, max_rounds)", "output": "function speck_64_128_gen_key_schedule_rec :: \"32 word list ⇒ 32 word list ⇒ nat ⇒ 32 word list\" where\n  \"speck_64_128_gen_key_schedule_rec l_keys k_keys i = (\n     if i ≥ (27 - 1) then k_keys\n     else\n       let (new_l, new_k) = speck_64_128_encrypt_round (word_of_nat i) (l_keys ! i, k_keys ! i)\n       in speck_64_128_gen_key_schedule_rec (l_keys @ [new_l]) (k_keys @ [new_k]) (i + 1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(l, k, i). 26 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.087808"}}
{"instruction": "Translate this Key Schedule Wrapper from SPECK-64/128 Python to Isabelle/HOL. Apply: implement recursive key expansion, use round-dependent constants, handle word extraction from master key. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_generate_key_schedule(master_key):\n    \"\"\"Generate SPECK round keys from master key\"\"\"\n    # Extract key words\n    # word_size = 32\n    key_words = []\n    for i in range(4):\n        key_words.append((master_key >> (32 * i)) & ((1 << 32 - 1))\n    \n    # Initialize L and K arrays\n    l_keys = key_words[1:]  # All except first\n    k_keys = [key_words[0]]  # First word\n    \n    # Generate round keys\n    return speck_gen_key_schedule_rec(l_keys, k_keys, 0, 27)", "output": "definition speck_64_128_generate_key_schedule :: \"32 word list ⇒ 32 word list\" where\n  \"speck_64_128_generate_key_schedule initial_key_words = (\n     let k0 = [initial_key_words ! 0];\n         l0 = [initial_key_words ! 1, initial_key_words ! 2, initial_key_words ! 3]\n     in speck_64_128_gen_key_schedule_rec l0 k0 0)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.088075"}}
{"instruction": "Translate this Encrypt Iteration from SPECK-64/128 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply SPECK encryption rounds\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    # word_size = 32\n    new_x, new_y = speck_encrypt_round(\n        x, y, k, \n        32, \n        (1 << 32) - 1\n    )\n    \n    # Recursive call for next round\n    return speck_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun speck_64_128_encrypt_iterate :: \"32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word\" where\n  \"speck_64_128_encrypt_iterate state [] = state\"\n| \"speck_64_128_encrypt_iterate state (k#ks) = speck_64_128_encrypt_iterate (speck_64_128_encrypt_round k state) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.088495"}}
{"instruction": "Translate this Decrypt Iteration from SPECK-64/128 Python to Isabelle/HOL. Apply: convert loops to recursion, handle base case and recursive case, maintain state across iterations. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply SPECK decryption rounds (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    # word_size = 32\n    new_x, new_y = speck_decrypt_round(\n        x, y, k,\n        32,\n        (1 << 32) - 1,\n        (1 << 32)\n    )\n    \n    # Recursive call for previous round\n    return speck_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun speck_64_128_decrypt_iterate :: \"32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word\" where\n  \"speck_64_128_decrypt_iterate state ks = foldl (λst_new k. speck_64_128_decrypt_round_inverse k st_new) state (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.089115"}}
{"instruction": "Translate this Encrypt Block from SPECK-64/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt_block(plaintext, key_schedule):\n    \"\"\"SPECK block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 32\n    left = (plaintext >> 32) & ((1 << 32) - 1)\n    right = plaintext & ((1 << 32) - 1)\n    \n    # Apply all rounds\n    cipher_left, cipher_right = speck_encrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # word_size = 32\n    # Combine back\n    return (cipher_left << 32) | cipher_right", "output": "definition speck_64_128_encrypt_block :: \"32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word\" where\n  \"speck_64_128_encrypt_block state keys = speck_64_128_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.089568"}}
{"instruction": "Translate this Decrypt Block from SPECK-64/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SPECK block decryption\"\"\"\n    # Split into left and right halves\n    left = (ciphertext >> 32) & ((1 << 32) - 1)\n    right = ciphertext & ((1 << 32) - 1)\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = speck_decrypt_iterate(\n        (left, right), \n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 32) | plain_right", "output": "definition speck_64_128_decrypt_block :: \"32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word\" where\n  \"speck_64_128_decrypt_block state keys = speck_64_128_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.089963"}}
{"instruction": "Translate this Block Splitting from SPECK-64/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_split_block(block):\n    \"\"\"Split 64-bit block into two 32-bit words\"\"\"\n    # word_size = 32\n    \n    mask = (1 << 32) - 1\n    left = (block >> 32) & (1 << 32) - 1\n    right = block & (1 << 32) - 1\n    return left, right", "output": "definition speck_64_128_split_block :: \"64 word ⇒ (32 word × 32 word)\" where\n  \"speck_64_128_split_block block = (\n    let left = ucast (drop_bit 32 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.091593"}}
{"instruction": "Translate this Block Combining from SPECK-64/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle word extraction and insertion, maintain block structure. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_combine_block(left, right):\n    \"\"\"Combine two 32-bit words into 64-bit block\"\"\"\n    # word_size = 32\n    \n    return (left << 32) | right", "output": "definition speck_64_128_combine_block :: \"32 word × 32 word ⇒ 64 word\" where\n  \"speck_64_128_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 32 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.092832"}}
{"instruction": "Translate this Top-Level Encrypt from SPECK-64/128 Python to Isabelle/HOL. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_encrypt(plaintext, master_key):\n    \"\"\"Top-level SPECK encryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return speck_encrypt_block(plaintext, key_schedule)", "output": "definition speck_64_128_encrypt :: \"64 word ⇒ 32 word list ⇒ 64 word\" where\n  \"speck_64_128_encrypt plaintext keys = (\n    let left = ucast (drop_bit 32 plaintext);\n        right = ucast plaintext;\n        (c_l, c_r) = speck_64_128_encrypt_block (left, right) keys\n    in or (push_bit 32 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.093160"}}
{"instruction": "Translate this Top-Level Decrypt from SPECK-64/128 Python to Isabelle/HOL. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SPECK decryption\"\"\"\n    # Generate key schedule\n    key_schedule = speck_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return speck_decrypt_block(ciphertext, key_schedule)", "output": "definition speck_64_128_decrypt :: \"64 word ⇒ 32 word list ⇒ 64 word\" where\n  \"speck_64_128_decrypt ciphertext keys = (\n    let left = ucast (drop_bit 32 ciphertext);\n        right = ucast ciphertext;\n        (p_l, p_r) = speck_64_128_decrypt_block (left, right) keys\n    in or (push_bit 32 (ucast p_l)) (ucast p_r))\"\n\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.093485"}}
{"instruction": "Translate this Modular Mask from SPECK-64/128 Python to Isabelle/HOL. Note: SPECK-64/128  is an ARX cipher with 8-bit right and 3-bit left rotations.", "input": "def speck_mod_mask(word_size=32):\n    \"\"\"Create mask for 32-bit words\"\"\"\n    # word_size = 32\n    \n    return (1 <<  32) - 1", "output": "definition speck_64_128_mod_mask :: \"32 word\" where\n  \"speck_64_128_mod_mask = 4294967295\"", "metadata": {"component_type": "Modular Mask", "difficulty": "easy", "semantic_group": "helpers", "cipher": "SPECK", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "rounds": 27}, "algorithm_params": {"word_size": 32, "alpha_rotation": 8, "beta_rotation": 3, "key_words": 4, "block_words": 2, "structure": "Feistel-like ARX", "arx_order": "add → rotate → xor"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.094546"}}
{"instruction": "Translate the SIMON(64/96) Word Size Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 42 rounds.", "input": "# Word size in bits for SIMON(64/96)\nword_size = 32", "output": "definition simon_64_96_word_size :: nat where \"simon_64_96_word_size = 32\"", "metadata": {"component_type": "Word Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.106240", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(64/96) Rounds Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "# Number of rounds for SIMON(64/96)\nrounds = 42", "output": "definition simon_64_96_rounds :: nat where \"simon_64_96_rounds = 42\"", "metadata": {"component_type": "Rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.107014", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap"]}}
{"instruction": "Translate the SIMON(64/96) Block Size Constant from Python to Isabelle/HOL. Note: SIMON processes 64-bit blocks as two 32-bit halves.", "input": "# 64-bit block size\nblock_size = 64", "output": "definition simon_64_96_block_size :: nat where \"simon_64_96_block_size = 64\"", "metadata": {"component_type": "Block Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.107921", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(64/96) Key Size Constant from Python to Isabelle/HOL. Note: Key expansion uses 3 initial key words and Z-sequence bits.", "input": "# 96-bit key size\nkey_size = 96", "output": "definition simon_64_96_key_size :: nat where \"simon_64_96_key_size = 96\"", "metadata": {"component_type": "Key Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.108910", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(64/96) Z Index Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 42 rounds.", "input": "# Z sequence index for SIMON(64/96)\nz_index = 2", "output": "definition simon_64_96_z_index :: nat where \"simon_64_96_z_index = 2\"", "metadata": {"component_type": "Z Index Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.109964", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(64/96) M Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 42 rounds.", "input": "# Number of key words (m) for SIMON(64/96)\nm = 3", "output": "definition simon_64_96_m :: nat where \"simon_64_96_m = 3\"", "metadata": {"component_type": "M Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.110738", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(64/96) Z Sequence Constant from Python to Isabelle/HOL. Note: Z-sequence bits are used as round constants in SIMON key schedule.", "input": "# Simon Z sequence 2\nz2 = 0b11001101101001111110001000010100011001001011000000111011110101", "output": "definition simon_64_96_z2 :: int where \"simon_64_96_z2 = 0b11001101101001111110001000010100011001001011000000111011110101\"", "metadata": {"component_type": "Z Sequence Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.110999", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(64/96) F-Function from Python to Isabelle/HOL. Note: SIMON F-function: F(x) = ((x <<< 1) & (x <<< 8)) ^ (x <<< 2) with 32-bit words.", "input": "def simon_f_function(x, word_size = 32 , mod_mask = (2 ** 32) - 1 ):\n    \"\"\"Simon F-function: ((S¹(x) & S⁸(x)) ⊕ S²(x))\"\"\"\n    # USE | for consistency with other Simon functions\n    s1_x = ((x << 1) | (x >> (32 - 1))) & (2 ** 32) - 1   # Left rotate 1\n    s8_x = ((x << 8) | (x >> (32 - 8))) & (2 ** 32) - 1   # Left rotate 8\n    s2_x = ((x << 2) | (x >> (32 - 2))) & (2 ** 32) - 1   # Left rotate 2\n    \n    return (s1_x & s8_x) ^ s2_x", "output": "definition simon_64_96_F_function :: \"32 word ⇒ 32 word\" where\n  \"simon_64_96_F_function x = xor (and (word_rotl 1 x) (word_rotl 8 x)) (word_rotl 2 x)\"", "metadata": {"component_type": "F-Function", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.111137", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/96) Encrypt Round from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_encrypt_round(k, (x, y)):\n    \"\"\"Simon encrypt round: new_x = k ⊕ F(x) ⊕ y, new_y = x\"\"\"\n    # word_size = 32\n    mask = (1 << 32) - 1\n    \n    # USE | for consistency\n    s1_x = ((x << 1) | (x >> (32 - 1))) & (1 << 32) - 1 # left rotate 1\n    s8_x = ((x << 8) | (x >> (32 - 8))) & (1 << 32) - 1 # left rotate 8\n    s2_x = ((x << 2) | (x >> (32 - 2))) & (1 << 32) - 1 # left rotate 2\n    fx = (s1_x & s8_x) ^ s2_x\n    \n    new_x = k ^ fx ^ y\n    new_y = x\n    return new_x, new_y", "output": "definition simon_64_96_encrypt_round :: \"32 word ⇒ 32 word × 32 word ⇒ 32 word × 32 word\" where\n  \"simon_64_96_encrypt_round k xy = (let (x, y) = xy in (xor (xor k (simon_64_96_F_function x)) y, x))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.111246", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/96) Decrypt Round Inverse from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_decrypt_round_inverse(k, (x, y)):\n    \"\"\"Simon decrypt round: new_y = k ⊕ F(y) ⊕ x, new_x = y\"\"\"\n    # word_size = 32\n    mask = (1 << 32) - 1\n    \n    # USE | for consistency\n    s1_y = ((y << 1) | (y >> (32 - 1))) & (1 << 32) - 1 # left rotate 1\n    s8_y = ((y << 8) | (y >> (32 - 8))) & (1 << 32) - 1 # left rotate 8\n    s2_y = ((y << 2) | (y >> (32 - 2))) & (1 << 32) - 1 # left rotate 2\n    fy = (s1_y & s8_y) ^ s2_y\n    \n    new_y = k ^ fy ^ x\n    new_x = y\n    return new_x, new_y", "output": "definition simon_64_96_decrypt_round_inverse :: \"32 word ⇒ 32 word × 32 word ⇒ 32 word × 32 word\" where\n  \"simon_64_96_decrypt_round_inverse k xy_new = (let (x_new, y_new) = xy_new in (y_new, xor (xor x_new k) (simon_64_96_F_function y_new)))\"", "metadata": {"component_type": "Decrypt Round Inverse", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.111346", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/96) Round Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "round_constant = (1 << 32) - 4 ", "output": "definition simon_64_96_rho_const :: \"32 word\" where\n  \"simon_64_96_rho_const = 0xFFFFFFFC\"", "metadata": {"component_type": "Round Constant", "difficulty": "easy", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.111439", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/96) Key Schedule Recursive from Python to Isabelle/HOL. Note: Key expansion uses 3 initial key words and Z-sequence bits.", "input": "def simon_gen_key_schedule_rec(ks, i, word_size=32):\n    \"\"\"Recursive Simon key schedule - matches Isabelle function signature\"\"\"\n    if i >= 42:\n        return ks\n    \n    mask = (1 << 32) - 1\n    \n    # Z sequence bit extraction (like bit function in Isabelle)\n    z_bit = (0b11001101101001111110001000010100011001001011000000111011110101 >> ((i - 3) % 62)) & 1\n    \n    # Right rotations (word_rotr in Isabelle)\n    # rs_3 = word_rotr 3 (ks[i-1])\n    key_idx_m1 = ks[i-1] if i > 0 else 0\n    rs_3 = ((key_idx_m1 >> 3) | (key_idx_m1 << (32 - 3))) & (1 << 32) - 1\n    \n    # rs_1 = word_rotr 1 rs_3\n    rs_1 = ((rs_3 >> 1) | (rs_3 << (32 - 1))) & (1 << 32) - 1\n    \n    # Round constant (0xFFFFFFFC for 32-bit)\n    rho_const = (1 << 32) - 1 ^ 3  \n    \n    # Compute new key: xor (xor (xor (ks[i-3]) rs_3) rs_1) (xor (if z_bit then 1 else 0) rho_const)\n    key_idx_m3 = ks[i-3] if i >= 3 else 0\n    temp1 = key_idx_m3 ^ rs_3\n    temp2 = temp1 ^ rs_1\n    z_bit_word = 1 if z_bit else 0\n    z_rho = z_bit_word ^ rho_const\n    new_k = temp2 ^ z_rho\n    \n    # Append and recurse (notice: ks is list, returns list)\n    return simon_gen_key_schedule_rec(ks + [new_k], i + 1, 32)", "output": "function simon_64_96_gen_key_schedule_rec :: \"32 word list ⇒ nat ⇒ 32 word list\" where\n  \"simon_64_96_gen_key_schedule_rec ks i = (if i ≥ 42 then ks else\n    let z_bit = bit simon_64_96_z2 (i - 3);\n        rs_3 = word_rotr 3 (ks ! (i-1)); rs_1 = word_rotr 1 rs_3;\n        new_k = xor (xor (xor (ks ! (i-3)) rs_3) rs_1) (xor (if z_bit then 1 else 0) simon_64_96_rho_const)\n    in simon_64_96_gen_key_schedule_rec (ks @ [new_k]) (i+1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(ks, i). 42 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.111502", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(64/96) Key Schedule Wrapper from Python to Isabelle/HOL. Note: Key expansion uses 3 initial key words and Z-sequence bits.", "input": "def simon_generate_key_schedule(master_key, word_size=32):\n    \"\"\"Generate Simon round keys from master key\"\"\"\n    # Extract m key words from master key\n    ks = []\n    mask = (1 << 32) - 1\n    for i in range(3):\n        word = (master_key >> (32 * ((3 - 1) - i))) & (1 << 32) - 1\n        ks.append(word)\n    \n    # Generate remaining keys recursively\n    return simon_gen_key_schedule_rec(ks, 0)", "output": "definition simon_64_96_generate_key_schedule :: \"32 word list ⇒ 32 word list\" where\n  \"simon_64_96_generate_key_schedule init = simon_64_96_gen_key_schedule_rec init (length init)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.111684", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(64/96) Encrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 42 Feistel rounds in encryption/decryption.", "input": "def simon_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply Simon Feistel rounds for encryption\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    new_x, new_y = simon_encrypt_round(\n        x, y, k,\n        32,\n        (1 << 32) - 1\n    )\n    \n    # Recursive call for next round\n    return simon_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun simon_64_96_encrypt_iterate :: \"32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word\" where\n  \"simon_64_96_encrypt_iterate st [] = st\" | \"simon_64_96_encrypt_iterate st (k#ks) = simon_64_96_encrypt_iterate (simon_64_96_encrypt_round k st) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.111789", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/96) Decrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 42 Feistel rounds in encryption/decryption.", "input": "def simon_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply Simon Feistel rounds for decryption (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    new_x, new_y = simon_decrypt_round(\n        x, y, k,\n        32,\n        (1 << 32) - 1\n    )\n    \n    # Recursive call for previous round\n    return simon_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun simon_64_96_decrypt_iterate :: \"32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word\" where\n  \"simon_64_96_decrypt_iterate st ks = foldl (λst_new k. simon_64_96_decrypt_round_inverse k st_new) st (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.111857", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/96) Encrypt Block from Python to Isabelle/HOL. Note: SIMON processes 64-bit blocks as two 32-bit halves.", "input": "def simon_encrypt_block(plaintext, key_schedule):\n    \"\"\"SIMON block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 32\n    mask = (1 << 32) - 1\n    left = (plaintext >> 32) & (1 << 32) - 1\n    right = plaintext & (1 << 32) - 1\n    \n    # Apply all rounds\n    cipher_left, cipher_right = simon_encrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (cipher_left << 32) | cipher_right", "output": "definition simon_64_96_encrypt_block ::\n  \"32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word\" where\n\"simon_64_96_encrypt_block state keys =\n   simon_64_96_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.112016", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/96) Decrypt Block from Python to Isabelle/HOL. Note: SIMON processes 64-bit blocks as two 32-bit halves.", "input": "def simon_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SIMON block decryption\"\"\"\n    # Split into left and right halves\n    # word_size = 32\n    mask = (1 << 32) - 1\n    left = (ciphertext >> 32) & (1 << 32) - 1\n    right = ciphertext & (1 << 32) - 1\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = simon_decrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 32) | plain_right", "output": "definition simon_64_96_decrypt_block ::\n  \"32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word\" where\n\"simon_64_96_decrypt_block state keys =\n   simon_64_96_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.112090", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/96) Block Splitting from Python to Isabelle/HOL. Note: SIMON processes 64-bit blocks as two 32-bit halves.", "input": "def simon_split_block(block):\n    \"\"\"Split 64-bit block into two 32-bit words\"\"\"\n    mask = (1 << 32) - 1\n    left = (block >> 32) & (1 << 32) - 1\n    right = block & (1 << 32) - 1\n    return left, right", "output": "definition simon_64_96_split_block :: \"64 word ⇒ (32 word × 32 word)\" where\n  \"simon_64_96_split_block block = (\n    let left = ucast (drop_bit 32 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.112134", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/96) Block Combining from Python to Isabelle/HOL. Note: SIMON processes 64-bit blocks as two 32-bit halves.", "input": "def simon_combine_block(left, right):\n    \"\"\"Combine two 32-bit words into 64-bit block\"\"\"\n    return (left << 32) | right", "output": "definition simon_64_96_combine_block :: \"32 word × 32 word ⇒ 64 word\" where\n  \"simon_64_96_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 32 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.112172", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/96) Top-Level Encrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 42 rounds.", "input": "def simon_encrypt(plaintext, master_key):\n    \"\"\"Top-level SIMON encryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return simon_encrypt_block(plaintext, key_schedule)", "output": "definition simon_64_96_encrypt ::\n  \"64 word ⇒ 32 word list ⇒ 64 word\" where\n\"simon_64_96_encrypt plaintext keys =\n  (let left  = ucast (drop_bit 32 plaintext);\n       right = ucast plaintext;\n       (c_l, c_r) = simon_64_96_encrypt_block (left, right) keys\n   in or (push_bit 32 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.113207", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(64/96) Top-Level Decrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 42 rounds.", "input": "def simon_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SIMON decryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return simon_decrypt_block(ciphertext, key_schedule)", "output": "definition simon_64_96_decrypt ::\n  \"64 word ⇒ 32 word list ⇒ 64 word\" where\n\"simon_64_96_decrypt ciphertext keys =\n  (let left  = ucast (drop_bit 32 ciphertext);\n       right = ucast ciphertext;\n       (p_l, p_r) = simon_64_96_decrypt_block (left, right) keys\n   in or (push_bit 32 (ucast p_l)) (ucast p_r))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.113254", "variant": {"block_size": 64, "key_size": 96, "word_size": 32, "rounds": 42, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(128/256) Word Size Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 72 rounds.", "input": "# Word size in bits for SIMON(128/256)\nword_size = 64", "output": "definition simon_128_256_word_size :: nat where \"simon_128_256_word_size = 64\"", "metadata": {"component_type": "Word Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.117944", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(128/256) Rounds Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "# Number of rounds for SIMON(128/256)\nrounds = 72", "output": "definition simon_128_256_rounds :: nat where \"simon_128_256_rounds = 72\"", "metadata": {"component_type": "Rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.118737", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap"]}}
{"instruction": "Translate the SIMON(128/256) Block Size Constant from Python to Isabelle/HOL. Note: SIMON processes 128-bit blocks as two 64-bit halves.", "input": "# 128-bit block size\nblock_size = 128", "output": "definition simon_128_256_block_size :: nat where \"simon_128_256_block_size = 128\"", "metadata": {"component_type": "Block Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.119376", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(128/256) Key Size Constant from Python to Isabelle/HOL. Note: Key expansion uses 4 initial key words and Z-sequence bits.", "input": "# 256-bit key size\nkey_size = 256", "output": "definition simon_128_256_key_size :: nat where \"simon_128_256_key_size = 256\"", "metadata": {"component_type": "Key Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.120050", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(128/256) Z Index Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 72 rounds.", "input": "# Z sequence index for SIMON(128/256)\nz_index = 2", "output": "definition simon_128_256_z_index :: nat where \"simon_128_256_z_index = 2\"", "metadata": {"component_type": "Z Index Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.120637", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(128/256) M Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 72 rounds.", "input": "# Number of key words (m) for SIMON(128/256)\nm = 4", "output": "definition simon_128_256_m :: nat where \"simon_128_256_m = 4\"", "metadata": {"component_type": "M Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.122046", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(128/256) Z Sequence Constant from Python to Isabelle/HOL. Note: Z-sequence bits are used as round constants in SIMON key schedule.", "input": "# Simon Z sequence 2\nz2 = 0b11001101101001111110001000010100011001001011000000111011110101", "output": "definition simon_128_256_z2 :: nat where \"simon_128_256_z2 = 0b11001101101001111110001000010100011001001011000000111011110101\"", "metadata": {"component_type": "Z Sequence Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.123041", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(128/256) F-Function from Python to Isabelle/HOL. Note: SIMON F-function: F(x) = ((x <<< 1) & (x <<< 8)) ^ (x <<< 2) with 64-bit words.", "input": "def simon_f_function(x, word_size = 64 , mod_mask = (2 ** 64) - 1 ):\n    \"\"\"Simon F-function: ((S¹(x) & S⁸(x)) ⊕ S²(x))\"\"\"\n    # USE | for consistency with other Simon functions\n    s1_x = ((x << 1) | (x >> (64 - 1))) & (2 ** 64) - 1   # Left rotate 1\n    s8_x = ((x << 8) | (x >> (64 - 8))) & (2 ** 64) - 1   # Left rotate 8\n    s2_x = ((x << 2) | (x >> (64 - 2))) & (2 ** 64) - 1   # Left rotate 2\n    \n    return (s1_x & s8_x) ^ s2_x", "output": "definition simon_128_256_F_function :: \"64 word ⇒ 64 word\" where\n  \"simon_128_256_F_function x = xor (and (word_rotl 1 x) (word_rotl 8 x)) (word_rotl 2 x)\"", "metadata": {"component_type": "F-Function", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.123142", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/256) Encrypt Round from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_encrypt_round(k, (x, y)):\n    \"\"\"Simon encrypt round: new_x = k ⊕ F(x) ⊕ y, new_y = x\"\"\"\n    # word_size = 64\n    mask = (1 << 64) - 1\n    \n    # USE | for consistency\n    s1_x = ((x << 1) | (x >> (64 - 1))) & (1 << 64) - 1 # left rotate 1\n    s8_x = ((x << 8) | (x >> (64 - 8))) & (1 << 64) - 1 # left rotate 8\n    s2_x = ((x << 2) | (x >> (64 - 2))) & (1 << 64) - 1 # left rotate 2\n    fx = (s1_x & s8_x) ^ s2_x\n    \n    new_x = k ^ fx ^ y\n    new_y = x\n    return new_x, new_y", "output": "definition simon_128_256_encrypt_round :: \"64 word ⇒ 64 word × 64 word ⇒ 64 word × 64 word\" where\n  \"simon_128_256_encrypt_round k xy = (let (x, y) = xy in (xor (xor k (simon_128_256_F_function x)) y, x))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.123224", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/256) Decrypt Round Inverse from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_decrypt_round_inverse(k, (x, y)):\n    \"\"\"Simon decrypt round: new_y = k ⊕ F(y) ⊕ x, new_x = y\"\"\"\n    # word_size = 64\n    mask = (1 << 64) - 1\n    \n    # USE | for consistency\n    s1_y = ((y << 1) | (y >> (64 - 1))) & (1 << 64) - 1 # left rotate 1\n    s8_y = ((y << 8) | (y >> (64 - 8))) & (1 << 64) - 1 # left rotate 8\n    s2_y = ((y << 2) | (y >> (64 - 2))) & (1 << 64) - 1 # left rotate 2\n    fy = (s1_y & s8_y) ^ s2_y\n    \n    new_y = k ^ fy ^ x\n    new_x = y\n    return new_x, new_y", "output": "definition simon_128_256_decrypt_round_inverse :: \"64 word ⇒ 64 word × 64 word ⇒ 64 word × 64 word\" where\n  \"simon_128_256_decrypt_round_inverse k xy_new = (let (x_new, y_new) = xy_new in (y_new, xor (xor x_new k) (simon_128_256_F_function y_new)))\"", "metadata": {"component_type": "Decrypt Round Inverse", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.123283", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/256) Round Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "round_constant = (1 << 64) - 4 ", "output": "definition simon_128_256_rho_const :: \"64 word\" where\n  \"simon_128_256_rho_const = 0xFFFFFFFFFFFFFFFC\"", "metadata": {"component_type": "Round Constant", "difficulty": "easy", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.123340", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/256) Key Schedule Recursive from Python to Isabelle/HOL. Note: Key expansion uses 4 initial key words and Z-sequence bits.", "input": "def simon_gen_key_schedule_rec(ks, i, word_size=64):\n    \"\"\"Recursive Simon key schedule - matches Isabelle function signature\"\"\"\n    if i >= 72:\n        return ks\n    \n    mask = (1 << 64) - 1\n    \n    # Z sequence bit extraction (like bit function in Isabelle)\n    z_bit = (0b11001101101001111110001000010100011001001011000000111011110101 >> ((i - 3) % 62)) & 1\n    \n    # Right rotations (word_rotr in Isabelle)\n    # rs_3 = word_rotr 3 (ks[i-1])\n    key_idx_m1 = ks[i-1] if i > 0 else 0\n    rs_3 = ((key_idx_m1 >> 3) | (key_idx_m1 << (64 - 3))) & (1 << 64) - 1\n    \n    # rs_1 = word_rotr 1 rs_3\n    rs_1 = ((rs_3 >> 1) | (rs_3 << (64 - 1))) & (1 << 64) - 1\n    \n    # Round constant (0xFFFFFFFC for 32-bit)\n    rho_const = (1 << 64) - 1 ^ 3  \n    \n    # Compute new key: xor (xor (xor (ks[i-3]) rs_3) rs_1) (xor (if z_bit then 1 else 0) rho_const)\n    key_idx_m3 = ks[i-3] if i >= 3 else 0\n    temp1 = key_idx_m3 ^ rs_3\n    temp2 = temp1 ^ rs_1\n    z_bit_word = 1 if z_bit else 0\n    z_rho = z_bit_word ^ rho_const\n    new_k = temp2 ^ z_rho\n    \n    # Append and recurse (notice: ks is list, returns list)\n    return simon_gen_key_schedule_rec(ks + [new_k], i + 1, 64)", "output": "function simon_128_256_gen_key_schedule_rec :: \"64 word list ⇒ nat ⇒ 64 word list\" where\n  \"simon_128_256_gen_key_schedule_rec ks i = (if i ≥ 72 then ks else\n    let z_bit = bit simon_128_256_z4 (i - 4);\n        rs_3 = word_rotr 3 (ks ! (i-1)); rs_1 = word_rotr 1 rs_3;\n        new_k = xor (xor (xor (ks ! (i-4)) rs_3) rs_1) (xor (if z_bit then 1 else 0) 0xFFFFFFFFFFFFFFFC)\n    in simon_128_256_gen_key_schedule_rec (ks @ [new_k]) (i+1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(ks, i). 72 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.123394", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(128/256) Key Schedule Wrapper from Python to Isabelle/HOL. Note: Key expansion uses 4 initial key words and Z-sequence bits.", "input": "def simon_generate_key_schedule(master_key, word_size=64):\n    \"\"\"Generate Simon round keys from master key\"\"\"\n    # Extract m key words from master key\n    ks = []\n    mask = (1 << 64) - 1\n    for i in range(4):\n        word = (master_key >> (64 * ((4 - 1) - i))) & (1 << 64) - 1\n        ks.append(word)\n    \n    # Generate remaining keys recursively\n    return simon_gen_key_schedule_rec(ks, 0)", "output": "definition simon_128_256_generate_key_schedule :: \"64 word list ⇒ 64 word list\" where\n  \"simon_128_256_generate_key_schedule init = simon_128_256_gen_key_schedule_rec init (length init)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.123437", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(128/256) Encrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 72 Feistel rounds in encryption/decryption.", "input": "def simon_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply Simon Feistel rounds for encryption\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    new_x, new_y = simon_encrypt_round(\n        x, y, k,\n        64,\n        (1 << 64) - 1\n    )\n    \n    # Recursive call for next round\n    return simon_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun simon_128_256_encrypt_iterate :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"simon_128_256_encrypt_iterate st [] = st\" \n| \"simon_128_256_encrypt_iterate st (k#ks) = simon_128_256_encrypt_iterate (simon_128_256_encrypt_round k st) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.123485", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/256) Decrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 72 Feistel rounds in encryption/decryption.", "input": "def simon_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply Simon Feistel rounds for decryption (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    new_x, new_y = simon_decrypt_round(\n        x, y, k,\n        64,\n        (1 << 64) - 1\n    )\n    \n    # Recursive call for previous round\n    return simon_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun simon_128_256_decrypt_iterate :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"simon_128_256_decrypt_iterate st ks = foldl (λst_new k. simon_128_256_decrypt_round_inverse k st_new) st (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.123526", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/256) Encrypt Block from Python to Isabelle/HOL. Note: SIMON processes 128-bit blocks as two 64-bit halves.", "input": "def simon_encrypt_block(plaintext, key_schedule):\n    \"\"\"SIMON block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 64\n    mask = (1 << 64) - 1\n    left = (plaintext >> 64) & (1 << 64) - 1\n    right = plaintext & (1 << 64) - 1\n    \n    # Apply all rounds\n    cipher_left, cipher_right = simon_encrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (cipher_left << 64) | cipher_right", "output": "definition simon_128_256_encrypt_block ::\n  \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n\"simon_128_256_encrypt_block state keys =\n   simon_128_256_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.123658", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/256) Decrypt Block from Python to Isabelle/HOL. Note: SIMON processes 128-bit blocks as two 64-bit halves.", "input": "def simon_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SIMON block decryption\"\"\"\n    # Split into left and right halves\n    # word_size = 64\n    mask = (1 << 64) - 1\n    left = (ciphertext >> 64) & (1 << 64) - 1\n    right = ciphertext & (1 << 64) - 1\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = simon_decrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 64) | plain_right", "output": "definition simon_128_256_decrypt_block ::\n  \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n\"simon_128_256_decrypt_block state keys =\n   simon_128_256_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.123704", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/256) Block Splitting from Python to Isabelle/HOL. Note: SIMON processes 128-bit blocks as two 64-bit halves.", "input": "def simon_split_block(block):\n    \"\"\"Split 128-bit block into two 64-bit words\"\"\"\n    mask = (1 << 64) - 1\n    left = (block >> 64) & (1 << 64) - 1\n    right = block & (1 << 64) - 1\n    return left, right", "output": "definition simon_128_256_split_block :: \"128 word ⇒ (64 word × 64 word)\" where\n  \"simon_128_256_split_block block = (\n    let left = ucast (drop_bit 64 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.123738", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/256) Block Combining from Python to Isabelle/HOL. Note: SIMON processes 128-bit blocks as two 64-bit halves.", "input": "def simon_combine_block(left, right):\n    \"\"\"Combine two 64-bit words into 128-bit block\"\"\"\n    return (left << 64) | right", "output": "definition simon_128_256_combine_block :: \"64 word × 64 word ⇒ 128 word\" where\n  \"simon_128_256_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 64 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.123760", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/256) Top-Level Encrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 72 rounds.", "input": "def simon_encrypt(plaintext, master_key):\n    \"\"\"Top-level SIMON encryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return simon_encrypt_block(plaintext, key_schedule)", "output": "definition simon_128_256_encrypt ::\n  \"128 word ⇒ 64 word list ⇒ 128 word\" where\n\"simon_128_256_encrypt plaintext keys =\n  (let left  = ucast (drop_bit 64 plaintext);\n       right = ucast plaintext;\n       (c_l, c_r) = simon_128_256_encrypt_block (left, right) keys\n   in or (push_bit 64 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.123993", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(128/256) Top-Level Decrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 72 rounds.", "input": "def simon_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SIMON decryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return simon_decrypt_block(ciphertext, key_schedule)", "output": "definition simon_128_256_decrypt ::\n  \"128 word ⇒ 64 word list ⇒ 128 word\" where\n\"simon_128_256_decrypt ciphertext keys =\n  (let left  = ucast (drop_bit 64 ciphertext);\n       right = ucast ciphertext;\n       (p_l, p_r) = simon_128_256_decrypt_block (left, right) keys\n   in or (push_bit 64 (ucast p_l)) (ucast p_r))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.124015", "variant": {"block_size": 128, "key_size": 256, "word_size": 64, "rounds": 72, "z_index": 2, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(48/96) Word Size Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 36 rounds.", "input": "# Word size in bits for SIMON(48/96)\nword_size = 24", "output": "definition simon_48_96_word_size :: nat where \"simon_48_96_word_size = 24\"", "metadata": {"component_type": "Word Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.127812", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(48/96) Rounds Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "# Number of rounds for SIMON(48/96)\nrounds = 36", "output": "definition simon_48_96_rounds :: nat where \"simon_48_96_rounds = 36\"", "metadata": {"component_type": "Rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.128499", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap"]}}
{"instruction": "Translate the SIMON(48/96) Block Size Constant from Python to Isabelle/HOL. Note: SIMON processes 48-bit blocks as two 24-bit halves.", "input": "# 48-bit block size\nblock_size = 48", "output": "definition simon_48_96_block_size :: nat where \"simon_48_96_block_size = 48\"", "metadata": {"component_type": "Block Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.129167", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(48/96) Key Size Constant from Python to Isabelle/HOL. Note: Key expansion uses 3 initial key words and Z-sequence bits.", "input": "# 96-bit key size\nkey_size = 96", "output": "definition simon_48_96_key_size :: nat where \"simon_48_96_key_size = 96\"", "metadata": {"component_type": "Key Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.129803", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(48/96) Z Index Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 36 rounds.", "input": "# Z sequence index for SIMON(48/96)\nz_index = 0", "output": "definition simon_48_96_z_index :: nat where \"simon_48_96_z_index = 0\"", "metadata": {"component_type": "Z Index Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.130821", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(48/96) M Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 36 rounds.", "input": "# Number of key words (m) for SIMON(48/96)\nm = 3", "output": "definition simon_48_96_m :: nat where \"simon_48_96_m = 3\"", "metadata": {"component_type": "M Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.131490", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(48/96) Z Sequence Constant from Python to Isabelle/HOL. Note: Z-sequence bits are used as round constants in SIMON key schedule.", "input": "# Simon Z sequence 0\nz0 = 0b01100111000011010100100010111110110011100001101010010001011111", "output": "definition simon_48_96_z0 :: nat where \"simon_48_96_z0 = 0b01100111000011010100100010111110110011100001101010010001011111\"", "metadata": {"component_type": "Z Sequence Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.132298", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(48/96) F-Function from Python to Isabelle/HOL. Note: SIMON F-function: F(x) = ((x <<< 1) & (x <<< 8)) ^ (x <<< 2) with 24-bit words.", "input": "def simon_f_function(x, word_size = 24 , mod_mask = (2 ** 24) - 1 ):\n    \"\"\"Simon F-function: ((S¹(x) & S⁸(x)) ⊕ S²(x))\"\"\"\n    # USE | for consistency with other Simon functions\n    s1_x = ((x << 1) | (x >> (24 - 1))) & (2 ** 24) - 1   # Left rotate 1\n    s8_x = ((x << 8) | (x >> (24 - 8))) & (2 ** 24) - 1   # Left rotate 8\n    s2_x = ((x << 2) | (x >> (24 - 2))) & (2 ** 24) - 1   # Left rotate 2\n    \n    return (s1_x & s8_x) ^ s2_x", "output": "definition simon_48_96_F_function :: \"24 word ⇒ 24 word\" where\n  \"simon_48_96_F_function x = xor (and (word_rotl 1 x) (word_rotl 8 x)) (word_rotl 2 x)\"", "metadata": {"component_type": "F-Function", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.132417", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/96) Encrypt Round from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_encrypt_round(k, (x, y)):\n    \"\"\"Simon encrypt round: new_x = k ⊕ F(x) ⊕ y, new_y = x\"\"\"\n    # word_size = 24\n    mask = (1 << 24) - 1\n    \n    # USE | for consistency\n    s1_x = ((x << 1) | (x >> (24 - 1))) & (1 << 24) - 1 # left rotate 1\n    s8_x = ((x << 8) | (x >> (24 - 8))) & (1 << 24) - 1 # left rotate 8\n    s2_x = ((x << 2) | (x >> (24 - 2))) & (1 << 24) - 1 # left rotate 2\n    fx = (s1_x & s8_x) ^ s2_x\n    \n    new_x = k ^ fx ^ y\n    new_y = x\n    return new_x, new_y", "output": "definition simon_48_96_encrypt_round :: \"24 word ⇒ 24 word × 24 word ⇒ 24 word × 24 word\" where\n  \"simon_48_96_encrypt_round k xy = (let (x, y) = xy in (xor (xor k (simon_48_96_F_function x)) y, x))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.132520", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/96) Decrypt Round Inverse from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_decrypt_round_inverse(k, (x, y)):\n    \"\"\"Simon decrypt round: new_y = k ⊕ F(y) ⊕ x, new_x = y\"\"\"\n    # word_size = 24\n    mask = (1 << 24) - 1\n    \n    # USE | for consistency\n    s1_y = ((y << 1) | (y >> (24 - 1))) & (1 << 24) - 1 # left rotate 1\n    s8_y = ((y << 8) | (y >> (24 - 8))) & (1 << 24) - 1 # left rotate 8\n    s2_y = ((y << 2) | (y >> (24 - 2))) & (1 << 24) - 1 # left rotate 2\n    fy = (s1_y & s8_y) ^ s2_y\n    \n    new_y = k ^ fy ^ x\n    new_x = y\n    return new_x, new_y", "output": "definition simon_48_96_decrypt_round_inverse :: \"24 word ⇒ 24 word × 24 word ⇒ 24 word × 24 word\" where\n  \"simon_48_96_decrypt_round_inverse k xy_new = (let (x_new, y_new) = xy_new in (y_new, xor (xor x_new k) (simon_48_96_F_function y_new)))\"", "metadata": {"component_type": "Decrypt Round Inverse", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.132610", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/96) Round Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "round_constant = (1 << 24) - 4 ", "output": "definition simon_48_96_rho_const :: \"24 word\" where\n  \"simon_48_96_rho_const = 0xFFFFFC\"", "metadata": {"component_type": "Round Constant", "difficulty": "easy", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.132716", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/96) Key Schedule Recursive from Python to Isabelle/HOL. Note: Key expansion uses 3 initial key words and Z-sequence bits.", "input": "def simon_gen_key_schedule_rec(ks, i, word_size=24):\n    \"\"\"Recursive Simon key schedule - matches Isabelle function signature\"\"\"\n    if i >= 36:\n        return ks\n    \n    mask = (1 << 24) - 1\n    \n    # Z sequence bit extraction (like bit function in Isabelle)\n    z_bit = (0b01100111000011010100100010111110110011100001101010010001011111 >> ((i - 3) % 62)) & 1\n    \n    # Right rotations (word_rotr in Isabelle)\n    # rs_3 = word_rotr 3 (ks[i-1])\n    key_idx_m1 = ks[i-1] if i > 0 else 0\n    rs_3 = ((key_idx_m1 >> 3) | (key_idx_m1 << (24 - 3))) & (1 << 24) - 1\n    \n    # rs_1 = word_rotr 1 rs_3\n    rs_1 = ((rs_3 >> 1) | (rs_3 << (24 - 1))) & (1 << 24) - 1\n    \n    # Round constant (0xFFFFFFFC for 32-bit)\n    rho_const = (1 << 24) - 1 ^ 3  \n    \n    # Compute new key: xor (xor (xor (ks[i-3]) rs_3) rs_1) (xor (if z_bit then 1 else 0) rho_const)\n    key_idx_m3 = ks[i-3] if i >= 3 else 0\n    temp1 = key_idx_m3 ^ rs_3\n    temp2 = temp1 ^ rs_1\n    z_bit_word = 1 if z_bit else 0\n    z_rho = z_bit_word ^ rho_const\n    new_k = temp2 ^ z_rho\n    \n    # Append and recurse (notice: ks is list, returns list)\n    return simon_gen_key_schedule_rec(ks + [new_k], i + 1, 24)", "output": "function simon_48_96_gen_key_schedule_rec :: \"24 word list ⇒ nat ⇒ 24 word list\" where\n  \"simon_48_96_gen_key_schedule_rec ks i = (if i ≥ 36 then ks else\n    let z_bit = bit simon_48_96_z1 (i - 4);\n        rs_3 = word_rotr 3 (ks ! (i-1)); rs_1 = word_rotr 1 rs_3;\n        new_k = xor (xor (xor (ks ! (i-4)) rs_3) rs_1) (xor (if z_bit then 1 else 0) simon_48_96_rho_const)\n    in simon_48_96_gen_key_schedule_rec (ks @ [new_k]) (i+1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(ks, i). 36 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.132780", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(48/96) Key Schedule Wrapper from Python to Isabelle/HOL. Note: Key expansion uses 3 initial key words and Z-sequence bits.", "input": "def simon_generate_key_schedule(master_key, word_size=24):\n    \"\"\"Generate Simon round keys from master key\"\"\"\n    # Extract m key words from master key\n    ks = []\n    mask = (1 << 24) - 1\n    for i in range(3):\n        word = (master_key >> (24 * ((3 - 1) - i))) & (1 << 24) - 1\n        ks.append(word)\n    \n    # Generate remaining keys recursively\n    return simon_gen_key_schedule_rec(ks, 0)", "output": "definition simon_48_96_generate_key_schedule :: \"24 word list ⇒ 24 word list\" where\n  \"simon_48_96_generate_key_schedule init = simon_48_96_gen_key_schedule_rec init (length init)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.132821", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(48/96) Encrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 36 Feistel rounds in encryption/decryption.", "input": "def simon_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply Simon Feistel rounds for encryption\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    new_x, new_y = simon_encrypt_round(\n        x, y, k,\n        24,\n        (1 << 24) - 1\n    )\n    \n    # Recursive call for next round\n    return simon_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun simon_48_96_encrypt_iterate :: \"24 word × 24 word ⇒ 24 word list ⇒ 24 word × 24 word\" where\n  \"simon_48_96_encrypt_iterate st [] = st\" \n| \"simon_48_96_encrypt_iterate st (k#ks) = simon_48_96_encrypt_iterate (simon_48_96_encrypt_round k st) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.132970", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/96) Decrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 36 Feistel rounds in encryption/decryption.", "input": "def simon_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply Simon Feistel rounds for decryption (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    new_x, new_y = simon_decrypt_round(\n        x, y, k,\n        24,\n        (1 << 24) - 1\n    )\n    \n    # Recursive call for previous round\n    return simon_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun simon_48_96_decrypt_iterate :: \"24 word × 24 word ⇒ 24 word list ⇒ 24 word × 24 word\" where\n  \"simon_48_96_decrypt_iterate st ks = foldl (λst_new k. simon_48_96_decrypt_round_inverse k st_new) st (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.133020", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/96) Encrypt Block from Python to Isabelle/HOL. Note: SIMON processes 48-bit blocks as two 24-bit halves.", "input": "def simon_encrypt_block(plaintext, key_schedule):\n    \"\"\"SIMON block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 24\n    mask = (1 << 24) - 1\n    left = (plaintext >> 24) & (1 << 24) - 1\n    right = plaintext & (1 << 24) - 1\n    \n    # Apply all rounds\n    cipher_left, cipher_right = simon_encrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (cipher_left << 24) | cipher_right", "output": "definition simon_48_96_encrypt_block ::\n  \"24 word × 24 word ⇒ 24 word list ⇒ 24 word × 24 word\" where\n\"simon_48_96_encrypt_block state keys =\n   simon_48_96_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.133079", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/96) Decrypt Block from Python to Isabelle/HOL. Note: SIMON processes 48-bit blocks as two 24-bit halves.", "input": "def simon_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SIMON block decryption\"\"\"\n    # Split into left and right halves\n    # word_size = 24\n    mask = (1 << 24) - 1\n    left = (ciphertext >> 24) & (1 << 24) - 1\n    right = ciphertext & (1 << 24) - 1\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = simon_decrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 24) | plain_right", "output": "definition simon_48_96_decrypt_block ::\n  \"24 word × 24 word ⇒ 24 word list ⇒ 24 word × 24 word\" where\n\"simon_48_96_decrypt_block state keys =\n   simon_48_96_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.133122", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/96) Block Splitting from Python to Isabelle/HOL. Note: SIMON processes 48-bit blocks as two 24-bit halves.", "input": "def simon_split_block(block):\n    \"\"\"Split 48-bit block into two 24-bit words\"\"\"\n    mask = (1 << 24) - 1\n    left = (block >> 24) & (1 << 24) - 1\n    right = block & (1 << 24) - 1\n    return left, right", "output": "definition simon_48_96_split_block :: \"48 word ⇒ (24 word × 24 word)\" where\n  \"simon_48_96_split_block block = (\n    let left = ucast (drop_bit 24 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.133156", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/96) Block Combining from Python to Isabelle/HOL. Note: SIMON processes 48-bit blocks as two 24-bit halves.", "input": "def simon_combine_block(left, right):\n    \"\"\"Combine two 24-bit words into 48-bit block\"\"\"\n    return (left << 24) | right", "output": "definition simon_48_96_combine_block :: \"24 word × 24 word ⇒ 48 word\" where\n  \"simon_48_96_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 24 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.133179", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/96) Top-Level Encrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 36 rounds.", "input": "def simon_encrypt(plaintext, master_key):\n    \"\"\"Top-level SIMON encryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return simon_encrypt_block(plaintext, key_schedule)", "output": "definition simon_48_96_encrypt ::\n  \"48 word ⇒ 24 word list ⇒ 48 word\" where\n\"simon_48_96_encrypt plaintext keys =\n  (let left  = ucast (drop_bit 24 plaintext);\n       right = ucast plaintext;\n       (c_l, c_r) = simon_48_96_encrypt_block (left, right) keys\n   in or (push_bit 24 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.133405", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(48/96) Top-Level Decrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 36 rounds.", "input": "def simon_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SIMON decryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return simon_decrypt_block(ciphertext, key_schedule)", "output": "definition simon_48_96_decrypt ::\n  \"48 word ⇒ 24 word list ⇒ 48 word\" where\n\"simon_48_96_decrypt ciphertext keys =\n  (let left  = ucast (drop_bit 24 ciphertext);\n       right = ucast ciphertext;\n       (p_l, p_r) = simon_48_96_decrypt_block (left, right) keys\n   in or (push_bit 24 (ucast p_l)) (ucast p_r))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.133436", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(128/192) Word Size Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 69 rounds.", "input": "# Word size in bits for SIMON(128/192)\nword_size = 64", "output": "definition simon_128_192_word_size :: nat where \"simon_128_192_word_size = 64\"", "metadata": {"component_type": "Word Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.135852", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(128/192) Rounds Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "# Number of rounds for SIMON(128/192)\nrounds = 69", "output": "definition simon_128_192_rounds :: nat where \"simon_128_192_rounds = 69\"", "metadata": {"component_type": "Rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.136489", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap"]}}
{"instruction": "Translate the SIMON(128/192) Block Size Constant from Python to Isabelle/HOL. Note: SIMON processes 128-bit blocks as two 64-bit halves.", "input": "# 128-bit block size\nblock_size = 128", "output": "definition simon_128_192_block_size :: nat where \"simon_128_192_block_size = 128\"", "metadata": {"component_type": "Block Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.137247", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(128/192) Key Size Constant from Python to Isabelle/HOL. Note: Key expansion uses 3 initial key words and Z-sequence bits.", "input": "# 192-bit key size\nkey_size = 192", "output": "definition simon_128_192_key_size :: nat where \"simon_128_192_key_size = 192\"", "metadata": {"component_type": "Key Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.137854", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(128/192) Z Index Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 69 rounds.", "input": "# Z sequence index for SIMON(128/192)\nz_index = 2", "output": "definition simon_128_192_z_index :: nat where \"simon_128_192_z_index = 2\"", "metadata": {"component_type": "Z Index Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.138468", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(128/192) M Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 69 rounds.", "input": "# Number of key words (m) for SIMON(128/192)\nm = 3", "output": "definition simon_128_192_m :: nat where \"simon_128_192_m = 3\"", "metadata": {"component_type": "M Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.139078", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(128/192) Z Sequence Constant from Python to Isabelle/HOL. Note: Z-sequence bits are used as round constants in SIMON key schedule.", "input": "# Simon Z sequence 2\nz2 = 0b11001101101001111110001000010100011001001011000000111011110101", "output": "definition simon_128_192_z2 :: nat where \"simon_128_192_z2 = 0b11001101101001111110001000010100011001001011000000111011110101\"", "metadata": {"component_type": "Z Sequence Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.139680", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(128/192) F-Function from Python to Isabelle/HOL. Note: SIMON F-function: F(x) = ((x <<< 1) & (x <<< 8)) ^ (x <<< 2) with 64-bit words.", "input": "def simon_f_function(x, word_size = 64 , mod_mask = (2 ** 64) - 1 ):\n    \"\"\"Simon F-function: ((S¹(x) & S⁸(x)) ⊕ S²(x))\"\"\"\n    # USE | for consistency with other Simon functions\n    s1_x = ((x << 1) | (x >> (64 - 1))) & (2 ** 64) - 1   # Left rotate 1\n    s8_x = ((x << 8) | (x >> (64 - 8))) & (2 ** 64) - 1   # Left rotate 8\n    s2_x = ((x << 2) | (x >> (64 - 2))) & (2 ** 64) - 1   # Left rotate 2\n    \n    return (s1_x & s8_x) ^ s2_x", "output": "definition simon_128_192_F_function :: \"64 word ⇒ 64 word\" where\n  \"simon_128_192_F_function x = xor (and (word_rotl 1 x) (word_rotl 8 x)) (word_rotl 2 x)\"", "metadata": {"component_type": "F-Function", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.139761", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/192) Encrypt Round from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_encrypt_round(k, (x, y)):\n    \"\"\"Simon encrypt round: new_x = k ⊕ F(x) ⊕ y, new_y = x\"\"\"\n    # word_size = 64\n    mask = (1 << 64) - 1\n    \n    # USE | for consistency\n    s1_x = ((x << 1) | (x >> (64 - 1))) & (1 << 64) - 1 # left rotate 1\n    s8_x = ((x << 8) | (x >> (64 - 8))) & (1 << 64) - 1 # left rotate 8\n    s2_x = ((x << 2) | (x >> (64 - 2))) & (1 << 64) - 1 # left rotate 2\n    fx = (s1_x & s8_x) ^ s2_x\n    \n    new_x = k ^ fx ^ y\n    new_y = x\n    return new_x, new_y", "output": "definition simon_128_192_encrypt_round :: \"64 word ⇒ 64 word × 64 word ⇒ 64 word × 64 word\" where\n  \"simon_128_192_encrypt_round k xy = (let (x, y) = xy in (xor (xor k (simon_128_192_F_function x)) y, x))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.139912", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/192) Decrypt Round Inverse from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_decrypt_round_inverse(k, (x, y)):\n    \"\"\"Simon decrypt round: new_y = k ⊕ F(y) ⊕ x, new_x = y\"\"\"\n    # word_size = 64\n    mask = (1 << 64) - 1\n    \n    # USE | for consistency\n    s1_y = ((y << 1) | (y >> (64 - 1))) & (1 << 64) - 1 # left rotate 1\n    s8_y = ((y << 8) | (y >> (64 - 8))) & (1 << 64) - 1 # left rotate 8\n    s2_y = ((y << 2) | (y >> (64 - 2))) & (1 << 64) - 1 # left rotate 2\n    fy = (s1_y & s8_y) ^ s2_y\n    \n    new_y = k ^ fy ^ x\n    new_x = y\n    return new_x, new_y", "output": "definition simon_128_192_decrypt_round_inverse :: \"64 word ⇒ 64 word × 64 word ⇒ 64 word × 64 word\" where\n  \"simon_128_192_decrypt_round_inverse k xy_new = (let (x_new, y_new) = xy_new in (y_new, xor (xor x_new k) (simon_128_192_F_function y_new)))\"", "metadata": {"component_type": "Decrypt Round Inverse", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.140027", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/192) Round Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "round_constant = (1 << 64) - 4 ", "output": "definition simon_128_192_rho_const :: \"64 word\" where\n  \"simon_128_192_rho_const = 0xFFFFFFFFFFFFFFFC\"", "metadata": {"component_type": "Round Constant", "difficulty": "easy", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.140108", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/192) Key Schedule Recursive from Python to Isabelle/HOL. Note: Key expansion uses 3 initial key words and Z-sequence bits.", "input": "def simon_gen_key_schedule_rec(ks, i, word_size=64):\n    \"\"\"Recursive Simon key schedule - matches Isabelle function signature\"\"\"\n    if i >= 69:\n        return ks\n    \n    mask = (1 << 64) - 1\n    \n    # Z sequence bit extraction (like bit function in Isabelle)\n    z_bit = (0b11001101101001111110001000010100011001001011000000111011110101 >> ((i - 3) % 62)) & 1\n    \n    # Right rotations (word_rotr in Isabelle)\n    # rs_3 = word_rotr 3 (ks[i-1])\n    key_idx_m1 = ks[i-1] if i > 0 else 0\n    rs_3 = ((key_idx_m1 >> 3) | (key_idx_m1 << (64 - 3))) & (1 << 64) - 1\n    \n    # rs_1 = word_rotr 1 rs_3\n    rs_1 = ((rs_3 >> 1) | (rs_3 << (64 - 1))) & (1 << 64) - 1\n    \n    # Round constant (0xFFFFFFFC for 32-bit)\n    rho_const = (1 << 64) - 1 ^ 3  \n    \n    # Compute new key: xor (xor (xor (ks[i-3]) rs_3) rs_1) (xor (if z_bit then 1 else 0) rho_const)\n    key_idx_m3 = ks[i-3] if i >= 3 else 0\n    temp1 = key_idx_m3 ^ rs_3\n    temp2 = temp1 ^ rs_1\n    z_bit_word = 1 if z_bit else 0\n    z_rho = z_bit_word ^ rho_const\n    new_k = temp2 ^ z_rho\n    \n    # Append and recurse (notice: ks is list, returns list)\n    return simon_gen_key_schedule_rec(ks + [new_k], i + 1, 64)", "output": "function simon_128_192_gen_key_schedule_rec :: \"64 word list ⇒ nat ⇒ 64 word list\" where\n  \"simon_128_192_gen_key_schedule_rec ks i = (if i ≥ 69 then ks else\n    let z_bit = bit simon_128_192_z3 (i - 3);\n        rs_3 = word_rotr 3 (ks ! (i-1)); rs_1 = word_rotr 1 rs_3;\n        new_k = xor (xor (xor (ks ! (i-3)) rs_3) rs_1) (xor (if z_bit then 1 else 0) simon_128_192_rho_const)\n    in simon_128_192_gen_key_schedule_rec (ks @ [new_k]) (i+1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(ks, i). 69 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.140160", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(128/192) Key Schedule Wrapper from Python to Isabelle/HOL. Note: Key expansion uses 3 initial key words and Z-sequence bits.", "input": "def simon_generate_key_schedule(master_key, word_size=64):\n    \"\"\"Generate Simon round keys from master key\"\"\"\n    # Extract m key words from master key\n    ks = []\n    mask = (1 << 64) - 1\n    for i in range(3):\n        word = (master_key >> (64 * ((3 - 1) - i))) & (1 << 64) - 1\n        ks.append(word)\n    \n    # Generate remaining keys recursively\n    return simon_gen_key_schedule_rec(ks, 0)", "output": "definition simon_128_192_generate_key_schedule :: \"64 word list ⇒ 64 word list\" where\n  \"simon_128_192_generate_key_schedule init = simon_128_192_gen_key_schedule_rec init (length init)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.140207", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(128/192) Encrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 69 Feistel rounds in encryption/decryption.", "input": "def simon_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply Simon Feistel rounds for encryption\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    new_x, new_y = simon_encrypt_round(\n        x, y, k,\n        64,\n        (1 << 64) - 1\n    )\n    \n    # Recursive call for next round\n    return simon_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun simon_128_192_encrypt_iterate :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"simon_128_192_encrypt_iterate st [] = st\" \n| \"simon_128_192_encrypt_iterate st (k#ks) = simon_128_192_encrypt_iterate (simon_128_192_encrypt_round k st) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.140267", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/192) Decrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 69 Feistel rounds in encryption/decryption.", "input": "def simon_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply Simon Feistel rounds for decryption (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    new_x, new_y = simon_decrypt_round(\n        x, y, k,\n        64,\n        (1 << 64) - 1\n    )\n    \n    # Recursive call for previous round\n    return simon_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun simon_128_192_decrypt_iterate :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"simon_128_192_decrypt_iterate st ks = foldl (λst_new k. simon_128_192_decrypt_round_inverse k st_new) st (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.140312", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/192) Encrypt Block from Python to Isabelle/HOL. Note: SIMON processes 128-bit blocks as two 64-bit halves.", "input": "def simon_encrypt_block(plaintext, key_schedule):\n    \"\"\"SIMON block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 64\n    mask = (1 << 64) - 1\n    left = (plaintext >> 64) & (1 << 64) - 1\n    right = plaintext & (1 << 64) - 1\n    \n    # Apply all rounds\n    cipher_left, cipher_right = simon_encrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (cipher_left << 64) | cipher_right", "output": "definition simon_128_192_encrypt_block ::\n  \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n\"simon_128_192_encrypt_block state keys =\n   simon_128_192_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.140370", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/192) Decrypt Block from Python to Isabelle/HOL. Note: SIMON processes 128-bit blocks as two 64-bit halves.", "input": "def simon_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SIMON block decryption\"\"\"\n    # Split into left and right halves\n    # word_size = 64\n    mask = (1 << 64) - 1\n    left = (ciphertext >> 64) & (1 << 64) - 1\n    right = ciphertext & (1 << 64) - 1\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = simon_decrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 64) | plain_right", "output": "definition simon_128_192_decrypt_block ::\n  \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n\"simon_128_192_decrypt_block state keys =\n   simon_128_192_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.140412", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/192) Block Splitting from Python to Isabelle/HOL. Note: SIMON processes 128-bit blocks as two 64-bit halves.", "input": "def simon_split_block(block):\n    \"\"\"Split 128-bit block into two 64-bit words\"\"\"\n    mask = (1 << 64) - 1\n    left = (block >> 64) & (1 << 64) - 1\n    right = block & (1 << 64) - 1\n    return left, right", "output": "definition simon_128_192_split_block :: \"128 word ⇒ (64 word × 64 word)\" where\n  \"simon_128_192_split_block block = (\n    let left = ucast (drop_bit 64 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.140446", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/192) Block Combining from Python to Isabelle/HOL. Note: SIMON processes 128-bit blocks as two 64-bit halves.", "input": "def simon_combine_block(left, right):\n    \"\"\"Combine two 64-bit words into 128-bit block\"\"\"\n    return (left << 64) | right", "output": "definition simon_128_192_combine_block :: \"64 word × 64 word ⇒ 128 word\" where\n  \"simon_128_192_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 64 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.140469", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/192) Top-Level Encrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 69 rounds.", "input": "def simon_encrypt(plaintext, master_key):\n    \"\"\"Top-level SIMON encryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return simon_encrypt_block(plaintext, key_schedule)", "output": "definition simon_128_192_encrypt ::\n  \"128 word ⇒ 64 word list ⇒ 128 word\" where\n\"simon_128_192_encrypt plaintext keys =\n  (let left  = ucast (drop_bit 64 plaintext);\n       right = ucast plaintext;\n       (c_l, c_r) = simon_128_192_encrypt_block (left, right) keys\n   in or (push_bit 64 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.140707", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(128/192) Top-Level Decrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 69 rounds.", "input": "def simon_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SIMON decryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return simon_decrypt_block(ciphertext, key_schedule)", "output": "definition simon_128_192_decrypt ::\n  \"128 word ⇒ 64 word list ⇒ 128 word\" where\n\"simon_128_192_decrypt ciphertext keys =\n  (let left  = ucast (drop_bit 64 ciphertext);\n       right = ucast ciphertext;\n       (p_l, p_r) = simon_128_192_decrypt_block (left, right) keys\n   in or (push_bit 64 (ucast p_l)) (ucast p_r))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.140731", "variant": {"block_size": 128, "key_size": 192, "word_size": 64, "rounds": 69, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(32/64) Word Size Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 32 rounds.", "input": "# Word size in bits for SIMON(32/64)\nword_size = 16", "output": "definition simon_32_64_word_size :: nat where \"simon_32_64_word_size = 16\"", "metadata": {"component_type": "Word Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.144216", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(32/64) Rounds Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "# Number of rounds for SIMON(32/64)\nrounds = 32", "output": "definition simon_32_64_rounds :: nat where \"simon_32_64_rounds = 32\"", "metadata": {"component_type": "Rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.144809", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap"]}}
{"instruction": "Translate the SIMON(32/64) Block Size Constant from Python to Isabelle/HOL. Note: SIMON processes 32-bit blocks as two 16-bit halves.", "input": "# 32-bit block size\nblock_size = 32", "output": "definition simon_32_64_block_size :: nat where \"simon_32_64_block_size = 32\"", "metadata": {"component_type": "Block Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.145412", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(32/64) Key Size Constant from Python to Isabelle/HOL. Note: Key expansion uses 4 initial key words and Z-sequence bits.", "input": "# 64-bit key size\nkey_size = 64", "output": "definition simon_32_64_key_size :: nat where \"simon_32_64_key_size = 64\"", "metadata": {"component_type": "Key Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.146302", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(32/64) Z Index Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 32 rounds.", "input": "# Z sequence index for SIMON(32/64)\nz_index = 0", "output": "definition simon_32_64_z_index :: nat where \"simon_32_64_z_index = 0\"", "metadata": {"component_type": "Z Index Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.147243", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(32/64) M Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 32 rounds.", "input": "# Number of key words (m) for SIMON(32/64)\nm = 4", "output": "definition simon_32_64_m :: nat where \"simon_32_64_m = 4\"", "metadata": {"component_type": "M Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.147921", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(32/64) Z Sequence Constant from Python to Isabelle/HOL. Note: Z-sequence bits are used as round constants in SIMON key schedule.", "input": "# Simon Z sequence 0\nz0 = 0b01100111000011010100100010111110110011100001101010010001011111", "output": "definition simon_32_64_z0 :: int where\n  \"simon_32_64_z0 = 0b01100111000011010100100010111110110011100001101010010001011111\"", "metadata": {"component_type": "Z Sequence Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.148138", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(32/64) F-Function from Python to Isabelle/HOL. Note: SIMON F-function: F(x) = ((x <<< 1) & (x <<< 8)) ^ (x <<< 2) with 16-bit words.", "input": "def simon_f_function(x, word_size = 16 , mod_mask = (2 ** 16) - 1 ):\n    \"\"\"Simon F-function: ((S¹(x) & S⁸(x)) ⊕ S²(x))\"\"\"\n    # USE | for consistency with other Simon functions\n    s1_x = ((x << 1) | (x >> (16 - 1))) & (2 ** 16) - 1   # Left rotate 1\n    s8_x = ((x << 8) | (x >> (16 - 8))) & (2 ** 16) - 1   # Left rotate 8\n    s2_x = ((x << 2) | (x >> (16 - 2))) & (2 ** 16) - 1   # Left rotate 2\n    \n    return (s1_x & s8_x) ^ s2_x", "output": "definition simon_32_64_F_function :: \"16 word ⇒ 16 word\" where\n  \"simon_32_64_F_function x = xor (and (word_rotl 1 x) (word_rotl 8 x)) (word_rotl 2 x)\"", "metadata": {"component_type": "F-Function", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.148228", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_16_modulo"]}}
{"instruction": "Translate the SIMON(32/64) Encrypt Round from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_encrypt_round(k, (x, y)):\n    \"\"\"Simon encrypt round: new_x = k ⊕ F(x) ⊕ y, new_y = x\"\"\"\n    # word_size = 16\n    mask = (1 << 16) - 1\n    \n    # USE | for consistency\n    s1_x = ((x << 1) | (x >> (16 - 1))) & (1 << 16) - 1 # left rotate 1\n    s8_x = ((x << 8) | (x >> (16 - 8))) & (1 << 16) - 1 # left rotate 8\n    s2_x = ((x << 2) | (x >> (16 - 2))) & (1 << 16) - 1 # left rotate 2\n    fx = (s1_x & s8_x) ^ s2_x\n    \n    new_x = k ^ fx ^ y\n    new_y = x\n    return new_x, new_y", "output": "definition simon_32_64_encrypt_round :: \"16 word ⇒ 16 word × 16 word ⇒ 16 word × 16 word\" where\n  \"simon_32_64_encrypt_round k xy = (let (x, y) = xy in (xor (xor k (simon_32_64_F_function x)) y, x))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.148431", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_16_modulo"]}}
{"instruction": "Translate the SIMON(32/64) Decrypt Round Inverse from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_decrypt_round_inverse(k, (x, y)):\n    \"\"\"Simon decrypt round: new_y = k ⊕ F(y) ⊕ x, new_x = y\"\"\"\n    # word_size = 16\n    mask = (1 << 16) - 1\n    \n    # USE | for consistency\n    s1_y = ((y << 1) | (y >> (16 - 1))) & (1 << 16) - 1 # left rotate 1\n    s8_y = ((y << 8) | (y >> (16 - 8))) & (1 << 16) - 1 # left rotate 8\n    s2_y = ((y << 2) | (y >> (16 - 2))) & (1 << 16) - 1 # left rotate 2\n    fy = (s1_y & s8_y) ^ s2_y\n    \n    new_y = k ^ fy ^ x\n    new_x = y\n    return new_x, new_y", "output": "definition simon_32_64_decrypt_round_inverse :: \"16 word ⇒ 16 word × 16 word ⇒ 16 word × 16 word\" where\n  \"simon_32_64_decrypt_round_inverse k xy_new = (let (x_new, y_new) = xy_new in (y_new, xor (xor x_new k) (simon_32_64_F_function y_new)))\"", "metadata": {"component_type": "Decrypt Round Inverse", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.148515", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_16_modulo"]}}
{"instruction": "Translate the SIMON(32/64) Round Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "round_constant = (1 << 16) - 4 ", "output": "definition simon_32_64_rho_const :: \"16 word\" where\n  \"simon_32_64_rho_const = 0xFFFC\"", "metadata": {"component_type": "Round Constant", "difficulty": "easy", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.148588", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_16_modulo"]}}
{"instruction": "Translate the SIMON(32/64) Key Schedule Recursive from Python to Isabelle/HOL. Note: Key expansion uses 4 initial key words and Z-sequence bits.", "input": "def simon_gen_key_schedule_rec(ks, i, word_size=16):\n    \"\"\"Recursive Simon key schedule - matches Isabelle function signature\"\"\"\n    if i >= 32:\n        return ks\n    \n    mask = (1 << 16) - 1\n    \n    # Z sequence bit extraction (like bit function in Isabelle)\n    z_bit = (0b01100111000011010100100010111110110011100001101010010001011111 >> ((i - 3) % 62)) & 1\n    \n    # Right rotations (word_rotr in Isabelle)\n    # rs_3 = word_rotr 3 (ks[i-1])\n    key_idx_m1 = ks[i-1] if i > 0 else 0\n    rs_3 = ((key_idx_m1 >> 3) | (key_idx_m1 << (16 - 3))) & (1 << 16) - 1\n    \n    # rs_1 = word_rotr 1 rs_3\n    rs_1 = ((rs_3 >> 1) | (rs_3 << (16 - 1))) & (1 << 16) - 1\n    \n    # Round constant (0xFFFFFFFC for 32-bit)\n    rho_const = (1 << 16) - 1 ^ 3  \n    \n    # Compute new key: xor (xor (xor (ks[i-3]) rs_3) rs_1) (xor (if z_bit then 1 else 0) rho_const)\n    key_idx_m3 = ks[i-3] if i >= 3 else 0\n    temp1 = key_idx_m3 ^ rs_3\n    temp2 = temp1 ^ rs_1\n    z_bit_word = 1 if z_bit else 0\n    z_rho = z_bit_word ^ rho_const\n    new_k = temp2 ^ z_rho\n    \n    # Append and recurse (notice: ks is list, returns list)\n    return simon_gen_key_schedule_rec(ks + [new_k], i + 1, 16)", "output": "function simon_32_64_gen_key_schedule_rec :: \"16 word list ⇒ nat ⇒ 16 word list\" where\n  \"simon_32_64_gen_key_schedule_rec current_keys i = (\n     if i ≥ 32 then current_keys\n     else\n       let z_bit = bit simon_32_64_z0 (i - 4);\n           rs_3 = word_rotr 3 (current_keys ! (i - 1));\n           rs_1 = word_rotr 1 (rs_3);\n           new_k = xor (xor (xor (current_keys ! (i - 4)) rs_3) rs_1) \n                       (xor (if z_bit then 1 else 0) simon_32_64_rho_const)\n       in simon_32_64_gen_key_schedule_rec (current_keys @ [new_k]) (i + 1))\"\n  by pat_completeness auto\ntermination\n  apply (relation \"measure (λ(keys, i). 32 - i)\")\n  apply auto\n  done", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.148667", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_16_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(32/64) Key Schedule Wrapper from Python to Isabelle/HOL. Note: Key expansion uses 4 initial key words and Z-sequence bits.", "input": "def simon_generate_key_schedule(master_key, word_size=16):\n    \"\"\"Generate Simon round keys from master key\"\"\"\n    # Extract m key words from master key\n    ks = []\n    mask = (1 << 16) - 1\n    for i in range(4):\n        word = (master_key >> (16 * ((4 - 1) - i))) & (1 << 16) - 1\n        ks.append(word)\n    \n    # Generate remaining keys recursively\n    return simon_gen_key_schedule_rec(ks, 0)", "output": "definition simon_32_64_generate_key_schedule :: \"16 word list ⇒ 16 word list\" where\n  \"simon_32_64_generate_key_schedule initial_keys = simon_32_64_gen_key_schedule_rec initial_keys (length initial_keys)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.148733", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_16_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(32/64) Encrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 32 Feistel rounds in encryption/decryption.", "input": "def simon_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply Simon Feistel rounds for encryption\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    new_x, new_y = simon_encrypt_round(\n        x, y, k,\n        16,\n        (1 << 16) - 1\n    )\n    \n    # Recursive call for next round\n    return simon_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun simon_32_64_encrypt_iterate :: \"16 word × 16 word ⇒ 16 word list ⇒ 16 word × 16 word\" where\n  \"simon_32_64_encrypt_iterate st [] = st\"\n| \"simon_32_64_encrypt_iterate st (k#ks) = simon_32_64_encrypt_iterate (simon_32_64_encrypt_round k st) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.148812", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_16_modulo"]}}
{"instruction": "Translate the SIMON(32/64) Decrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 32 Feistel rounds in encryption/decryption.", "input": "def simon_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply Simon Feistel rounds for decryption (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    new_x, new_y = simon_decrypt_round(\n        x, y, k,\n        16,\n        (1 << 16) - 1\n    )\n    \n    # Recursive call for previous round\n    return simon_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun simon_32_64_decrypt_iterate :: \"16 word × 16 word ⇒ 16 word list ⇒ 16 word × 16 word\" where\n  \"simon_32_64_decrypt_iterate st ks = foldl (λst_new k. simon_32_64_decrypt_round_inverse k st_new) st (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.148865", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_16_modulo"]}}
{"instruction": "Translate the SIMON(32/64) Encrypt Block from Python to Isabelle/HOL. Note: SIMON processes 32-bit blocks as two 16-bit halves.", "input": "def simon_encrypt_block(plaintext, key_schedule):\n    \"\"\"SIMON block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 16\n    mask = (1 << 16) - 1\n    left = (plaintext >> 16) & (1 << 16) - 1\n    right = plaintext & (1 << 16) - 1\n    \n    # Apply all rounds\n    cipher_left, cipher_right = simon_encrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (cipher_left << 16) | cipher_right", "output": "definition simon_32_64_encrypt_block ::\n  \"16 word × 16 word ⇒ 16 word list ⇒ 16 word × 16 word\" where\n\"simon_32_64_encrypt_block state keys =\n   simon_32_64_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.148997", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_16_modulo"]}}
{"instruction": "Translate the SIMON(32/64) Decrypt Block from Python to Isabelle/HOL. Note: SIMON processes 32-bit blocks as two 16-bit halves.", "input": "def simon_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SIMON block decryption\"\"\"\n    # Split into left and right halves\n    # word_size = 16\n    mask = (1 << 16) - 1\n    left = (ciphertext >> 16) & (1 << 16) - 1\n    right = ciphertext & (1 << 16) - 1\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = simon_decrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 16) | plain_right", "output": "definition simon_32_64_decrypt_block ::\n  \"16 word × 16 word ⇒ 16 word list ⇒ 16 word × 16 word\" where\n\"simon_32_64_decrypt_block state keys =\n   simon_32_64_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.149085", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_16_modulo"]}}
{"instruction": "Translate the SIMON(32/64) Block Splitting from Python to Isabelle/HOL. Note: SIMON processes 32-bit blocks as two 16-bit halves.", "input": "def simon_split_block(block):\n    \"\"\"Split 32-bit block into two 16-bit words\"\"\"\n    mask = (1 << 16) - 1\n    left = (block >> 16) & (1 << 16) - 1\n    right = block & (1 << 16) - 1\n    return left, right", "output": "definition simon_32_64_split_block :: \"32 word ⇒ (16 word × 16 word)\" where\n  \"simon_32_64_split_block block = (\n    let left = ucast (drop_bit 16 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.149125", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_16_modulo"]}}
{"instruction": "Translate the SIMON(32/64) Block Combining from Python to Isabelle/HOL. Note: SIMON processes 32-bit blocks as two 16-bit halves.", "input": "def simon_combine_block(left, right):\n    \"\"\"Combine two 16-bit words into 32-bit block\"\"\"\n    return (left << 16) | right", "output": "definition simon_32_64_combine_block :: \"16 word × 16 word ⇒ 32 word\" where\n  \"simon_32_64_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 16 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.149157", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_16_modulo"]}}
{"instruction": "Translate the SIMON(32/64) Top-Level Encrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 32 rounds.", "input": "def simon_encrypt(plaintext, master_key):\n    \"\"\"Top-level SIMON encryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return simon_encrypt_block(plaintext, key_schedule)", "output": "definition simon_32_64_encrypt ::\n  \"32 word ⇒ 16 word list ⇒ 32 word\" where\n\"simon_32_64_encrypt plaintext keys =\n  (let left  = ucast (drop_bit 16 plaintext);\n       right = ucast plaintext;\n       (c_l, c_r) = simon_32_64_encrypt_block (left, right) keys\n   in or (push_bit 16 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.149484", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(32/64) Top-Level Decrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 32 rounds.", "input": "def simon_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SIMON decryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return simon_decrypt_block(ciphertext, key_schedule)", "output": "definition simon_32_64_decrypt ::\n  \"32 word ⇒ 16 word list ⇒ 32 word\" where\n\"simon_32_64_decrypt ciphertext keys =\n  (let left  = ucast (drop_bit 16 ciphertext);\n       right = ucast ciphertext;\n       (p_l, p_r) = simon_32_64_decrypt_block (left, right) keys\n   in or (push_bit 16 (ucast p_l)) (ucast p_r))\"\n\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.149507", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "z_index": 0, "m": 4, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(96/96) Word Size Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 54 rounds.", "input": "# Word size in bits for SIMON(96/96)\nword_size = 48", "output": "definition simon_96_96_word_size :: nat where \"simon_96_96_word_size = 48\"", "metadata": {"component_type": "Word Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.151496", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(96/96) Rounds Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "# Number of rounds for SIMON(96/96)\nrounds = 54", "output": "definition simon_96_96_rounds :: nat where \"simon_96_96_rounds = 54\"", "metadata": {"component_type": "Rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.152107", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap"]}}
{"instruction": "Translate the SIMON(96/96) Block Size Constant from Python to Isabelle/HOL. Note: SIMON processes 96-bit blocks as two 48-bit halves.", "input": "# 96-bit block size\nblock_size = 96", "output": "definition simon_96_96_block_size :: nat where \"simon_96_96_block_size = 96\"", "metadata": {"component_type": "Block Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.152770", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(96/96) Key Size Constant from Python to Isabelle/HOL. Note: Key expansion uses 2 initial key words and Z-sequence bits.", "input": "# 96-bit key size\nkey_size = 96", "output": "definition simon_96_96_key_size :: nat where \"simon_96_96_key_size = 96\"", "metadata": {"component_type": "Key Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.153567", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(96/96) Z Index Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 54 rounds.", "input": "# Z sequence index for SIMON(96/96)\nz_index = 2", "output": "definition simon_96_96_z_index :: nat where \"simon_96_96_z_index = 2\"", "metadata": {"component_type": "Z Index Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.154175", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(96/96) M Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 54 rounds.", "input": "# Number of key words (m) for SIMON(96/96)\nm = 2", "output": "definition simon_96_96_m :: nat where \"simon_96_96_m = 2\"", "metadata": {"component_type": "M Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.154754", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(96/96) Z Sequence Constant from Python to Isabelle/HOL. Note: Z-sequence bits are used as round constants in SIMON key schedule.", "input": "# Simon Z sequence 2\nz2 = 0b11001101101001111110001000010100011001001011000000111011110101", "output": "definition simon_96_96_z2 :: int where \"simon_96_96_z2 = 0b11001101101001111110001000010100011001001011000000111011110101\"", "metadata": {"component_type": "Z Sequence Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.154947", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(96/96) F-Function from Python to Isabelle/HOL. Note: SIMON F-function: F(x) = ((x <<< 1) & (x <<< 8)) ^ (x <<< 2) with 48-bit words.", "input": "def simon_f_function(x, word_size = 48 , mod_mask = (2 ** 48) - 1 ):\n    \"\"\"Simon F-function: ((S¹(x) & S⁸(x)) ⊕ S²(x))\"\"\"\n    # USE | for consistency with other Simon functions\n    s1_x = ((x << 1) | (x >> (48 - 1))) & (2 ** 48) - 1   # Left rotate 1\n    s8_x = ((x << 8) | (x >> (48 - 8))) & (2 ** 48) - 1   # Left rotate 8\n    s2_x = ((x << 2) | (x >> (48 - 2))) & (2 ** 48) - 1   # Left rotate 2\n    \n    return (s1_x & s8_x) ^ s2_x", "output": "definition simon_96_96_F_function :: \"48 word ⇒ 48 word\" where\n  \"simon_96_96_F_function x = xor (and (word_rotl 1 x) (word_rotl 8 x)) (word_rotl 2 x)\"", "metadata": {"component_type": "F-Function", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.155025", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/96) Encrypt Round from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_encrypt_round(k, (x, y)):\n    \"\"\"Simon encrypt round: new_x = k ⊕ F(x) ⊕ y, new_y = x\"\"\"\n    # word_size = 48\n    mask = (1 << 48) - 1\n    \n    # USE | for consistency\n    s1_x = ((x << 1) | (x >> (48 - 1))) & (1 << 48) - 1 # left rotate 1\n    s8_x = ((x << 8) | (x >> (48 - 8))) & (1 << 48) - 1 # left rotate 8\n    s2_x = ((x << 2) | (x >> (48 - 2))) & (1 << 48) - 1 # left rotate 2\n    fx = (s1_x & s8_x) ^ s2_x\n    \n    new_x = k ^ fx ^ y\n    new_y = x\n    return new_x, new_y", "output": "definition simon_96_96_encrypt_round :: \"48 word ⇒ 48 word × 48 word ⇒ 48 word × 48 word\" where\n  \"simon_96_96_encrypt_round k xy = (let (x, y) = xy in (xor (xor k (simon_96_96_F_function x)) y, x))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.155077", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/96) Decrypt Round Inverse from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_decrypt_round_inverse(k, (x, y)):\n    \"\"\"Simon decrypt round: new_y = k ⊕ F(y) ⊕ x, new_x = y\"\"\"\n    # word_size = 48\n    mask = (1 << 48) - 1\n    \n    # USE | for consistency\n    s1_y = ((y << 1) | (y >> (48 - 1))) & (1 << 48) - 1 # left rotate 1\n    s8_y = ((y << 8) | (y >> (48 - 8))) & (1 << 48) - 1 # left rotate 8\n    s2_y = ((y << 2) | (y >> (48 - 2))) & (1 << 48) - 1 # left rotate 2\n    fy = (s1_y & s8_y) ^ s2_y\n    \n    new_y = k ^ fy ^ x\n    new_x = y\n    return new_x, new_y", "output": "definition simon_96_96_decrypt_round_inverse :: \"48 word ⇒ 48 word × 48 word ⇒ 48 word × 48 word\" where\n  \"simon_96_96_decrypt_round_inverse k xy_new = (let (x_new, y_new) = xy_new in (y_new, xor (xor x_new k) (simon_96_96_F_function y_new)))\"", "metadata": {"component_type": "Decrypt Round Inverse", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.155168", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/96) Round Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "round_constant = (1 << 48) - 4 ", "output": "definition simon_96_96_rho_const :: \"48 word\" where\n  \"simon_96_96_rho_const = 0xFFFFFFFFFFFFC\"", "metadata": {"component_type": "Round Constant", "difficulty": "easy", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.155316", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/96) Key Schedule Recursive from Python to Isabelle/HOL. Note: Key expansion uses 2 initial key words and Z-sequence bits.", "input": "def simon_gen_key_schedule_rec(ks, i, word_size=48):\n    \"\"\"Recursive Simon key schedule - matches Isabelle function signature\"\"\"\n    if i >= 54:\n        return ks\n    \n    mask = (1 << 48) - 1\n    \n    # Z sequence bit extraction (like bit function in Isabelle)\n    z_bit = (0b11001101101001111110001000010100011001001011000000111011110101 >> ((i - 3) % 62)) & 1\n    \n    # Right rotations (word_rotr in Isabelle)\n    # rs_3 = word_rotr 3 (ks[i-1])\n    key_idx_m1 = ks[i-1] if i > 0 else 0\n    rs_3 = ((key_idx_m1 >> 3) | (key_idx_m1 << (48 - 3))) & (1 << 48) - 1\n    \n    # rs_1 = word_rotr 1 rs_3\n    rs_1 = ((rs_3 >> 1) | (rs_3 << (48 - 1))) & (1 << 48) - 1\n    \n    # Round constant (0xFFFFFFFC for 32-bit)\n    rho_const = (1 << 48) - 1 ^ 3  \n    \n    # Compute new key: xor (xor (xor (ks[i-3]) rs_3) rs_1) (xor (if z_bit then 1 else 0) rho_const)\n    key_idx_m3 = ks[i-3] if i >= 3 else 0\n    temp1 = key_idx_m3 ^ rs_3\n    temp2 = temp1 ^ rs_1\n    z_bit_word = 1 if z_bit else 0\n    z_rho = z_bit_word ^ rho_const\n    new_k = temp2 ^ z_rho\n    \n    # Append and recurse (notice: ks is list, returns list)\n    return simon_gen_key_schedule_rec(ks + [new_k], i + 1, 48)", "output": "function simon_96_96_gen_key_schedule_rec :: \"48 word list ⇒ nat ⇒ 48 word list\" where\n  \"simon_96_96_gen_key_schedule_rec ks i = (if i ≥ 52 then ks else\n    let z_bit = bit simon_96_96_z2 (i - 2);\n        rs_3 = word_rotr 3 (ks ! (i-1)); rs_1 = word_rotr 1 rs_3;\n        new_k = xor (xor (xor (ks ! (i-2)) rs_3) rs_1) (xor (if z_bit then 1 else 0) simon_96_96_rho_const )\n    in simon_96_96_gen_key_schedule_rec (ks @ [new_k]) (i+1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(ks, i). 52 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.155392", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(96/96) Key Schedule Wrapper from Python to Isabelle/HOL. Note: Key expansion uses 2 initial key words and Z-sequence bits.", "input": "def simon_generate_key_schedule(master_key, word_size=48):\n    \"\"\"Generate Simon round keys from master key\"\"\"\n    # Extract m key words from master key\n    ks = []\n    mask = (1 << 48) - 1\n    for i in range(2):\n        word = (master_key >> (48 * ((2 - 1) - i))) & (1 << 48) - 1\n        ks.append(word)\n    \n    # Generate remaining keys recursively\n    return simon_gen_key_schedule_rec(ks, 0)", "output": "definition simon_96_96_generate_key_schedule :: \"48 word list ⇒ 48 word list\" where\n  \"simon_96_96_generate_key_schedule init = simon_96_96_gen_key_schedule_rec init (length init)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.155452", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(96/96) Encrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 54 Feistel rounds in encryption/decryption.", "input": "def simon_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply Simon Feistel rounds for encryption\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    new_x, new_y = simon_encrypt_round(\n        x, y, k,\n        48,\n        (1 << 48) - 1\n    )\n    \n    # Recursive call for next round\n    return simon_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun simon_96_96_encrypt_iterate :: \"48 word × 48 word ⇒ 48 word list ⇒ 48 word × 48 word\" where\n  \"simon_96_96_encrypt_iterate st [] = st\" | \"simon_96_96_encrypt_iterate st (k#ks) = simon_96_96_encrypt_iterate (simon_96_96_encrypt_round k st) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.155565", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/96) Decrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 54 Feistel rounds in encryption/decryption.", "input": "def simon_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply Simon Feistel rounds for decryption (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    new_x, new_y = simon_decrypt_round(\n        x, y, k,\n        48,\n        (1 << 48) - 1\n    )\n    \n    # Recursive call for previous round\n    return simon_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun simon_96_96_decrypt_iterate :: \"48 word × 48 word ⇒ 48 word list ⇒ 48 word × 48 word\" where\n  \"simon_96_96_decrypt_iterate st ks = foldl (λst_new k. simon_96_96_decrypt_round_inverse k st_new) st (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.155614", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/96) Encrypt Block from Python to Isabelle/HOL. Note: SIMON processes 96-bit blocks as two 48-bit halves.", "input": "def simon_encrypt_block(plaintext, key_schedule):\n    \"\"\"SIMON block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 48\n    mask = (1 << 48) - 1\n    left = (plaintext >> 48) & (1 << 48) - 1\n    right = plaintext & (1 << 48) - 1\n    \n    # Apply all rounds\n    cipher_left, cipher_right = simon_encrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (cipher_left << 48) | cipher_right", "output": "definition simon_96_96_encrypt_block ::\n  \"48 word × 48 word ⇒ 48 word list ⇒ 48 word × 48 word\" where\n\"simon_96_96_encrypt_block state keys =\n   simon_96_96_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.155670", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/96) Decrypt Block from Python to Isabelle/HOL. Note: SIMON processes 96-bit blocks as two 48-bit halves.", "input": "def simon_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SIMON block decryption\"\"\"\n    # Split into left and right halves\n    # word_size = 48\n    mask = (1 << 48) - 1\n    left = (ciphertext >> 48) & (1 << 48) - 1\n    right = ciphertext & (1 << 48) - 1\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = simon_decrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 48) | plain_right", "output": "definition simon_96_96_decrypt_block ::\n  \"48 word × 48 word ⇒ 48 word list ⇒ 48 word × 48 word\" where\n\"simon_96_96_decrypt_block state keys =\n   simon_96_96_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.155712", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/96) Block Splitting from Python to Isabelle/HOL. Note: SIMON processes 96-bit blocks as two 48-bit halves.", "input": "def simon_split_block(block):\n    \"\"\"Split 96-bit block into two 48-bit words\"\"\"\n    mask = (1 << 48) - 1\n    left = (block >> 48) & (1 << 48) - 1\n    right = block & (1 << 48) - 1\n    return left, right", "output": "definition simon_96_96_split_block :: \"96 word ⇒ (48 word × 48 word)\" where\n  \"simon_96_96_split_block block = (\n    let left = ucast (drop_bit 48 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.155846", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/96) Block Combining from Python to Isabelle/HOL. Note: SIMON processes 96-bit blocks as two 48-bit halves.", "input": "def simon_combine_block(left, right):\n    \"\"\"Combine two 48-bit words into 96-bit block\"\"\"\n    return (left << 48) | right", "output": "definition simon_96_96_combine_block :: \"48 word × 48 word ⇒ 96 word\" where\n  \"simon_96_96_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 48 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.155877", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/96) Top-Level Encrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 54 rounds.", "input": "def simon_encrypt(plaintext, master_key):\n    \"\"\"Top-level SIMON encryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return simon_encrypt_block(plaintext, key_schedule)", "output": "definition simon_96_96_encrypt ::\n  \"96 word ⇒ 48 word list ⇒ 96 word\" where\n\"simon_96_96_encrypt plaintext keys =\n  (let left  = ucast (drop_bit 48 plaintext);\n       right = ucast plaintext;\n       (c_l, c_r) = simon_96_96_encrypt_block (left, right) keys\n   in or (push_bit 48 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.156116", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(96/96) Top-Level Decrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 54 rounds.", "input": "def simon_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SIMON decryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return simon_decrypt_block(ciphertext, key_schedule)", "output": "definition simon_96_96_decrypt ::\n  \"96 word ⇒ 48 word list ⇒ 96 word\" where\n\"simon_96_96_decrypt ciphertext keys =\n  (let left  = ucast (drop_bit 48 ciphertext);\n       right = ucast ciphertext;\n       (p_l, p_r) = simon_96_96_decrypt_block (left, right) keys\n   in or (push_bit 48 (ucast p_l)) (ucast p_r))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.156139", "variant": {"block_size": 96, "key_size": 96, "word_size": 48, "rounds": 54, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(48/72) Word Size Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 36 rounds.", "input": "# Word size in bits for SIMON(48/72)\nword_size = 24", "output": "definition simon_48_72_word_size :: nat where \"simon_48_72_word_size = 24\"", "metadata": {"component_type": "Word Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.159532", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(48/72) Rounds Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "# Number of rounds for SIMON(48/72)\nrounds = 36", "output": "definition simon_48_72_rounds :: nat where \"simon_48_72_rounds = 36\"", "metadata": {"component_type": "Rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.160255", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap"]}}
{"instruction": "Translate the SIMON(48/72) Block Size Constant from Python to Isabelle/HOL. Note: SIMON processes 48-bit blocks as two 24-bit halves.", "input": "# 48-bit block size\nblock_size = 48", "output": "definition simon_48_72_block_size :: nat where \"simon_48_72_block_size = 48\"", "metadata": {"component_type": "Block Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.160946", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(48/72) Key Size Constant from Python to Isabelle/HOL. Note: Key expansion uses 3 initial key words and Z-sequence bits.", "input": "# 72-bit key size\nkey_size = 72", "output": "definition simon_48_72_key_size :: nat where \"simon_48_72_key_size = 72\"", "metadata": {"component_type": "Key Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.161713", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(48/72) Z Index Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 36 rounds.", "input": "# Z sequence index for SIMON(48/72)\nz_index = 0", "output": "definition simon_48_72_z_index :: nat where \"simon_48_72_z_index = 0\"", "metadata": {"component_type": "Z Index Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.162375", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(48/72) M Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 36 rounds.", "input": "# Number of key words (m) for SIMON(48/72)\nm = 3", "output": "definition simon_48_72_m :: nat where \"simon_48_72_m = 3\"", "metadata": {"component_type": "M Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.163092", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(48/72) Z Sequence Constant from Python to Isabelle/HOL. Note: Z-sequence bits are used as round constants in SIMON key schedule.", "input": "# Simon Z sequence 0\nz0 = 0b01100111000011010100100010111110110011100001101010010001011111", "output": "definition simon_48_72_z0 :: int where \"simon_48_72_z0 = 0b01100111000011010100100010111110110011100001101010010001011111\"", "metadata": {"component_type": "Z Sequence Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.163339", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(48/72) F-Function from Python to Isabelle/HOL. Note: SIMON F-function: F(x) = ((x <<< 1) & (x <<< 8)) ^ (x <<< 2) with 24-bit words.", "input": "def simon_f_function(x, word_size = 24 , mod_mask = (2 ** 24) - 1 ):\n    \"\"\"Simon F-function: ((S¹(x) & S⁸(x)) ⊕ S²(x))\"\"\"\n    # USE | for consistency with other Simon functions\n    s1_x = ((x << 1) | (x >> (24 - 1))) & (2 ** 24) - 1   # Left rotate 1\n    s8_x = ((x << 8) | (x >> (24 - 8))) & (2 ** 24) - 1   # Left rotate 8\n    s2_x = ((x << 2) | (x >> (24 - 2))) & (2 ** 24) - 1   # Left rotate 2\n    \n    return (s1_x & s8_x) ^ s2_x", "output": "definition simon_48_72_F_function :: \"24 word ⇒ 24 word\" where\n  \"simon_48_72_F_function x = xor (and (word_rotl 1 x) (word_rotl 8 x)) (word_rotl 2 x)\"", "metadata": {"component_type": "F-Function", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.163414", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/72) Encrypt Round from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_encrypt_round(k, (x, y)):\n    \"\"\"Simon encrypt round: new_x = k ⊕ F(x) ⊕ y, new_y = x\"\"\"\n    # word_size = 24\n    mask = (1 << 24) - 1\n    \n    # USE | for consistency\n    s1_x = ((x << 1) | (x >> (24 - 1))) & (1 << 24) - 1 # left rotate 1\n    s8_x = ((x << 8) | (x >> (24 - 8))) & (1 << 24) - 1 # left rotate 8\n    s2_x = ((x << 2) | (x >> (24 - 2))) & (1 << 24) - 1 # left rotate 2\n    fx = (s1_x & s8_x) ^ s2_x\n    \n    new_x = k ^ fx ^ y\n    new_y = x\n    return new_x, new_y", "output": "definition simon_48_72_encrypt_round :: \"24 word ⇒ 24 word × 24 word ⇒ 24 word × 24 word\" where\n  \"simon_48_72_encrypt_round k xy = (let (x, y) = xy in (xor (xor k (simon_48_72_F_function x)) y, x))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.163471", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/72) Decrypt Round Inverse from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_decrypt_round_inverse(k, (x, y)):\n    \"\"\"Simon decrypt round: new_y = k ⊕ F(y) ⊕ x, new_x = y\"\"\"\n    # word_size = 24\n    mask = (1 << 24) - 1\n    \n    # USE | for consistency\n    s1_y = ((y << 1) | (y >> (24 - 1))) & (1 << 24) - 1 # left rotate 1\n    s8_y = ((y << 8) | (y >> (24 - 8))) & (1 << 24) - 1 # left rotate 8\n    s2_y = ((y << 2) | (y >> (24 - 2))) & (1 << 24) - 1 # left rotate 2\n    fy = (s1_y & s8_y) ^ s2_y\n    \n    new_y = k ^ fy ^ x\n    new_x = y\n    return new_x, new_y", "output": "definition simon_48_72_decrypt_round_inverse :: \"24 word ⇒ 24 word × 24 word ⇒ 24 word × 24 word\" where\n  \"simon_48_72_decrypt_round_inverse k xy_new = (let (x_new, y_new) = xy_new in (y_new, xor (xor x_new k) (simon_48_72_F_function y_new)))\"", "metadata": {"component_type": "Decrypt Round Inverse", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.164360", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/72) Round Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "round_constant = (1 << 24) - 4 ", "output": "definition simon_48_72_rho_const :: \"24 word\" where\n  \"simon_48_72_rho_const = 0xFFFFFC\"", "metadata": {"component_type": "Round Constant", "difficulty": "easy", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.165822", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/72) Key Schedule Recursive from Python to Isabelle/HOL. Note: Key expansion uses 3 initial key words and Z-sequence bits.", "input": "def simon_gen_key_schedule_rec(ks, i, word_size=24):\n    \"\"\"Recursive Simon key schedule - matches Isabelle function signature\"\"\"\n    if i >= 36:\n        return ks\n    \n    mask = (1 << 24) - 1\n    \n    # Z sequence bit extraction (like bit function in Isabelle)\n    z_bit = (0b01100111000011010100100010111110110011100001101010010001011111 >> ((i - 3) % 62)) & 1\n    \n    # Right rotations (word_rotr in Isabelle)\n    # rs_3 = word_rotr 3 (ks[i-1])\n    key_idx_m1 = ks[i-1] if i > 0 else 0\n    rs_3 = ((key_idx_m1 >> 3) | (key_idx_m1 << (24 - 3))) & (1 << 24) - 1\n    \n    # rs_1 = word_rotr 1 rs_3\n    rs_1 = ((rs_3 >> 1) | (rs_3 << (24 - 1))) & (1 << 24) - 1\n    \n    # Round constant (0xFFFFFFFC for 32-bit)\n    rho_const = (1 << 24) - 1 ^ 3  \n    \n    # Compute new key: xor (xor (xor (ks[i-3]) rs_3) rs_1) (xor (if z_bit then 1 else 0) rho_const)\n    key_idx_m3 = ks[i-3] if i >= 3 else 0\n    temp1 = key_idx_m3 ^ rs_3\n    temp2 = temp1 ^ rs_1\n    z_bit_word = 1 if z_bit else 0\n    z_rho = z_bit_word ^ rho_const\n    new_k = temp2 ^ z_rho\n    \n    # Append and recurse (notice: ks is list, returns list)\n    return simon_gen_key_schedule_rec(ks + [new_k], i + 1, 24)", "output": "function simon_48_72_gen_key_schedule_rec :: \"24 word list ⇒ nat ⇒ 24 word list\" where\n  \"simon_48_72_gen_key_schedule_rec ks i = (if i ≥ 36 then ks else\n    let z_bit = bit simon_48_72_z0 (i - 3);\n        rs_3 = word_rotr 3 (ks ! (i-1)); rs_1 = word_rotr 1 rs_3;\n        new_k = xor (xor (xor (ks ! (i-3)) rs_3) rs_1) (xor (if z_bit then 1 else 0) simon_48_72_rho_const )\n    in simon_48_72_gen_key_schedule_rec (ks @ [new_k]) (i+1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(ks, i). 36 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.165945", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(48/72) Key Schedule Wrapper from Python to Isabelle/HOL. Note: Key expansion uses 3 initial key words and Z-sequence bits.", "input": "def simon_generate_key_schedule(master_key, word_size=24):\n    \"\"\"Generate Simon round keys from master key\"\"\"\n    # Extract m key words from master key\n    ks = []\n    mask = (1 << 24) - 1\n    for i in range(3):\n        word = (master_key >> (24 * ((3 - 1) - i))) & (1 << 24) - 1\n        ks.append(word)\n    \n    # Generate remaining keys recursively\n    return simon_gen_key_schedule_rec(ks, 0)", "output": "definition simon_48_72_generate_key_schedule :: \"24 word list ⇒ 24 word list\" where\n  \"simon_48_72_generate_key_schedule init = simon_48_72_gen_key_schedule_rec init (length init)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.166018", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(48/72) Encrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 36 Feistel rounds in encryption/decryption.", "input": "def simon_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply Simon Feistel rounds for encryption\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    new_x, new_y = simon_encrypt_round(\n        x, y, k,\n        24,\n        (1 << 24) - 1\n    )\n    \n    # Recursive call for next round\n    return simon_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun simon_48_72_encrypt_iterate :: \"24 word × 24 word ⇒ 24 word list ⇒ 24 word × 24 word\" where\n  \"simon_48_72_encrypt_iterate st [] = st\" | \"simon_48_72_encrypt_iterate st (k#ks) = simon_48_72_encrypt_iterate (simon_48_72_encrypt_round k st) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.166108", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/72) Decrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 36 Feistel rounds in encryption/decryption.", "input": "def simon_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply Simon Feistel rounds for decryption (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    new_x, new_y = simon_decrypt_round(\n        x, y, k,\n        24,\n        (1 << 24) - 1\n    )\n    \n    # Recursive call for previous round\n    return simon_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun simon_48_72_decrypt_iterate :: \"24 word × 24 word ⇒ 24 word list ⇒ 24 word × 24 word\" where\n  \"simon_48_72_decrypt_iterate st ks = foldl (λst_new k. simon_48_72_decrypt_round_inverse k st_new) st (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.166188", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/72) Encrypt Block from Python to Isabelle/HOL. Note: SIMON processes 48-bit blocks as two 24-bit halves.", "input": "def simon_encrypt_block(plaintext, key_schedule):\n    \"\"\"SIMON block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 24\n    mask = (1 << 24) - 1\n    left = (plaintext >> 24) & (1 << 24) - 1\n    right = plaintext & (1 << 24) - 1\n    \n    # Apply all rounds\n    cipher_left, cipher_right = simon_encrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (cipher_left << 24) | cipher_right", "output": "definition simon_48_72_encrypt_block ::\n  \"24 word × 24 word ⇒ 24 word list ⇒ 24 word × 24 word\" where\n\"simon_48_72_encrypt_block state keys =\n   simon_48_72_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.166259", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/72) Decrypt Block from Python to Isabelle/HOL. Note: SIMON processes 48-bit blocks as two 24-bit halves.", "input": "def simon_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SIMON block decryption\"\"\"\n    # Split into left and right halves\n    # word_size = 24\n    mask = (1 << 24) - 1\n    left = (ciphertext >> 24) & (1 << 24) - 1\n    right = ciphertext & (1 << 24) - 1\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = simon_decrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 24) | plain_right", "output": "definition simon_48_72_decrypt_block ::\n  \"24 word × 24 word ⇒ 24 word list ⇒ 24 word × 24 word\" where\n\"simon_48_72_decrypt_block state keys =\n   simon_48_72_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.166302", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/72) Block Splitting from Python to Isabelle/HOL. Note: SIMON processes 48-bit blocks as two 24-bit halves.", "input": "def simon_split_block(block):\n    \"\"\"Split 48-bit block into two 24-bit words\"\"\"\n    mask = (1 << 24) - 1\n    left = (block >> 24) & (1 << 24) - 1\n    right = block & (1 << 24) - 1\n    return left, right", "output": "definition simon_48_72_split_block :: \"48 word ⇒ (24 word × 24 word)\" where\n  \"simon_48_72_split_block block = (\n    let left = ucast (drop_bit 24 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.166338", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/72) Block Combining from Python to Isabelle/HOL. Note: SIMON processes 48-bit blocks as two 24-bit halves.", "input": "def simon_combine_block(left, right):\n    \"\"\"Combine two 24-bit words into 48-bit block\"\"\"\n    return (left << 24) | right", "output": "definition simon_48_72_combine_block :: \"24 word × 24 word ⇒ 48 word\" where\n  \"simon_48_72_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 24 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.166367", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_24_modulo"]}}
{"instruction": "Translate the SIMON(48/72) Top-Level Encrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 36 rounds.", "input": "def simon_encrypt(plaintext, master_key):\n    \"\"\"Top-level SIMON encryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return simon_encrypt_block(plaintext, key_schedule)", "output": "definition simon_48_72_encrypt ::\n  \"48 word ⇒ 24 word list ⇒ 48 word\" where\n\"simon_48_72_encrypt plaintext keys =\n  (let left  = ucast (drop_bit 24 plaintext);\n       right = ucast plaintext;\n       (c_l, c_r) = simon_48_72_encrypt_block (left, right) keys\n   in or (push_bit 24 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.166618", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(48/72) Top-Level Decrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 36 rounds.", "input": "def simon_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SIMON decryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return simon_decrypt_block(ciphertext, key_schedule)", "output": "definition simon_48_72_decrypt ::\n  \"48 word ⇒ 24 word list ⇒ 48 word\" where\n\"simon_48_72_decrypt ciphertext keys =\n  (let left  = ucast (drop_bit 24 ciphertext);\n       right = ucast ciphertext;\n       (p_l, p_r) = simon_48_72_decrypt_block (left, right) keys\n   in or (push_bit 24 (ucast p_l)) (ucast p_r))\"\n\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.166641", "variant": {"block_size": 48, "key_size": 72, "word_size": 24, "rounds": 36, "z_index": 0, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 0 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(64/128) Word Size Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 44 rounds.", "input": "# Word size in bits for SIMON(64/128)\nword_size = 32", "output": "definition simon_64_128_word_size :: nat where \"simon_64_128_word_size = 32\"", "metadata": {"component_type": "Word Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.169631", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(64/128) Rounds Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "# Number of rounds for SIMON(64/128)\nrounds = 44", "output": "definition simon_64_128_rounds :: nat where \"simon_64_128_rounds = 44\"", "metadata": {"component_type": "Rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.170274", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap"]}}
{"instruction": "Translate the SIMON(64/128) Block Size Constant from Python to Isabelle/HOL. Note: SIMON processes 64-bit blocks as two 32-bit halves.", "input": "# 64-bit block size\nblock_size = 64", "output": "definition simon_64_128_block_size :: nat where \"simon_64_128_block_size = 64\"", "metadata": {"component_type": "Block Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.171148", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(64/128) Key Size Constant from Python to Isabelle/HOL. Note: Key expansion uses 3 initial key words and Z-sequence bits.", "input": "# 128-bit key size\nkey_size = 128", "output": "definition simon_64_128_key_size :: nat where \"simon_64_128_key_size = 128\"", "metadata": {"component_type": "Key Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.172165", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(64/128) Z Index Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 44 rounds.", "input": "# Z sequence index for SIMON(64/128)\nz_index = 2", "output": "definition simon_64_128_z_index :: nat where \"simon_64_128_z_index = 2\"", "metadata": {"component_type": "Z Index Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.173142", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(64/128) M Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 44 rounds.", "input": "# Number of key words (m) for SIMON(64/128)\nm = 3", "output": "definition simon_64_128_m :: nat where \"simon_64_128_m = 3\"", "metadata": {"component_type": "M Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.174166", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(64/128) Z Sequence Constant from Python to Isabelle/HOL. Note: Z-sequence bits are used as round constants in SIMON key schedule.", "input": "# Simon Z sequence 2\nz2 = 0b11001101101001111110001000010100011001001011000000111011110101", "output": "definition simon_64_128_z2 :: nat where \"simon_64_128_z2 = 0b11001101101001111110001000010100011001001011000000111011110101\"", "metadata": {"component_type": "Z Sequence Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.175177", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(64/128) F-Function from Python to Isabelle/HOL. Note: SIMON F-function: F(x) = ((x <<< 1) & (x <<< 8)) ^ (x <<< 2) with 32-bit words.", "input": "def simon_f_function(x, word_size = 32 , mod_mask = (2 ** 32) - 1 ):\n    \"\"\"Simon F-function: ((S¹(x) & S⁸(x)) ⊕ S²(x))\"\"\"\n    # USE | for consistency with other Simon functions\n    s1_x = ((x << 1) | (x >> (32 - 1))) & (2 ** 32) - 1   # Left rotate 1\n    s8_x = ((x << 8) | (x >> (32 - 8))) & (2 ** 32) - 1   # Left rotate 8\n    s2_x = ((x << 2) | (x >> (32 - 2))) & (2 ** 32) - 1   # Left rotate 2\n    \n    return (s1_x & s8_x) ^ s2_x", "output": "definition simon_64_128_F_function :: \"32 word ⇒ 32 word\" where\n  \"simon_64_128_F_function x = xor (and (word_rotl 1 x) (word_rotl 8 x)) (word_rotl 2 x)\"", "metadata": {"component_type": "F-Function", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.175304", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/128) Encrypt Round from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_encrypt_round(k, (x, y)):\n    \"\"\"Simon encrypt round: new_x = k ⊕ F(x) ⊕ y, new_y = x\"\"\"\n    # word_size = 32\n    mask = (1 << 32) - 1\n    \n    # USE | for consistency\n    s1_x = ((x << 1) | (x >> (32 - 1))) & (1 << 32) - 1 # left rotate 1\n    s8_x = ((x << 8) | (x >> (32 - 8))) & (1 << 32) - 1 # left rotate 8\n    s2_x = ((x << 2) | (x >> (32 - 2))) & (1 << 32) - 1 # left rotate 2\n    fx = (s1_x & s8_x) ^ s2_x\n    \n    new_x = k ^ fx ^ y\n    new_y = x\n    return new_x, new_y", "output": "definition simon_64_128_encrypt_round :: \"32 word ⇒ 32 word × 32 word ⇒ 32 word × 32 word\" where\n  \"simon_64_128_encrypt_round k xy = (let (x, y) = xy in (xor (xor k (simon_64_128_F_function x)) y, x))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.175435", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/128) Decrypt Round Inverse from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_decrypt_round_inverse(k, (x, y)):\n    \"\"\"Simon decrypt round: new_y = k ⊕ F(y) ⊕ x, new_x = y\"\"\"\n    # word_size = 32\n    mask = (1 << 32) - 1\n    \n    # USE | for consistency\n    s1_y = ((y << 1) | (y >> (32 - 1))) & (1 << 32) - 1 # left rotate 1\n    s8_y = ((y << 8) | (y >> (32 - 8))) & (1 << 32) - 1 # left rotate 8\n    s2_y = ((y << 2) | (y >> (32 - 2))) & (1 << 32) - 1 # left rotate 2\n    fy = (s1_y & s8_y) ^ s2_y\n    \n    new_y = k ^ fy ^ x\n    new_x = y\n    return new_x, new_y", "output": "definition simon_64_128_decrypt_round_inverse :: \"32 word ⇒ 32 word × 32 word ⇒ 32 word × 32 word\" where\n  \"simon_64_128_decrypt_round_inverse k xy_new = (let (x_new, y_new) = xy_new in (y_new, xor (xor x_new k) (simon_64_128_F_function y_new)))\"", "metadata": {"component_type": "Decrypt Round Inverse", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.175531", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/128) Round Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "round_constant = (1 << 32) - 4 ", "output": "definition simon_64_128_rho_const :: \"32 word\" where\n  \"simon_64_128_rho_const = 0xFFFFFFFC\"", "metadata": {"component_type": "Round Constant", "difficulty": "easy", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.175593", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/128) Key Schedule Recursive from Python to Isabelle/HOL. Note: Key expansion uses 3 initial key words and Z-sequence bits.", "input": "def simon_gen_key_schedule_rec(ks, i, word_size=32):\n    \"\"\"Recursive Simon key schedule - matches Isabelle function signature\"\"\"\n    if i >= 44:\n        return ks\n    \n    mask = (1 << 32) - 1\n    \n    # Z sequence bit extraction (like bit function in Isabelle)\n    z_bit = (0b11001101101001111110001000010100011001001011000000111011110101 >> ((i - 3) % 62)) & 1\n    \n    # Right rotations (word_rotr in Isabelle)\n    # rs_3 = word_rotr 3 (ks[i-1])\n    key_idx_m1 = ks[i-1] if i > 0 else 0\n    rs_3 = ((key_idx_m1 >> 3) | (key_idx_m1 << (32 - 3))) & (1 << 32) - 1\n    \n    # rs_1 = word_rotr 1 rs_3\n    rs_1 = ((rs_3 >> 1) | (rs_3 << (32 - 1))) & (1 << 32) - 1\n    \n    # Round constant (0xFFFFFFFC for 32-bit)\n    rho_const = (1 << 32) - 1 ^ 3  \n    \n    # Compute new key: xor (xor (xor (ks[i-3]) rs_3) rs_1) (xor (if z_bit then 1 else 0) rho_const)\n    key_idx_m3 = ks[i-3] if i >= 3 else 0\n    temp1 = key_idx_m3 ^ rs_3\n    temp2 = temp1 ^ rs_1\n    z_bit_word = 1 if z_bit else 0\n    z_rho = z_bit_word ^ rho_const\n    new_k = temp2 ^ z_rho\n    \n    # Append and recurse (notice: ks is list, returns list)\n    return simon_gen_key_schedule_rec(ks + [new_k], i + 1, 32)", "output": "function simon_64_128_gen_key_schedule_rec :: \"32 word list ⇒ nat ⇒ 32 word list\" where\n  \"simon_64_128_gen_key_schedule_rec current_keys i = (\n     if i ≥ 44 then current_keys\n     else\n       let z_bit = bit simon_64_128_z3 (i - 4);\n           rs_3 = word_rotr 3 (current_keys ! (i - 1));\n           rs_1 = word_rotr 1 (rs_3);\n           new_k = xor (xor (xor (current_keys ! (i - 4)) rs_3) rs_1) \n                       (xor (if z_bit then 1 else 0) simon_64_128_rho_const)\n       in simon_64_128_gen_key_schedule_rec (current_keys @ [new_k]) (i + 1))\"\n  by pat_completeness auto\ntermination\n  apply (relation \"measure (λ(keys, i). 44 - i)\")\n  apply auto\n  done", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.175681", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(64/128) Key Schedule Wrapper from Python to Isabelle/HOL. Note: Key expansion uses 3 initial key words and Z-sequence bits.", "input": "def simon_generate_key_schedule(master_key, word_size=32):\n    \"\"\"Generate Simon round keys from master key\"\"\"\n    # Extract m key words from master key\n    ks = []\n    mask = (1 << 32) - 1\n    for i in range(3):\n        word = (master_key >> (32 * ((3 - 1) - i))) & (1 << 32) - 1\n        ks.append(word)\n    \n    # Generate remaining keys recursively\n    return simon_gen_key_schedule_rec(ks, 0)", "output": "definition simon_64_128_generate_key_schedule :: \"32 word list ⇒ 32 word list\" where\n  \"simon_64_128_generate_key_schedule initial_keys = simon_64_128_gen_key_schedule_rec initial_keys (length initial_keys)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.175744", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(64/128) Encrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 44 Feistel rounds in encryption/decryption.", "input": "def simon_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply Simon Feistel rounds for encryption\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    new_x, new_y = simon_encrypt_round(\n        x, y, k,\n        32,\n        (1 << 32) - 1\n    )\n    \n    # Recursive call for next round\n    return simon_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun simon_64_128_encrypt_iterate :: \"32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word\" where\n  \"simon_64_128_encrypt_iterate st [] = st\"\n| \"simon_64_128_encrypt_iterate st (k#ks) = simon_64_128_encrypt_iterate (simon_64_128_encrypt_round k st) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.175823", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/128) Decrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 44 Feistel rounds in encryption/decryption.", "input": "def simon_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply Simon Feistel rounds for decryption (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    new_x, new_y = simon_decrypt_round(\n        x, y, k,\n        32,\n        (1 << 32) - 1\n    )\n    \n    # Recursive call for previous round\n    return simon_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun simon_64_128_decrypt_iterate :: \"32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word\" where\n  \"simon_64_128_decrypt_iterate st ks = foldl (λst_new k. simon_64_128_decrypt_round_inverse k st_new) st (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.175947", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/128) Encrypt Block from Python to Isabelle/HOL. Note: SIMON processes 64-bit blocks as two 32-bit halves.", "input": "def simon_encrypt_block(plaintext, key_schedule):\n    \"\"\"SIMON block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 32\n    mask = (1 << 32) - 1\n    left = (plaintext >> 32) & (1 << 32) - 1\n    right = plaintext & (1 << 32) - 1\n    \n    # Apply all rounds\n    cipher_left, cipher_right = simon_encrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (cipher_left << 32) | cipher_right", "output": "definition simon_64_128_encrypt_block ::\n  \"32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word\" where\n\"simon_64_128_encrypt_block state keys =\n   simon_64_128_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.176054", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/128) Decrypt Block from Python to Isabelle/HOL. Note: SIMON processes 64-bit blocks as two 32-bit halves.", "input": "def simon_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SIMON block decryption\"\"\"\n    # Split into left and right halves\n    # word_size = 32\n    mask = (1 << 32) - 1\n    left = (ciphertext >> 32) & (1 << 32) - 1\n    right = ciphertext & (1 << 32) - 1\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = simon_decrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 32) | plain_right", "output": "definition simon_64_128_decrypt_block ::\n  \"32 word × 32 word ⇒ 32 word list ⇒ 32 word × 32 word\" where\n\"simon_64_128_decrypt_block state keys =\n   simon_64_128_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.176109", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/128) Block Splitting from Python to Isabelle/HOL. Note: SIMON processes 64-bit blocks as two 32-bit halves.", "input": "def simon_split_block(block):\n    \"\"\"Split 64-bit block into two 32-bit words\"\"\"\n    mask = (1 << 32) - 1\n    left = (block >> 32) & (1 << 32) - 1\n    right = block & (1 << 32) - 1\n    return left, right", "output": "definition simon_64_128_split_block :: \"64 word ⇒ (32 word × 32 word)\" where\n  \"simon_64_128_split_block block = (\n    let left = ucast (drop_bit 32 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.176193", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/128) Block Combining from Python to Isabelle/HOL. Note: SIMON processes 64-bit blocks as two 32-bit halves.", "input": "def simon_combine_block(left, right):\n    \"\"\"Combine two 32-bit words into 64-bit block\"\"\"\n    return (left << 32) | right", "output": "definition simon_64_128_combine_block :: \"32 word × 32 word ⇒ 64 word\" where\n  \"simon_64_128_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 32 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.176223", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_32_modulo"]}}
{"instruction": "Translate the SIMON(64/128) Top-Level Encrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 44 rounds.", "input": "def simon_encrypt(plaintext, master_key):\n    \"\"\"Top-level SIMON encryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return simon_encrypt_block(plaintext, key_schedule)", "output": "definition simon_64_128_encrypt ::\n  \"64 word ⇒ 32 word list ⇒ 64 word\" where\n\"simon_64_128_encrypt plaintext keys =\n  (let left  = ucast (drop_bit 32 plaintext);\n       right = ucast plaintext;\n       (c_l, c_r) = simon_64_128_encrypt_block (left, right) keys\n   in or (push_bit 32 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.176672", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(64/128) Top-Level Decrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 44 rounds.", "input": "def simon_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SIMON decryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return simon_decrypt_block(ciphertext, key_schedule)", "output": "definition simon_64_128_decrypt ::\n  \"64 word ⇒ 32 word list ⇒ 64 word\" where\n\"simon_64_128_decrypt ciphertext keys =\n  (let left  = ucast (drop_bit 32 ciphertext);\n       right = ucast ciphertext;\n       (p_l, p_r) = simon_64_128_decrypt_block (left, right) keys\n   in or (push_bit 32 (ucast p_l)) (ucast p_r))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.176718", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "z_index": 2, "m": 3, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(96/144) Word Size Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 52 rounds.", "input": "# Word size in bits for SIMON(96/144)\nword_size = 48", "output": "definition simon_96_144_word_size :: nat where \"simon_96_144_word_size = 48\"", "metadata": {"component_type": "Word Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.179443", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(96/144) Rounds Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "# Number of rounds for SIMON(96/144)\nrounds = 52", "output": "definition simon_96_144_rounds :: nat where \"simon_96_144_rounds = 52\"", "metadata": {"component_type": "Rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.182666", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap"]}}
{"instruction": "Translate the SIMON(96/144) Block Size Constant from Python to Isabelle/HOL. Note: SIMON processes 96-bit blocks as two 48-bit halves.", "input": "# 96-bit block size\nblock_size = 96", "output": "definition simon_96_144_block_size :: nat where \"simon_96_144_block_size = 96\"", "metadata": {"component_type": "Block Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.183950", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(96/144) Key Size Constant from Python to Isabelle/HOL. Note: Key expansion uses 2 initial key words and Z-sequence bits.", "input": "# 144-bit key size\nkey_size = 144", "output": "definition simon_96_144_key_size :: nat where \"simon_96_144_key_size = 144\"", "metadata": {"component_type": "Key Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.185146", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(96/144) Z Index Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 52 rounds.", "input": "# Z sequence index for SIMON(96/144)\nz_index = 2", "output": "definition simon_96_144_z_index :: nat where \"simon_96_144_z_index = 2\"", "metadata": {"component_type": "Z Index Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.186014", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(96/144) M Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 52 rounds.", "input": "# Number of key words (m) for SIMON(96/144)\nm = 2", "output": "definition simon_96_144_m :: nat where \"simon_96_144_m = 2\"", "metadata": {"component_type": "M Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.186727", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(96/144) Z Sequence Constant from Python to Isabelle/HOL. Note: Z-sequence bits are used as round constants in SIMON key schedule.", "input": "# Simon Z sequence 2\nz2 = 0b11001101101001111110001000010100011001001011000000111011110101", "output": "definition simon_96_144_z2 :: nat where \"simon_96_144_z2 = 0b11001101101001111110001000010100011001001011000000111011110101\"", "metadata": {"component_type": "Z Sequence Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.187567", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(96/144) F-Function from Python to Isabelle/HOL. Note: SIMON F-function: F(x) = ((x <<< 1) & (x <<< 8)) ^ (x <<< 2) with 48-bit words.", "input": "def simon_f_function(x, word_size = 48 , mod_mask = (2 ** 48) - 1 ):\n    \"\"\"Simon F-function: ((S¹(x) & S⁸(x)) ⊕ S²(x))\"\"\"\n    # USE | for consistency with other Simon functions\n    s1_x = ((x << 1) | (x >> (48 - 1))) & (2 ** 48) - 1   # Left rotate 1\n    s8_x = ((x << 8) | (x >> (48 - 8))) & (2 ** 48) - 1   # Left rotate 8\n    s2_x = ((x << 2) | (x >> (48 - 2))) & (2 ** 48) - 1   # Left rotate 2\n    \n    return (s1_x & s8_x) ^ s2_x", "output": "definition simon_96_144_F_function :: \"48 word ⇒ 48 word\" where\n  \"simon_96_144_F_function x = xor (and (word_rotl 1 x) (word_rotl 8 x)) (word_rotl 2 x)\"", "metadata": {"component_type": "F-Function", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.187670", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/144) Encrypt Round from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_encrypt_round(k, (x, y)):\n    \"\"\"Simon encrypt round: new_x = k ⊕ F(x) ⊕ y, new_y = x\"\"\"\n    # word_size = 48\n    mask = (1 << 48) - 1\n    \n    # USE | for consistency\n    s1_x = ((x << 1) | (x >> (48 - 1))) & (1 << 48) - 1 # left rotate 1\n    s8_x = ((x << 8) | (x >> (48 - 8))) & (1 << 48) - 1 # left rotate 8\n    s2_x = ((x << 2) | (x >> (48 - 2))) & (1 << 48) - 1 # left rotate 2\n    fx = (s1_x & s8_x) ^ s2_x\n    \n    new_x = k ^ fx ^ y\n    new_y = x\n    return new_x, new_y", "output": "definition simon_96_144_encrypt_round :: \"48 word ⇒ 48 word × 48 word ⇒ 48 word × 48 word\" where\n  \"simon_96_144_encrypt_round k xy = (let (x, y) = xy in (xor (xor k (simon_96_144_F_function x)) y, x))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.187724", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/144) Decrypt Round Inverse from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_decrypt_round_inverse(k, (x, y)):\n    \"\"\"Simon decrypt round: new_y = k ⊕ F(y) ⊕ x, new_x = y\"\"\"\n    # word_size = 48\n    mask = (1 << 48) - 1\n    \n    # USE | for consistency\n    s1_y = ((y << 1) | (y >> (48 - 1))) & (1 << 48) - 1 # left rotate 1\n    s8_y = ((y << 8) | (y >> (48 - 8))) & (1 << 48) - 1 # left rotate 8\n    s2_y = ((y << 2) | (y >> (48 - 2))) & (1 << 48) - 1 # left rotate 2\n    fy = (s1_y & s8_y) ^ s2_y\n    \n    new_y = k ^ fy ^ x\n    new_x = y\n    return new_x, new_y", "output": "definition simon_96_144_decrypt_round_inverse :: \"48 word ⇒ 48 word × 48 word ⇒ 48 word × 48 word\" where\n  \"simon_96_144_decrypt_round_inverse k xy_new = (let (x_new, y_new) = xy_new in (y_new, xor (xor x_new k) (simon_96_144_F_function y_new)))\"", "metadata": {"component_type": "Decrypt Round Inverse", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.187766", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/144) Round Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "round_constant = (1 << 48) - 4 ", "output": "definition simon_96_144_rho_const :: \"48 word\" where\n  \"simon_96_144_rho_const = 0xFFFFFFFFFFFC\"", "metadata": {"component_type": "Round Constant", "difficulty": "easy", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.187810", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/144) Key Schedule Recursive from Python to Isabelle/HOL. Note: Key expansion uses 2 initial key words and Z-sequence bits.", "input": "def simon_gen_key_schedule_rec(ks, i, word_size=48):\n    \"\"\"Recursive Simon key schedule - matches Isabelle function signature\"\"\"\n    if i >= 52:\n        return ks\n    \n    mask = (1 << 48) - 1\n    \n    # Z sequence bit extraction (like bit function in Isabelle)\n    z_bit = (0b11001101101001111110001000010100011001001011000000111011110101 >> ((i - 3) % 62)) & 1\n    \n    # Right rotations (word_rotr in Isabelle)\n    # rs_3 = word_rotr 3 (ks[i-1])\n    key_idx_m1 = ks[i-1] if i > 0 else 0\n    rs_3 = ((key_idx_m1 >> 3) | (key_idx_m1 << (48 - 3))) & (1 << 48) - 1\n    \n    # rs_1 = word_rotr 1 rs_3\n    rs_1 = ((rs_3 >> 1) | (rs_3 << (48 - 1))) & (1 << 48) - 1\n    \n    # Round constant (0xFFFFFFFC for 32-bit)\n    rho_const = (1 << 48) - 1 ^ 3  \n    \n    # Compute new key: xor (xor (xor (ks[i-3]) rs_3) rs_1) (xor (if z_bit then 1 else 0) rho_const)\n    key_idx_m3 = ks[i-3] if i >= 3 else 0\n    temp1 = key_idx_m3 ^ rs_3\n    temp2 = temp1 ^ rs_1\n    z_bit_word = 1 if z_bit else 0\n    z_rho = z_bit_word ^ rho_const\n    new_k = temp2 ^ z_rho\n    \n    # Append and recurse (notice: ks is list, returns list)\n    return simon_gen_key_schedule_rec(ks + [new_k], i + 1, 48)", "output": "function simon_96_144_gen_key_schedule_rec :: \"48 word list ⇒ nat ⇒ 48 word list\" where\n  \"simon_96_144_gen_key_schedule_rec ks i = (if i ≥ 54 then ks else\n    let z_bit = bit simon_96_144_z3 (i - 3);\n        rs_3 = word_rotr 3 (ks ! (i-1)); rs_1 = word_rotr 1 rs_3;\n        new_k = xor (xor (xor (ks ! (i-3)) rs_3) rs_1) (xor (if z_bit then 1 else 0) simon_96_144_rho_const)\n    in simon_96_144_gen_key_schedule_rec (ks @ [new_k]) (i+1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(ks, i). 54 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.187856", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(96/144) Key Schedule Wrapper from Python to Isabelle/HOL. Note: Key expansion uses 2 initial key words and Z-sequence bits.", "input": "def simon_generate_key_schedule(master_key, word_size=48):\n    \"\"\"Generate Simon round keys from master key\"\"\"\n    # Extract m key words from master key\n    ks = []\n    mask = (1 << 48) - 1\n    for i in range(2):\n        word = (master_key >> (48 * ((2 - 1) - i))) & (1 << 48) - 1\n        ks.append(word)\n    \n    # Generate remaining keys recursively\n    return simon_gen_key_schedule_rec(ks, 0)", "output": "definition simon_96_144_generate_key_schedule :: \"48 word list ⇒ 48 word list\" where\n  \"simon_96_144_generate_key_schedule init = simon_96_144_gen_key_schedule_rec init (length init)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.187904", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(96/144) Encrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 52 Feistel rounds in encryption/decryption.", "input": "def simon_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply Simon Feistel rounds for encryption\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    new_x, new_y = simon_encrypt_round(\n        x, y, k,\n        48,\n        (1 << 48) - 1\n    )\n    \n    # Recursive call for next round\n    return simon_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun simon_96_144_encrypt_iterate :: \"48 word × 48 word ⇒ 48 word list ⇒ 48 word × 48 word\" where\n  \"simon_96_144_encrypt_iterate st [] = st\" \n| \"simon_96_144_encrypt_iterate st (k#ks) = simon_96_144_encrypt_iterate (simon_96_144_encrypt_round k st) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.187959", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/144) Decrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 52 Feistel rounds in encryption/decryption.", "input": "def simon_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply Simon Feistel rounds for decryption (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    new_x, new_y = simon_decrypt_round(\n        x, y, k,\n        48,\n        (1 << 48) - 1\n    )\n    \n    # Recursive call for previous round\n    return simon_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun simon_96_144_decrypt_iterate :: \"48 word × 48 word ⇒ 48 word list ⇒ 48 word × 48 word\" where\n  \"simon_96_144_decrypt_iterate st ks = foldl (λst_new k. simon_96_144_decrypt_round_inverse k st_new) st (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.187999", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/144) Encrypt Block from Python to Isabelle/HOL. Note: SIMON processes 96-bit blocks as two 48-bit halves.", "input": "def simon_encrypt_block(plaintext, key_schedule):\n    \"\"\"SIMON block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 48\n    mask = (1 << 48) - 1\n    left = (plaintext >> 48) & (1 << 48) - 1\n    right = plaintext & (1 << 48) - 1\n    \n    # Apply all rounds\n    cipher_left, cipher_right = simon_encrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (cipher_left << 48) | cipher_right", "output": "definition simon_96_144_encrypt_block ::\n  \"48 word × 48 word ⇒ 48 word list ⇒ 48 word × 48 word\" where\n\"simon_96_144_encrypt_block state keys =\n   simon_96_144_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.188050", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/144) Decrypt Block from Python to Isabelle/HOL. Note: SIMON processes 96-bit blocks as two 48-bit halves.", "input": "def simon_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SIMON block decryption\"\"\"\n    # Split into left and right halves\n    # word_size = 48\n    mask = (1 << 48) - 1\n    left = (ciphertext >> 48) & (1 << 48) - 1\n    right = ciphertext & (1 << 48) - 1\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = simon_decrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 48) | plain_right", "output": "definition simon_96_144_decrypt_block ::\n  \"48 word × 48 word ⇒ 48 word list ⇒ 48 word × 48 word\" where\n\"simon_96_144_decrypt_block state keys =\n   simon_96_144_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.188090", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/144) Block Splitting from Python to Isabelle/HOL. Note: SIMON processes 96-bit blocks as two 48-bit halves.", "input": "def simon_split_block(block):\n    \"\"\"Split 96-bit block into two 48-bit words\"\"\"\n    mask = (1 << 48) - 1\n    left = (block >> 48) & (1 << 48) - 1\n    right = block & (1 << 48) - 1\n    return left, right", "output": "definition simon_96_144_split_block :: \"96 word ⇒ (48 word × 48 word)\" where\n  \"simon_96_144_split_block block = (\n    let left = ucast (drop_bit 48 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.188147", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/144) Block Combining from Python to Isabelle/HOL. Note: SIMON processes 96-bit blocks as two 48-bit halves.", "input": "def simon_combine_block(left, right):\n    \"\"\"Combine two 48-bit words into 96-bit block\"\"\"\n    return (left << 48) | right", "output": "definition simon_96_144_combine_block :: \"48 word × 48 word ⇒ 96 word\" where\n  \"simon_96_144_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 48 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.188210", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_48_modulo"]}}
{"instruction": "Translate the SIMON(96/144) Top-Level Encrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 52 rounds.", "input": "def simon_encrypt(plaintext, master_key):\n    \"\"\"Top-level SIMON encryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return simon_encrypt_block(plaintext, key_schedule)", "output": "definition simon_96_144_encrypt ::\n  \"96 word ⇒ 48 word list ⇒ 96 word\" where\n\"simon_96_144_encrypt plaintext keys =\n  (let left  = ucast (drop_bit 48 plaintext);\n       right = ucast plaintext;\n       (c_l, c_r) = simon_96_144_encrypt_block (left, right) keys\n   in or (push_bit 48 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.188741", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(96/144) Top-Level Decrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 52 rounds.", "input": "def simon_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SIMON decryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return simon_decrypt_block(ciphertext, key_schedule)", "output": "definition simon_96_144_decrypt ::\n  \"96 word ⇒ 48 word list ⇒ 96 word\" where\n\"simon_96_144_decrypt ciphertext keys =\n  (let left  = ucast (drop_bit 48 ciphertext);\n       right = ucast ciphertext;\n       (p_l, p_r) = simon_96_144_decrypt_block (left, right) keys\n   in or (push_bit 48 (ucast p_l)) (ucast p_r))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.188784", "variant": {"block_size": 96, "key_size": 144, "word_size": 48, "rounds": 52, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(128/128) Word Size Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 68 rounds.", "input": "# Word size in bits for SIMON(128/128)\nword_size = 64", "output": "definition simon_128_128_word_size :: nat where \"simon_128_128_word_size = 64\"", "metadata": {"component_type": "Word Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.190657", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(128/128) Rounds Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "# Number of rounds for SIMON(128/128)\nrounds = 68", "output": "definition simon_128_128_rounds :: nat where \"simon_128_128_rounds = 68\"", "metadata": {"component_type": "Rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.191374", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap"]}}
{"instruction": "Translate the SIMON(128/128) Block Size Constant from Python to Isabelle/HOL. Note: SIMON processes 128-bit blocks as two 64-bit halves.", "input": "# 128-bit block size\nblock_size = 128", "output": "definition simon_128_128_block_size :: nat where \"simon_128_128_block_size = 128\"", "metadata": {"component_type": "Block Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.192940", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(128/128) Key Size Constant from Python to Isabelle/HOL. Note: Key expansion uses 2 initial key words and Z-sequence bits.", "input": "# 128-bit key size\nkey_size = 128", "output": "definition simon_128_128_key_size :: nat where \"simon_128_128_key_size = 128\"", "metadata": {"component_type": "Key Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.194025", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(128/128) Z Index Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 68 rounds.", "input": "# Z sequence index for SIMON(128/128)\nz_index = 2", "output": "definition simon_128_128_z_index :: nat where \"simon_128_128_z_index = 2\"", "metadata": {"component_type": "Z Index Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.194872", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(128/128) M Constant from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 68 rounds.", "input": "# Number of key words (m) for SIMON(128/128)\nm = 2", "output": "definition simon_128_128_m :: nat where \"simon_128_128_m = 2\"", "metadata": {"component_type": "M Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.195505", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(128/128) Z Sequence Constant from Python to Isabelle/HOL. Note: Z-sequence bits are used as round constants in SIMON key schedule.", "input": "# Simon Z sequence 2\nz2 = 0b11001101101001111110001000010100011001001011000000111011110101", "output": "definition simon_128_128_z2 :: int where \"simon_128_128_z2 = 0b11001101101001111110001000010100011001001011000000111011110101\"", "metadata": {"component_type": "Z Sequence Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.195730", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["z_sequence_bit_extraction"]}}
{"instruction": "Translate the SIMON(128/128) F-Function from Python to Isabelle/HOL. Note: SIMON F-function: F(x) = ((x <<< 1) & (x <<< 8)) ^ (x <<< 2) with 64-bit words.", "input": "def simon_f_function(x, word_size = 64 , mod_mask = (2 ** 64) - 1 ):\n    \"\"\"Simon F-function: ((S¹(x) & S⁸(x)) ⊕ S²(x))\"\"\"\n    # USE | for consistency with other Simon functions\n    s1_x = ((x << 1) | (x >> (64 - 1))) & (2 ** 64) - 1   # Left rotate 1\n    s8_x = ((x << 8) | (x >> (64 - 8))) & (2 ** 64) - 1   # Left rotate 8\n    s2_x = ((x << 2) | (x >> (64 - 2))) & (2 ** 64) - 1   # Left rotate 2\n    \n    return (s1_x & s8_x) ^ s2_x", "output": "definition simon_128_128_F_function :: \"64 word ⇒ 64 word\" where\n  \"simon_128_128_F_function x = xor (and (word_rotl 1 x) (word_rotl 8 x)) (word_rotl 2 x)\"", "metadata": {"component_type": "F-Function", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.195807", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/128) Encrypt Round from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_encrypt_round(k, (x, y)):\n    \"\"\"Simon encrypt round: new_x = k ⊕ F(x) ⊕ y, new_y = x\"\"\"\n    # word_size = 64\n    mask = (1 << 64) - 1\n    \n    # USE | for consistency\n    s1_x = ((x << 1) | (x >> (64 - 1))) & (1 << 64) - 1 # left rotate 1\n    s8_x = ((x << 8) | (x >> (64 - 8))) & (1 << 64) - 1 # left rotate 8\n    s2_x = ((x << 2) | (x >> (64 - 2))) & (1 << 64) - 1 # left rotate 2\n    fx = (s1_x & s8_x) ^ s2_x\n    \n    new_x = k ^ fx ^ y\n    new_y = x\n    return new_x, new_y", "output": "definition simon_128_128_encrypt_round :: \"64 word ⇒ 64 word × 64 word ⇒ 64 word × 64 word\" where\n  \"simon_128_128_encrypt_round k xy = (let (x, y) = xy in (xor (xor k (simon_128_128_F_function x)) y, x))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.195859", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/128) Decrypt Round Inverse from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "def simon_decrypt_round_inverse(k, (x, y)):\n    \"\"\"Simon decrypt round: new_y = k ⊕ F(y) ⊕ x, new_x = y\"\"\"\n    # word_size = 64\n    mask = (1 << 64) - 1\n    \n    # USE | for consistency\n    s1_y = ((y << 1) | (y >> (64 - 1))) & (1 << 64) - 1 # left rotate 1\n    s8_y = ((y << 8) | (y >> (64 - 8))) & (1 << 64) - 1 # left rotate 8\n    s2_y = ((y << 2) | (y >> (64 - 2))) & (1 << 64) - 1 # left rotate 2\n    fy = (s1_y & s8_y) ^ s2_y\n    \n    new_y = k ^ fy ^ x\n    new_x = y\n    return new_x, new_y", "output": "definition simon_128_128_decrypt_round_inverse :: \"64 word ⇒ 64 word × 64 word ⇒ 64 word × 64 word\" where\n  \"simon_128_128_decrypt_round_inverse k xy_new = (let (x_new, y_new) = xy_new in (y_new, xor (xor x_new k) (simon_128_128_F_function y_new)))\"", "metadata": {"component_type": "Decrypt Round Inverse", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.195900", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/128) Round Constant from Python to Isabelle/HOL. Note: SIMON uses balanced Feistel network: new_left = F(left) ^ right ^ round_key, new_right = left.", "input": "round_constant = (1 << 64) - 4 ", "output": "definition simon_128_128_rho_const :: \"64 word\" where\n  \"simon_128_128_rho_const = 0xFFFFFFFFFFFFFFFC\"", "metadata": {"component_type": "Round Constant", "difficulty": "easy", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.195951", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/128) Key Schedule Recursive from Python to Isabelle/HOL. Note: Key expansion uses 2 initial key words and Z-sequence bits.", "input": "def simon_gen_key_schedule_rec(ks, i, word_size=64):\n    \"\"\"Recursive Simon key schedule - matches Isabelle function signature\"\"\"\n    if i >= 68:\n        return ks\n    \n    mask = (1 << 64) - 1\n    \n    # Z sequence bit extraction (like bit function in Isabelle)\n    z_bit = (0b11001101101001111110001000010100011001001011000000111011110101 >> ((i - 3) % 62)) & 1\n    \n    # Right rotations (word_rotr in Isabelle)\n    # rs_3 = word_rotr 3 (ks[i-1])\n    key_idx_m1 = ks[i-1] if i > 0 else 0\n    rs_3 = ((key_idx_m1 >> 3) | (key_idx_m1 << (64 - 3))) & (1 << 64) - 1\n    \n    # rs_1 = word_rotr 1 rs_3\n    rs_1 = ((rs_3 >> 1) | (rs_3 << (64 - 1))) & (1 << 64) - 1\n    \n    # Round constant (0xFFFFFFFC for 32-bit)\n    rho_const = (1 << 64) - 1 ^ 3  \n    \n    # Compute new key: xor (xor (xor (ks[i-3]) rs_3) rs_1) (xor (if z_bit then 1 else 0) rho_const)\n    key_idx_m3 = ks[i-3] if i >= 3 else 0\n    temp1 = key_idx_m3 ^ rs_3\n    temp2 = temp1 ^ rs_1\n    z_bit_word = 1 if z_bit else 0\n    z_rho = z_bit_word ^ rho_const\n    new_k = temp2 ^ z_rho\n    \n    # Append and recurse (notice: ks is list, returns list)\n    return simon_gen_key_schedule_rec(ks + [new_k], i + 1, 64)", "output": "function simon_128_128_gen_key_schedule_rec :: \"64 word list ⇒ nat ⇒ 64 word list\" where\n  \"simon_128_128_gen_key_schedule_rec ks i = (if i ≥ 68 then ks else\n    let z_bit = bit simon_128_128_z2 (i - 2);\n        rs_3 = word_rotr 3 (ks ! (i-1)); rs_1 = word_rotr 1 rs_3;\n        new_k = xor (xor (xor (ks ! (i-2)) rs_3) rs_1) (xor (if z_bit then 1 else 0) simon_128_128_rho_const)\n    in simon_128_128_gen_key_schedule_rec (ks @ [new_k]) (i+1))\"\n  by pat_completeness auto\ntermination by (relation \"measure (λ(ks, i). 68 - i)\") auto", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.196008", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(128/128) Key Schedule Wrapper from Python to Isabelle/HOL. Note: Key expansion uses 2 initial key words and Z-sequence bits.", "input": "def simon_generate_key_schedule(master_key, word_size=64):\n    \"\"\"Generate Simon round keys from master key\"\"\"\n    # Extract m key words from master key\n    ks = []\n    mask = (1 << 64) - 1\n    for i in range(2):\n        word = (master_key >> (64 * ((2 - 1) - i))) & (1 << 64) - 1\n        ks.append(word)\n    \n    # Generate remaining keys recursively\n    return simon_gen_key_schedule_rec(ks, 0)", "output": "definition simon_128_128_generate_key_schedule :: \"64 word list ⇒ 64 word list\" where\n  \"simon_128_128_generate_key_schedule init = simon_128_128_gen_key_schedule_rec init (length init)\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.196053", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo", "recursive_key_expansion", "z_sequence_integration"]}}
{"instruction": "Translate the SIMON(128/128) Encrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 68 Feistel rounds in encryption/decryption.", "input": "def simon_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply Simon Feistel rounds for encryption\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one round\n    new_x, new_y = simon_encrypt_round(\n        x, y, k,\n        64,\n        (1 << 64) - 1\n    )\n    \n    # Recursive call for next round\n    return simon_encrypt_iterate((new_x, new_y), key_schedule, round_idx + 1)", "output": "fun simon_128_128_encrypt_iterate :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"simon_128_128_encrypt_iterate st [] = st\" | \"simon_128_128_encrypt_iterate st (k#ks) = simon_128_128_encrypt_iterate (simon_128_128_encrypt_round k st) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.196108", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/128) Decrypt Iteration from Python to Isabelle/HOL. Note: SIMON applies 68 Feistel rounds in encryption/decryption.", "input": "def simon_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply Simon Feistel rounds for decryption (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    \n    if round_idx < 0:\n        return state\n    \n    x, y = state\n    k = key_schedule[round_idx]\n    \n    # Apply one inverse round\n    new_x, new_y = simon_decrypt_round(\n        x, y, k,\n        64,\n        (1 << 64) - 1\n    )\n    \n    # Recursive call for previous round\n    return simon_decrypt_iterate((new_x, new_y), key_schedule, round_idx - 1)", "output": "fun simon_128_128_decrypt_iterate :: \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n  \"simon_128_128_decrypt_iterate st ks = foldl (λst_new k. simon_128_128_decrypt_round_inverse k st_new) st (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.196149", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/128) Encrypt Block from Python to Isabelle/HOL. Note: SIMON processes 128-bit blocks as two 64-bit halves.", "input": "def simon_encrypt_block(plaintext, key_schedule):\n    \"\"\"SIMON block encryption\"\"\"\n    # Split into left and right halves\n    # word_size = 64\n    mask = (1 << 64) - 1\n    left = (plaintext >> 64) & (1 << 64) - 1\n    right = plaintext & (1 << 64) - 1\n    \n    # Apply all rounds\n    cipher_left, cipher_right = simon_encrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (cipher_left << 64) | cipher_right", "output": "definition simon_128_128_encrypt_block ::\n  \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n\"simon_128_128_encrypt_block state keys =\n   simon_128_128_encrypt_iterate state keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.196198", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/128) Decrypt Block from Python to Isabelle/HOL. Note: SIMON processes 128-bit blocks as two 64-bit halves.", "input": "def simon_decrypt_block(ciphertext, key_schedule):\n    \"\"\"SIMON block decryption\"\"\"\n    # Split into left and right halves\n    # word_size = 64\n    mask = (1 << 64) - 1\n    left = (ciphertext >> 64) & (1 << 64) - 1\n    right = ciphertext & (1 << 64) - 1\n    \n    # Apply all inverse rounds\n    plain_left, plain_right = simon_decrypt_iterate(\n        (left, right),\n        key_schedule\n    )\n    \n    # Combine back\n    return (plain_left << 64) | plain_right", "output": "definition simon_128_128_decrypt_block ::\n  \"64 word × 64 word ⇒ 64 word list ⇒ 64 word × 64 word\" where\n\"simon_128_128_decrypt_block state keys =\n   simon_128_128_decrypt_iterate state keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.196237", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/128) Block Splitting from Python to Isabelle/HOL. Note: SIMON processes 128-bit blocks as two 64-bit halves.", "input": "def simon_split_block(block):\n    \"\"\"Split 128-bit block into two 64-bit words\"\"\"\n    mask = (1 << 64) - 1\n    left = (block >> 64) & (1 << 64) - 1\n    right = block & (1 << 64) - 1\n    return left, right", "output": "definition simon_128_128_split_block :: \"128 word ⇒ (64 word × 64 word)\" where\n  \"simon_128_128_split_block block = (\n    let left = ucast (drop_bit 64 block);\n        right = ucast block\n    in (left, right))\"", "metadata": {"component_type": "Block Splitting", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.196271", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/128) Block Combining from Python to Isabelle/HOL. Note: SIMON processes 128-bit blocks as two 64-bit halves.", "input": "def simon_combine_block(left, right):\n    \"\"\"Combine two 64-bit words into 128-bit block\"\"\"\n    return (left << 64) | right", "output": "definition simon_128_128_combine_block :: \"64 word × 64 word ⇒ 128 word\" where\n  \"simon_128_128_combine_block pair = (\n    let (left, right) = pair\n    in or (push_bit 64 (ucast left)) (ucast right))\"", "metadata": {"component_type": "Block Combining", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.196294", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": ["bit_rotation", "word_size_64_modulo"]}}
{"instruction": "Translate the SIMON(128/128) Top-Level Encrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 68 rounds.", "input": "def simon_encrypt(plaintext, master_key):\n    \"\"\"Top-level SIMON encryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Encrypt block\n    return simon_encrypt_block(plaintext, key_schedule)", "output": "definition simon_128_128_encrypt ::\n  \"128 word ⇒ 64 word list ⇒ 128 word\" where\n\"simon_128_128_encrypt plaintext keys =\n  (let left  = ucast (drop_bit 64 plaintext);\n       right = ucast plaintext;\n       (c_l, c_r) = simon_128_128_encrypt_block (left, right) keys\n   in or (push_bit 64 (ucast c_l)) (ucast c_r))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.196524", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate the SIMON(128/128) Top-Level Decrypt from Python to Isabelle/HOL. Note: SIMON is a lightweight Feistel cipher with 68 rounds.", "input": "def simon_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SIMON decryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simon_generate_key_schedule(master_key)\n    \n    # Decrypt block\n    return simon_decrypt_block(ciphertext, key_schedule)", "output": "definition simon_128_128_decrypt ::\n  \"128 word ⇒ 64 word list ⇒ 128 word\" where\n\"simon_128_128_decrypt ciphertext keys =\n  (let left  = ucast (drop_bit 64 ciphertext);\n       right = ucast ciphertext;\n       (p_l, p_r) = simon_128_128_decrypt_block (left, right) keys\n   in or (push_bit 64 (ucast p_l)) (ucast p_r))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMON", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.196547", "variant": {"block_size": 128, "key_size": 128, "word_size": 64, "rounds": 68, "z_index": 2, "m": 2, "rotation_constants": [1, 8, 2], "feistel_structure": "balanced", "key_expansion": "z_sequence_based"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "((x <<< 1) & (x <<< 8)) ^ (x <<< 2)", "z_sequence_usage": "Uses Z-sequence 2 for key schedule", "operations": ["rotation", "and", "xor"]}, "transformation_patterns": []}}
{"instruction": "Translate this Cipher Constant: BLOCK_SIZE from PRESENT-64/80 Python to Isabelle/HOL. Apply: define constants with explicit type annotations. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "# Block size in bits\nBLOCK_SIZE = 64", "output": "definition present_64_80_block_size :: nat where \"present_64_80_block_size = 64\"", "metadata": {"component_type": "Cipher Constant: BLOCK_SIZE", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.216187"}}
{"instruction": "Translate this Cipher Constant: KEY_SIZE from PRESENT-64/80 Python to Isabelle/HOL. Apply: define constants with explicit type annotations. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "# Key size in bits\nKEY_SIZE = 80", "output": "definition present_64_80_key_size :: nat where \"present_64_80_key_size = 80\"", "metadata": {"component_type": "Cipher Constant: KEY_SIZE", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.216213"}}
{"instruction": "Translate this Cipher Constant: ENCRYPTION_ROUNDS from PRESENT-64/80 Python to Isabelle/HOL. Apply: use natural number definition for round count, define constants with explicit type annotations. Note: PRESENT-64/80 uses 31 SPN rounds.", "input": "# Number of SPN rounds (without final whitening)\nENCRYPTION_ROUNDS = 31", "output": "definition present_64_80_encryption_rounds :: nat where \"present_64_80_encryption_rounds = 31\"", "metadata": {"component_type": "Cipher Constant: ENCRYPTION_ROUNDS", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.216228"}}
{"instruction": "Translate this Cipher Constant: TOTAL_ROUNDS from PRESENT-64/80 Python to Isabelle/HOL. Apply: use natural number definition for round count, define constants with explicit type annotations. Note: PRESENT-64/80 uses 31 SPN rounds.", "input": "# Total operations including final whitening\nTOTAL_ROUNDS = 32", "output": "definition present_64_80_total_rounds :: nat where \"present_64_80_total_rounds = 32\"", "metadata": {"component_type": "Cipher Constant: TOTAL_ROUNDS", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.216240"}}
{"instruction": "Translate this Cipher Constant: NIBBLES_PER_BLOCK from PRESENT-64/80 Python to Isabelle/HOL. Apply: define constants with explicit type annotations. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "# Number of 4-bit nibbles in a block\nNIBBLES_PER_BLOCK = 16", "output": "definition present_64_80_nibbles_per_block :: nat where \"present_64_80_nibbles_per_block = 16\"", "metadata": {"component_type": "Cipher Constant: NIBBLES_PER_BLOCK", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.216250"}}
{"instruction": "Translate this Cipher Constant: KEY_SCHEDULE_ROUNDS from PRESENT-64/80 Python to Isabelle/HOL. Apply: use natural number definition for round count, define constants with explicit type annotations. Note: PRESENT-64/80 uses 31 SPN rounds.", "input": "# Number of round keys needed\nKEY_SCHEDULE_ROUNDS = 32", "output": "definition present_64_80_key_schedule_rounds :: nat where \"present_64_80_key_schedule_rounds = 32\"", "metadata": {"component_type": "Cipher Constant: KEY_SCHEDULE_ROUNDS", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.216263"}}
{"instruction": "Translate this S-Box Table from PRESENT-64/80 Python to Isabelle/HOL. Apply: use Isabelle list notation for tables, preserve 4-bit S-box values as hexadecimal. Note: PRESENT uses a 4-bit S-box with strong cryptographic properties.", "input": "# PRESENT S-Box (4-bit substitution)\nSBOX = [0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, \n        0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2]", "output": "definition present_64_80_sbox_table :: \"nat list\" where\n  \"present_64_80_sbox_table = \n    [0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, \n     0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2]\"", "metadata": {"component_type": "S-Box Table", "difficulty": "easy", "semantic_group": "primitives", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["table_definition"], "extraction_time": "2026-01-24T13:11:48.216978"}}
{"instruction": "Translate this Inverse S-Box Table from PRESENT-64/80 Python to Isabelle/HOL. Apply: use Isabelle list notation for tables, preserve 4-bit S-box values as hexadecimal. Note: PRESENT uses a 4-bit S-box with strong cryptographic properties.", "input": "# PRESENT Inverse S-Box\nINV_SBOX = [0x5, 0xE, 0xF, 0x8, 0xC, 0x1, 0x2, 0xD, \n        0xB, 0x4, 0x6, 0x3, 0x0, 0x7, 0x9, 0xA]", "output": "definition present_64_80_sbox_inv_table :: \"nat list\" where\n  \"present_64_80_sbox_inv_table = \n    [0x5, 0xE, 0xF, 0x8, 0xC, 0x1, 0x2, 0xD,\n     0xB, 0x4, 0x6, 0x3, 0x0, 0x7, 0x9, 0xA]\"", "metadata": {"component_type": "Inverse S-Box Table", "difficulty": "easy", "semantic_group": "primitives", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["table_definition"], "extraction_time": "2026-01-24T13:11:48.217223"}}
{"instruction": "Translate this Permutation Table from PRESENT-64/80 Python to Isabelle/HOL. Apply: use Isabelle list notation for tables, implement bit permutation using table lookup. Note: PRESENT permutation layer provides bit-level diffusion across the 64-bit state.", "input": "# PRESENT Permutation Table\nPERM = [0, 16, 32, 48, 1, 17, 33, 49, 2, 18, 34, 50, 3, 19, 35, 51,\n        4, 20, 36, 52, 5, 21, 37, 53, 6, 22, 38, 54, 7, 23, 39, 55,\n        8, 24, 40, 56, 9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,\n        12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63]", "output": "definition present_64_80_p_layer_order :: \"nat list\" where\n  \"present_64_80_p_layer_order = \n    [0, 16, 32, 48, 1, 17, 33, 49, 2, 18, 34, 50, 3, 19, 35, 51,\n     4, 20, 36, 52, 5, 21, 37, 53, 6, 22, 38, 54, 7, 23, 39, 55,\n     8, 24, 40, 56, 9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,\n     12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63]\"", "metadata": {"component_type": "Permutation Table", "difficulty": "easy", "semantic_group": "primitives", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["table_definition", "permutation_layer"], "extraction_time": "2026-01-24T13:11:48.217505"}}
{"instruction": "Translate this Core Operation: Add Round Key from PRESENT-64/80 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially, use XOR operation for key mixing. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def add_round_key(state, round_key):\n    \"\"\"Add round key via XOR (key mixing operation)\"\"\"\n    return state ^ round_key", "output": "definition present_64_80_add_round_key :: \"64 word ⇒ 64 word ⇒ 64 word\" where\n  \"present_64_80_add_round_key state round_key = xor state round_key\"", "metadata": {"component_type": "Core Operation: Add Round Key", "difficulty": "easy", "semantic_group": "core_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["bitwise_operations", "function_definition", "key_addition"], "extraction_time": "2026-01-24T13:11:48.218206"}}
{"instruction": "Translate this Core Operation: S-Box Layer from PRESENT-64/80 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially, apply 16 parallel 4-bit S-boxes, process 16 nibbles in parallel. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def sbox_layer(state):\n        \"\"\"Apply 4-bit S-Box to 16 parallel nibbles\"\"\"\n        res = 0\n        for i in range(16):\n            nibble = (state >> (4 * i)) & 0xF\n            res |= (SBOX[nibble] << (4 * i))\n        return res", "output": "definition present_64_80_sbox_layer :: \"64 word ⇒ 64 word\" where\n  \"present_64_80_sbox_layer s = \n    word_of_int (∑i < 16. \n      uint (present_64_80_sbox (word_of_int ((uint s div 2^(4*i)) mod 16))) * 2^(4*i))\"", "metadata": {"component_type": "Core Operation: S-Box Layer", "difficulty": "medium", "semantic_group": "core_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "substitution_layer"], "extraction_time": "2026-01-24T13:11:48.218675"}}
{"instruction": "Translate this Core Operation: Inverse S-Box Layer from PRESENT-64/80 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially, apply 16 parallel 4-bit S-boxes, process 16 nibbles in parallel. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def inv_sbox_layer(state):\n        \"\"\"Inverse S-box layer for decryption\"\"\"\n        res = 0\n        for i in range(16):\n            nibble = (state >> (4 * i)) & 0xF\n            res |= (INV_SBOX[nibble] << (4 * i))\n        return res", "output": "definition present_64_80_sbox_layer_inverse :: \"64 word ⇒ 64 word\" where\n  \"present_64_80_sbox_layer_inverse s = \n    word_of_int (∑i < 16. \n      uint (present_64_80_sbox_inverse (word_of_int ((uint s div 2^(4*i)) mod 16))) * 2^(4*i))\"", "metadata": {"component_type": "Core Operation: Inverse S-Box Layer", "difficulty": "medium", "semantic_group": "core_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "substitution_layer"], "extraction_time": "2026-01-24T13:11:48.219250"}}
{"instruction": "Translate this Core Operation: Permutation Layer from PRESENT-64/80 Python to Isabelle/HOL. Apply: use Isabelle list notation for tables, implement bit permutation using table lookup. Note: PRESENT permutation layer provides bit-level diffusion across the 64-bit state.", "input": "def p_layer(state):\n        \"\"\"Bit-level permutation layer\"\"\"\n        res = 0\n        for i in range(64):\n            bit = (state >> i) & 1\n            res |= (bit << PERM[i])\n        return res", "output": "definition present_64_80_p_layer :: \"64 word ⇒ 64 word\" where\n  \"present_64_80_p_layer s = \n    word_of_int (∑ i<64. \n      if bit s i then 2 ^ (present_64_80_p_layer_order ! i) else 0)\"", "metadata": {"component_type": "Core Operation: Permutation Layer", "difficulty": "medium", "semantic_group": "core_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "permutation_layer"], "extraction_time": "2026-01-24T13:11:48.219727"}}
{"instruction": "Translate this Core Operation: Inverse Permutation Layer from PRESENT-64/80 Python to Isabelle/HOL. Apply: use Isabelle list notation for tables, implement bit permutation using table lookup. Note: PRESENT permutation layer provides bit-level diffusion across the 64-bit state.", "input": "def inv_p_layer(state):\n        \"\"\"Inverse bit-level permutation layer\"\"\"\n        res = 0\n        for i in range(64):\n            bit = (state >> i) & 1\n            res |= (bit << INV_PERM[i])\n        return res", "output": "definition present_64_80_p_layer_inverse :: \"64 word ⇒ 64 word\" where\n  \"present_64_80_p_layer_inverse s = \n    word_of_int (∑ i<64. \n      if bit s i then 2 ^ (present_64_80_p_layer_inv_order ! i) else 0)\"", "metadata": {"component_type": "Core Operation: Inverse Permutation Layer", "difficulty": "medium", "semantic_group": "core_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "permutation_layer"], "extraction_time": "2026-01-24T13:11:48.220230"}}
{"instruction": "Translate this Round Function: Encrypt Round from PRESENT-64/80 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def encrypt_round(state, round_key):\n        \"\"\"Standard SPN round composition\"\"\"\n        state = add_round_key(state, round_key)\n        state = sbox_layer(state)\n        state = p_layer(state)\n        return state", "output": "definition present_64_80_encrypt_round :: \"64 word ⇒ 64 word ⇒ 64 word\" where\n  \"present_64_80_encrypt_round round_key state = \n    present_64_80_p_layer (present_64_80_sbox_layer (xor state round_key))\"", "metadata": {"component_type": "Round Function: Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition", "substitution_layer", "permutation_layer", "key_addition"], "extraction_time": "2026-01-24T13:11:48.220704"}}
{"instruction": "Translate this Round Function: Decrypt Round from PRESENT-64/80 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def decrypt_round(state, round_key):\n        \"\"\"Inverse SPN round composition\"\"\"\n        state = inv_p_layer(state)\n        state = inv_sbox_layer(state)\n        state = add_round_key(state, round_key)\n        return state", "output": "definition present_64_80_decrypt_round_inverse :: \"64 word ⇒ 64 word ⇒ 64 word\" where\n  \"present_64_80_decrypt_round_inverse round_key state = \n    xor (present_64_80_sbox_layer_inverse (present_64_80_p_layer_inverse state)) round_key\"", "metadata": {"component_type": "Round Function: Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition", "substitution_layer", "permutation_layer", "key_addition"], "extraction_time": "2026-01-24T13:11:48.221188"}}
{"instruction": "Translate this Key Extraction (80-bit variant) from PRESENT-64/80 Python to Isabelle/HOL. Apply: implement key register rotation and S-box application, use round counter for key schedule, rotate key register left by 61 bits. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def extract_round_key_80(key_state):\n        \"\"\"Extract 64-bit round key from 80-bit state (bits 16:79)\"\"\"\n        # key_extract_shift = 16\n        #mask = (1 << key_extract_shift) - 1\n        mask = (1 << 16) - 1\n        # return (key_state >> 16) & (1 << 16) - 1\n        return (key_state >> 16) & (1 << 16) - 1", "output": "definition present_64_80_extract_round_key :: \"80 word ⇒ 64 word\" where\n      \"present_64_80_extract_round_key key_state = \n        ucast (present_64_80_word_slice 16 64 key_state)\"", "metadata": {"component_type": "Key Extraction (80-bit variant)", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.221770"}}
{"instruction": "Translate this Key Update (80-bit variant) from PRESENT-64/80 Python to Isabelle/HOL. Apply: implement key register rotation and S-box application, use round counter for key schedule, rotate key register left by 61 bits. Note: PRESENT-80 key schedule rotates 80-bit register by 61 bits and applies S-box to bits 76-79.", "input": "def key_update_80(key_state, round_counter):\n        \"\"\"Update 80-bit key state (Standard)\"\"\"\n        key_state = ((key_state << 61) & ((1 << 80) - 1)) | (key_state >> 19)\n        ms_nibble = (key_state >> 76) & 0xF\n        key_state = (SBOX[ms_nibble] << 76) | (key_state & ((1 << 76) - 1))\n        key_state ^= (round_counter << 15)\n        return key_state", "output": "definition present_64_80_key_update :: \"80 word ⇒ nat ⇒ 80 word\" where\n  \"present_64_80_key_update k r_count = (\n    let k_rot = word_rotl 61 k;                    \n        sbox_in = (present_64_80_word_slice 76 4 k_rot :: 4 word); \n        sbox_out = present_64_80_sbox sbox_in;\n        k_sboxed = or (and k_rot (mask 76)) (push_bit 76 (ucast sbox_out));\n        xor_in = (present_64_80_word_slice 15 5 k_sboxed :: 5 word);  \n        xor_out = xor xor_in (of_nat r_count);\n        mask_15_19 = not (push_bit 15 (mask 5 :: 80 word));\n        k_final = or (and k_sboxed mask_15_19) (push_bit 15 (ucast xor_out))\n    in k_final)\"", "metadata": {"component_type": "Key Update (80-bit variant)", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "table_definition", "function_definition", "key_schedule"], "extraction_time": "2026-01-24T13:11:48.222192"}}
{"instruction": "Translate this Generate Round Keys (80-bit) from PRESENT-64/80 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def generate_round_keys_80(key):\n    \"\"\"Generate round keys for PRESENT-64/80\"\"\"\n    #key_size = 80\n    \n    round_keys = []\n    k_state = key\n    \n    for r in range(1, 32):  # 31 round keys\n        # Extract round key (bits 16-79)\n        round_keys.append((k_state >> 16) & ((1 << 64) - 1))\n        # Update key state\n        k_state = key_update_80(k_state, r)\n    \n    # Final whitening key\n    round_keys.append((k_state >> 16) & ((1 << 64) - 1))\n    return round_keys", "output": "definition present_64_80_generate_key_schedule :: \"80 word ⇒ 64 word list\" where\n  \"present_64_80_generate_key_schedule initial_key = \n    present_64_80_build_keys initial_key KEY_SCHEDULE_ROUNDS\"", "metadata": {"component_type": "Generate Round Keys (80-bit)", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "key_schedule"], "extraction_time": "2026-01-24T13:11:48.222661"}}
{"instruction": "Translate this Iteration: Encrypt Iterate (Recursive) from PRESENT-64/80 Python to Isabelle/HOL. Apply: convert Python for-loops to recursion, handle round iteration with explicit counter, apply rounds in correct order (1-31 with final whitening). Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def encrypt_iterate(state, round_keys):\n        \"\"\"Recursive/Iterative layer for round application\"\"\"\n        for rk in round_keys[:-1]:\n            state = encrypt_round(state, rk)\n        # Final whitening XOR\n        return state ^ round_keys[-1]", "output": "fun present_64_80_encrypt_iterate :: \"64 word ⇒ 64 word list ⇒ nat ⇒ 64 word\" where\n  \"present_64_80_encrypt_iterate state [] _ = state\"\n| \"present_64_80_encrypt_iterate state (k#ks) rounds_left = \n     (if rounds_left = 1 then xor state k \n      else present_64_80_encrypt_iterate (present_64_80_encrypt_round k state) ks (rounds_left - 1))\"", "metadata": {"component_type": "Iteration: Encrypt Iterate (Recursive)", "difficulty": "medium", "semantic_group": "iteration", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "table_definition", "function_definition"], "extraction_time": "2026-01-24T13:11:48.223127"}}
{"instruction": "Translate this Iteration: Decrypt Iterate (Recursive) from PRESENT-64/80 Python to Isabelle/HOL. Apply: convert Python for-loops to recursion, handle round iteration with explicit counter, apply rounds in correct order (1-31 with final whitening). Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def decrypt_iterate(state, round_keys):\n        \"\"\"Recursive/Iterative layer for inverse round application\"\"\"\n        # Undo final whitening\n        state = state ^ round_keys[-1]\n        # Undo rounds in reverse\n        for rk in reversed(round_keys[:-1]):\n            state = decrypt_round(state, rk)\n        return state", "output": "fun present_64_80_decrypt_iterate :: \"64 word ⇒ 64 word list ⇒ nat ⇒ 64 word\" where\n  \"present_64_80_decrypt_iterate state [] _ = state\"\n| \"present_64_80_decrypt_iterate state (k#ks) rounds_left = \n     (if rounds_left = 1 then xor state k \n      else present_64_80_decrypt_iterate (present_64_80_decrypt_round_inverse k state) ks (rounds_left - 1))\"", "metadata": {"component_type": "Iteration: Decrypt Iterate (Recursive)", "difficulty": "medium", "semantic_group": "iteration", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "table_definition", "function_definition"], "extraction_time": "2026-01-24T13:11:48.223541"}}
{"instruction": "Translate this Semantic Boundary: Final Whitening from PRESENT-64/80 Python to Isabelle/HOL. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def final_whitening(state, key):\n    \"\"\"Final key addition (semantic boundary for last round)\"\"\"\n    return state ^ key", "output": "definition present_64_80_final_whitening :: \"64 word ⇒ 64 word ⇒ 64 word\" where\n  \"present_64_80_final_whitening state key = xor state key\"", "metadata": {"component_type": "Semantic Boundary: Final Whitening", "difficulty": "easy", "semantic_group": "iteration", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.223559"}}
{"instruction": "Translate this Block Encryption from PRESENT-64/80 Python to Isabelle/HOL. Apply: apply SPN structure: AddRoundKey → S-box → Permutation, handle final round without permutation layer, use generated round keys from key schedule. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def encrypt_block(plaintext, key):\n        \"\"\"Orchestration of key expansion and state transformation\"\"\"\n        round_keys = generate_round_keys(key)\n        return encrypt_iterate(plaintext, round_keys)", "output": "definition present_64_80_encrypt_block :: \"64 word ⇒ 64 word list ⇒ 64 word\" where\n  \"present_64_80_encrypt_block state keys = \n    present_64_80_encrypt_iterate state keys ENCRYPTION_ROUNDS\"", "metadata": {"component_type": "Block Encryption", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.223992"}}
{"instruction": "Translate this Block Decryption from PRESENT-64/80 Python to Isabelle/HOL. Apply: apply SPN structure: AddRoundKey → S-box → Permutation, handle final round without permutation layer, use generated round keys from key schedule. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def decrypt_block(ciphertext, key):\n        \"\"\"Orchestration of key expansion and inverse state transformation\"\"\"\n        round_keys = generate_round_keys(key)\n        return decrypt_iterate(ciphertext, round_keys)", "output": "definition present_64_80_decrypt_block :: \"64 word ⇒ 64 word list ⇒ 64 word\" where\n  \"present_64_80_decrypt_block state keys = \n    present_64_80_decrypt_iterate state (rev keys) ENCRYPTION_ROUNDS\"", "metadata": {"component_type": "Block Decryption", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.224421"}}
{"instruction": "Translate this Top-Level: Encrypt from PRESENT-64/80 Python to Isabelle/HOL. Apply: apply SPN structure: AddRoundKey → S-box → Permutation, handle final round without permutation layer, use generated round keys from key schedule. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def encrypt(plaintext, key):\n        \"\"\"Top-level encryption entry point\"\"\"\n        return encrypt_block(plaintext, key)", "output": "definition present_64_80_encrypt :: \"64 word ⇒ 80 word ⇒ 64 word\" where\n  \"present_64_80_encrypt plaintext key = (\n    let keys = present_64_80_generate_key_schedule key\n    in present_64_80_encrypt_block plaintext keys)\"", "metadata": {"component_type": "Top-Level: Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.224849"}}
{"instruction": "Translate this Top-Level: Decrypt from PRESENT-64/80 Python to Isabelle/HOL. Apply: apply SPN structure: AddRoundKey → S-box → Permutation, handle final round without permutation layer, use generated round keys from key schedule. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def decrypt(ciphertext, key):\n        \"\"\"Top-level decryption entry point\"\"\"\n        return decrypt_block(ciphertext, key)", "output": "definition present_64_80_decrypt :: \"64 word ⇒ 80 word ⇒ 64 word\" where\n  \"present_64_80_decrypt ciphertext key = (\n    let keys = present_64_80_generate_key_schedule key\n    in present_64_80_decrypt_block ciphertext keys)\"", "metadata": {"component_type": "Top-Level: Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.225267"}}
{"instruction": "Translate this Helper: Word Slice from PRESENT-64/80 Python to Isabelle/HOL. Apply: extract bit slices using shift and mask operations. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def word_slice(start, length, word):\n    \"\"\"Extract a slice of bits from a word\"\"\"\n    mask = (1 << length) - 1\n    # return (word >> start) & mask\n    return (word >> start) & (1 << length) - 1", "output": "definition present_64_80_word_slice :: \"nat ⇒ nat ⇒ 'a::len word ⇒ 'b::len word\" where\n  \"present_64_80_word_slice start len w = \n    word_of_int ((uint w div 2^start) mod 2^len)\"", "metadata": {"component_type": "Helper: Word Slice", "difficulty": "medium", "semantic_group": "helpers", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.225511"}}
{"instruction": "Translate this Helper: S-Box Function from PRESENT-64/80 Python to Isabelle/HOL. Apply: apply 4-bit S-box using table lookup. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def sbox(nibble):\n    \"\"\"Apply S-box to a 4-bit nibble\"\"\"\n    return SBOX[nibble]", "output": "definition present_64_80_sbox :: \"4 word ⇒ 4 word\" where\n  \"present_64_80_sbox x = of_nat (present_64_80_sbox_table ! unat x)\"", "metadata": {"component_type": "Helper: S-Box Function", "difficulty": "easy", "semantic_group": "helpers", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.225719"}}
{"instruction": "Translate this Helper: Inverse S-Box Function from PRESENT-64/80 Python to Isabelle/HOL. Apply: apply 4-bit S-box using table lookup. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def inv_sbox(nibble):\n    \"\"\"Apply inverse S-box to a 4-bit nibble\"\"\"\n    return INV_SBOX[nibble]", "output": "definition present_64_80_sbox_inverse :: \"4 word ⇒ 4 word\" where\n  \"present_64_80_sbox_inverse x = of_nat (present_64_80_sbox_inv_table ! unat x)\"", "metadata": {"component_type": "Helper: Inverse S-Box Function", "difficulty": "easy", "semantic_group": "helpers", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.225943"}}
{"instruction": "Translate this Helper: Recursive Key Building from PRESENT-64/80 Python to Isabelle/HOL. Apply: implement key register rotation and S-box application, use round counter for key schedule, rotate key register left by 61 bits. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def build_keys(key, n):\n    \"\"\"Recursively generate round keys\"\"\"\n    if n == 0:\n        return []\n\n    # uses key_update_80 function for key size =80\n    current_key = (key >> 16) & ((1 << 64) - 1)\n    next_key = key_update_80(key, n)\n    return [current_key] + build_keys(next_key, n - 1)", "output": "fun present_64_80_build_keys :: \"80 word ⇒ nat ⇒ 64 word list\" where\n  \"present_64_80_build_keys key 0 = []\"\n| \"present_64_80_build_keys key (Suc n) = \n    (ucast (present_64_80_word_slice 16 64 key :: 64 word)) # \n    present_64_80_build_keys (present_64_80_key_update key (KEY_SCHEDULE_ROUNDS - n)) n\"", "metadata": {"component_type": "Helper: Recursive Key Building", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 80, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 61, "sbox_positions": [76], "counter_position": 15, "counter_mask": 31, "extract_position": 16, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 80, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "key_schedule"], "extraction_time": "2026-01-24T13:11:48.226187"}}
{"instruction": "Translate this Cipher Constant: BLOCK_SIZE from PRESENT-64/40 Python to Isabelle/HOL. Apply: define constants with explicit type annotations. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "# Block size in bits\nBLOCK_SIZE = 64", "output": "definition present_64_40_block_size :: nat where \"present_64_40_block_size = 64\"", "metadata": {"component_type": "Cipher Constant: BLOCK_SIZE", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.228549"}}
{"instruction": "Translate this Cipher Constant: KEY_SIZE from PRESENT-64/40 Python to Isabelle/HOL. Apply: define constants with explicit type annotations. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "# Key size in bits\nKEY_SIZE = 40", "output": "definition present_64_40_key_size :: nat where \"present_64_40_key_size = 40\"", "metadata": {"component_type": "Cipher Constant: KEY_SIZE", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.228569"}}
{"instruction": "Translate this Cipher Constant: ENCRYPTION_ROUNDS from PRESENT-64/40 Python to Isabelle/HOL. Apply: use natural number definition for round count, define constants with explicit type annotations. Note: PRESENT-64/40 uses 8 SPN rounds.", "input": "# Number of SPN rounds (without final whitening)\nENCRYPTION_ROUNDS = 8", "output": "definition present_64_40_encryption_rounds :: nat where \"present_64_40_encryption_rounds = 8\"", "metadata": {"component_type": "Cipher Constant: ENCRYPTION_ROUNDS", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.228585"}}
{"instruction": "Translate this Cipher Constant: TOTAL_ROUNDS from PRESENT-64/40 Python to Isabelle/HOL. Apply: use natural number definition for round count, define constants with explicit type annotations. Note: PRESENT-64/40 uses 8 SPN rounds.", "input": "# Total operations including final whitening\nTOTAL_ROUNDS = 9", "output": "definition present_64_40_total_rounds :: nat where \"present_64_40_total_rounds = 9\"", "metadata": {"component_type": "Cipher Constant: TOTAL_ROUNDS", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.228603"}}
{"instruction": "Translate this Cipher Constant: NIBBLES_PER_BLOCK from PRESENT-64/40 Python to Isabelle/HOL. Apply: define constants with explicit type annotations. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "# Number of 4-bit nibbles in a block\nNIBBLES_PER_BLOCK = 16", "output": "definition present_64_40_nibbles_per_block :: nat where \"present_64_40_nibbles_per_block = 16\"", "metadata": {"component_type": "Cipher Constant: NIBBLES_PER_BLOCK", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.228619"}}
{"instruction": "Translate this Cipher Constant: KEY_SCHEDULE_ROUNDS from PRESENT-64/40 Python to Isabelle/HOL. Apply: use natural number definition for round count, define constants with explicit type annotations. Note: PRESENT-64/40 uses 8 SPN rounds.", "input": "# Number of round keys needed\nKEY_SCHEDULE_ROUNDS = 9", "output": "definition present_64_40_key_schedule_rounds :: nat where \"present_64_40_key_schedule_rounds = 9\"", "metadata": {"component_type": "Cipher Constant: KEY_SCHEDULE_ROUNDS", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.228630"}}
{"instruction": "Translate this S-Box Table from PRESENT-64/40 Python to Isabelle/HOL. Apply: use Isabelle list notation for tables, preserve 4-bit S-box values as hexadecimal. Note: PRESENT uses a 4-bit S-box with strong cryptographic properties.", "input": "# PRESENT S-Box (4-bit substitution)\nSBOX = [0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, \n        0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2]", "output": "definition present_64_40_sbox_table :: \"nat list\" where\n  \"present_64_40_sbox_table = \n    [0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, \n     0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2]\"", "metadata": {"component_type": "S-Box Table", "difficulty": "easy", "semantic_group": "primitives", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["table_definition"], "extraction_time": "2026-01-24T13:11:48.228937"}}
{"instruction": "Translate this Inverse S-Box Table from PRESENT-64/40 Python to Isabelle/HOL. Apply: use Isabelle list notation for tables, preserve 4-bit S-box values as hexadecimal. Note: PRESENT uses a 4-bit S-box with strong cryptographic properties.", "input": "# PRESENT Inverse S-Box\nINV_SBOX = [0x5, 0xE, 0xF, 0x8, 0xC, 0x1, 0x2, 0xD, \n        0xB, 0x4, 0x6, 0x3, 0x0, 0x7, 0x9, 0xA]", "output": "definition present_64_40_sbox_inv_table :: \"nat list\" where\n  \"present_64_40_sbox_inv_table = \n    [0x5, 0xE, 0xF, 0x8, 0xC, 0x1, 0x2, 0xD,\n     0xB, 0x4, 0x6, 0x3, 0x0, 0x7, 0x9, 0xA]\"", "metadata": {"component_type": "Inverse S-Box Table", "difficulty": "easy", "semantic_group": "primitives", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["table_definition"], "extraction_time": "2026-01-24T13:11:48.229192"}}
{"instruction": "Translate this Permutation Table from PRESENT-64/40 Python to Isabelle/HOL. Apply: use Isabelle list notation for tables, implement bit permutation using table lookup. Note: PRESENT permutation layer provides bit-level diffusion across the 64-bit state.", "input": "# PRESENT Permutation Table\nPERM = [0, 16, 32, 48, 1, 17, 33, 49, 2, 18, 34, 50, 3, 19, 35, 51,\n        4, 20, 36, 52, 5, 21, 37, 53, 6, 22, 38, 54, 7, 23, 39, 55,\n        8, 24, 40, 56, 9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,\n        12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63]", "output": "definition present_64_40_p_layer_order :: \"nat list\" where\n  \"present_64_40_p_layer_order = \n    [0, 16, 32, 48, 1, 17, 33, 49, 2, 18, 34, 50, 3, 19, 35, 51,\n     4, 20, 36, 52, 5, 21, 37, 53, 6, 22, 38, 54, 7, 23, 39, 55,\n     8, 24, 40, 56, 9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,\n     12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63]\"", "metadata": {"component_type": "Permutation Table", "difficulty": "easy", "semantic_group": "primitives", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["table_definition", "permutation_layer"], "extraction_time": "2026-01-24T13:11:48.229426"}}
{"instruction": "Translate this Core Operation: Add Round Key from PRESENT-64/40 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially, use XOR operation for key mixing. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def add_round_key(state, round_key):\n    \"\"\"Add round key via XOR (key mixing operation)\"\"\"\n    return state ^ round_key", "output": "definition present_64_40_add_round_key :: \"64 word ⇒ 64 word ⇒ 64 word\" where\n  \"present_64_40_add_round_key state round_key = xor state round_key\"", "metadata": {"component_type": "Core Operation: Add Round Key", "difficulty": "easy", "semantic_group": "core_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["bitwise_operations", "function_definition", "key_addition"], "extraction_time": "2026-01-24T13:11:48.229949"}}
{"instruction": "Translate this Core Operation: S-Box Layer from PRESENT-64/40 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially, apply 16 parallel 4-bit S-boxes, process 16 nibbles in parallel. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def sbox_layer(state):\n        \"\"\"Apply 4-bit S-Box to 16 parallel nibbles\"\"\"\n        res = 0\n        for i in range(16):\n            nibble = (state >> (4 * i)) & 0xF\n            res |= (SBOX[nibble] << (4 * i))\n        return res", "output": "definition present_64_40_sbox_layer :: \"64 word ⇒ 64 word\" where\n  \"present_64_40_sbox_layer s = \n    word_of_int (∑i < 16. \n      uint (present_64_40_sbox (word_of_int ((uint s div 2^(4*i)) mod 16))) * 2^(4*i))\"", "metadata": {"component_type": "Core Operation: S-Box Layer", "difficulty": "medium", "semantic_group": "core_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "substitution_layer"], "extraction_time": "2026-01-24T13:11:48.230182"}}
{"instruction": "Translate this Core Operation: Inverse S-Box Layer from PRESENT-64/40 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially, apply 16 parallel 4-bit S-boxes, process 16 nibbles in parallel. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def inv_sbox_layer(state):\n        \"\"\"Inverse S-box layer for decryption\"\"\"\n        res = 0\n        for i in range(16):\n            nibble = (state >> (4 * i)) & 0xF\n            res |= (INV_SBOX[nibble] << (4 * i))\n        return res", "output": "definition present_64_40_sbox_layer_inverse :: \"64 word ⇒ 64 word\" where\n  \"present_64_40_sbox_layer_inverse s = \n    word_of_int (∑i < 16. \n      uint (present_64_40_sbox_inverse (word_of_int ((uint s div 2^(4*i)) mod 16))) * 2^(4*i))\"", "metadata": {"component_type": "Core Operation: Inverse S-Box Layer", "difficulty": "medium", "semantic_group": "core_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "substitution_layer"], "extraction_time": "2026-01-24T13:11:48.230839"}}
{"instruction": "Translate this Core Operation: Permutation Layer from PRESENT-64/40 Python to Isabelle/HOL. Apply: use Isabelle list notation for tables, implement bit permutation using table lookup. Note: PRESENT permutation layer provides bit-level diffusion across the 64-bit state.", "input": "def p_layer(state):\n        \"\"\"Bit-level permutation layer\"\"\"\n        res = 0\n        for i in range(64):\n            bit = (state >> i) & 1\n            res |= (bit << PERM[i])\n        return res", "output": "definition present_64_40_p_layer :: \"64 word ⇒ 64 word\" where\n  \"present_64_40_p_layer s = \n    word_of_int (∑ i<64. \n      if bit s i then 2 ^ (present_64_40_p_layer_order ! i) else 0)\"", "metadata": {"component_type": "Core Operation: Permutation Layer", "difficulty": "medium", "semantic_group": "core_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "permutation_layer"], "extraction_time": "2026-01-24T13:11:48.231121"}}
{"instruction": "Translate this Core Operation: Inverse Permutation Layer from PRESENT-64/40 Python to Isabelle/HOL. Apply: use Isabelle list notation for tables, implement bit permutation using table lookup. Note: PRESENT permutation layer provides bit-level diffusion across the 64-bit state.", "input": "def inv_p_layer(state):\n        \"\"\"Inverse bit-level permutation layer\"\"\"\n        res = 0\n        for i in range(64):\n            bit = (state >> i) & 1\n            res |= (bit << INV_PERM[i])\n        return res", "output": "definition present_64_40_p_layer_inverse :: \"64 word ⇒ 64 word\" where\n  \"present_64_40_p_layer_inverse s = \n    word_of_int (∑ i<64. \n      if bit s i then 2 ^ (present_64_40_p_layer_inv_order ! i) else 0)\"", "metadata": {"component_type": "Core Operation: Inverse Permutation Layer", "difficulty": "medium", "semantic_group": "core_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "permutation_layer"], "extraction_time": "2026-01-24T13:11:48.231465"}}
{"instruction": "Translate this Round Function: Encrypt Round from PRESENT-64/40 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def encrypt_round(state, round_key):\n        \"\"\"Standard SPN round composition\"\"\"\n        state = add_round_key(state, round_key)\n        state = sbox_layer(state)\n        state = p_layer(state)\n        return state", "output": "definition present_64_40_encrypt_round :: \"64 word ⇒ 64 word ⇒ 64 word\" where\n  \"present_64_40_encrypt_round round_key state = \n    present_64_40_p_layer (present_64_40_sbox_layer (xor state round_key))\"", "metadata": {"component_type": "Round Function: Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition", "substitution_layer", "permutation_layer", "key_addition"], "extraction_time": "2026-01-24T13:11:48.231734"}}
{"instruction": "Translate this Round Function: Decrypt Round from PRESENT-64/40 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def decrypt_round(state, round_key):\n        \"\"\"Inverse SPN round composition\"\"\"\n        state = inv_p_layer(state)\n        state = inv_sbox_layer(state)\n        state = add_round_key(state, round_key)\n        return state", "output": "definition present_64_40_decrypt_round_inverse :: \"64 word ⇒ 64 word ⇒ 64 word\" where\n  \"present_64_40_decrypt_round_inverse round_key state = \n    xor (present_64_40_sbox_layer_inverse (present_64_40_p_layer_inverse state)) round_key\"", "metadata": {"component_type": "Round Function: Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition", "substitution_layer", "permutation_layer", "key_addition"], "extraction_time": "2026-01-24T13:11:48.232024"}}
{"instruction": "Translate this Key Extraction (40-bit variant) from PRESENT-64/40 Python to Isabelle/HOL. Apply: implement key register rotation and S-box application, use round counter for key schedule. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def extract_round_key_40(key_state):\n        \"\"\"Extract 64-bit round key from 40-bit state (bits 0:63)\"\"\"\n        # key_extract_shift = 0\n        #mask = (1 << key_extract_shift) - 1\n        mask = (1 << 0) - 1\n        # return (key_state >> 0) & (1 << 0) - 1\n        return (key_state >> 0) & (1 << 0) - 1", "output": "definition present_64_40_extract_round_key :: \"40 word ⇒ 64 word\" where\n      \"present_64_40_extract_round_key key_state = \n        ucast (present_64_40_word_slice 0 64 key_state)\"", "metadata": {"component_type": "Key Extraction (40-bit variant)", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.233199"}}
{"instruction": "Translate this Key Update (40-bit variant) from PRESENT-64/40 Python to Isabelle/HOL. Apply: implement key register rotation and S-box application, use round counter for key schedule. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def key_update_40(key_state, round_counter):\n        \"\"\"Update 40-bit key state (Weak variant)\"\"\"\n        # 1. Rotate 20 bits\n        key_state = ((key_state << 20) & ((1 << 40) - 1)) | (key_state >> 20)\n        # 2. S-Box the top nibble\n        nibble = (key_state >> 36) & 0xF\n        key_state = (SBOX[nibble] << 36) | (key_state & ((1 << 36) - 1))\n        # 3. XOR round counter\n        key_state ^= round_counter\n        return key_state", "output": "definition present_64_40_key_update :: \"40 word ⇒ nat ⇒ 40 word\" where\n  \"present_64_40_key_update k r_count = (\n    let k_rot = word_rotl 21 k;                   \n        sbox_in = (present_64_40_word_slice 36 4 k_rot :: 4 word); \n        sbox_out = present_64_40_sbox sbox_in;\n        k_sboxed = or (and k_rot (mask 36)) (push_bit 36 (ucast sbox_out));\n        xor_in = (present_64_40_word_slice 15 5 k_sboxed :: 5 word);  \n        xor_out = xor xor_in (of_nat r_count);\n        mask_15_19 = not (push_bit 15 (mask 5 :: 40 word));\n        k_final = or (and k_sboxed mask_15_19) (push_bit 15 (ucast xor_out))\n    in k_final)\"", "metadata": {"component_type": "Key Update (40-bit variant)", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "table_definition", "function_definition", "key_schedule"], "extraction_time": "2026-01-24T13:11:48.233666"}}
{"instruction": "Translate this Generate Round Keys (40-bit) from PRESENT-64/40 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def generate_round_keys_40(key):\n    \"\"\"Generate round keys for PRESENT-64/40\"\"\"\n    #key_size = 40\n    round_keys = []\n    k_state = key\n    for r in range(1, 9):  # 8 round keys (SPN rounds)\n        # Extract round key (bits 0-63 of 40-bit state)\n        round_keys.append(k_state & ((1 << 64) - 1))\n        # Update key state\n        k_state = key_update_40(k_state, r)    \n    # Final whitening key (round 9)\n    round_keys.append(k_state & ((1 << 64) - 1))\n    return round_keys", "output": "definition present_64_40_generate_key_schedule :: \"40 word ⇒ 64 word list\" where\n  \"present_64_40_generate_key_schedule initial_key = \n    present_64_40_build_keys initial_key KEY_SCHEDULE_ROUNDS\"", "metadata": {"component_type": "Generate Round Keys (40-bit)", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "key_schedule"], "extraction_time": "2026-01-24T13:11:48.233993"}}
{"instruction": "Translate this Iteration: Encrypt Iterate (Recursive) from PRESENT-64/40 Python to Isabelle/HOL. Apply: convert Python for-loops to recursion, handle round iteration with explicit counter, apply rounds in correct order (1-8 with final whitening). Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def encrypt_iterate(state, round_keys):\n        \"\"\"Recursive/Iterative layer for round application\"\"\"\n        for rk in round_keys[:-1]:\n            state = encrypt_round(state, rk)\n        # Final whitening XOR\n        return state ^ round_keys[-1]", "output": "fun present_64_40_encrypt_iterate :: \"64 word ⇒ 64 word list ⇒ nat ⇒ 64 word\" where\n  \"present_64_40_encrypt_iterate state [] _ = state\"\n| \"present_64_40_encrypt_iterate state (k#ks) rounds_left = \n     (if rounds_left = 1 then xor state k \n      else present_64_40_encrypt_iterate (present_64_40_encrypt_round k state) ks (rounds_left - 1))\"", "metadata": {"component_type": "Iteration: Encrypt Iterate (Recursive)", "difficulty": "medium", "semantic_group": "iteration", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "table_definition", "function_definition"], "extraction_time": "2026-01-24T13:11:48.234295"}}
{"instruction": "Translate this Iteration: Decrypt Iterate (Recursive) from PRESENT-64/40 Python to Isabelle/HOL. Apply: convert Python for-loops to recursion, handle round iteration with explicit counter, apply rounds in correct order (1-8 with final whitening). Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def decrypt_iterate(state, round_keys):\n        \"\"\"Recursive/Iterative layer for inverse round application\"\"\"\n        # Undo final whitening\n        state = state ^ round_keys[-1]\n        # Undo rounds in reverse\n        for rk in reversed(round_keys[:-1]):\n            state = decrypt_round(state, rk)\n        return state", "output": "fun present_64_40_decrypt_iterate :: \"64 word ⇒ 64 word list ⇒ nat ⇒ 64 word\" where\n  \"present_64_40_decrypt_iterate state [] _ = state\"\n| \"present_64_40_decrypt_iterate state (k#ks) rounds_left = \n     (if rounds_left = 1 then xor state k \n      else present_64_40_decrypt_iterate (present_64_40_decrypt_round_inverse k state) ks (rounds_left - 1))\"", "metadata": {"component_type": "Iteration: Decrypt Iterate (Recursive)", "difficulty": "medium", "semantic_group": "iteration", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "table_definition", "function_definition"], "extraction_time": "2026-01-24T13:11:48.234600"}}
{"instruction": "Translate this Semantic Boundary: Final Whitening from PRESENT-64/40 Python to Isabelle/HOL. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def final_whitening(state, key):\n    \"\"\"Final key addition (semantic boundary for last round)\"\"\"\n    return state ^ key", "output": "definition present_64_40_final_whitening :: \"64 word ⇒ 64 word ⇒ 64 word\" where\n  \"present_64_40_final_whitening state key = xor state key\"", "metadata": {"component_type": "Semantic Boundary: Final Whitening", "difficulty": "easy", "semantic_group": "iteration", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.234617"}}
{"instruction": "Translate this Block Encryption from PRESENT-64/40 Python to Isabelle/HOL. Apply: apply SPN structure: AddRoundKey → S-box → Permutation, handle final round without permutation layer, use generated round keys from key schedule. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def encrypt_block(plaintext, key):\n        \"\"\"Orchestration of key expansion and state transformation\"\"\"\n        round_keys = generate_round_keys(key)\n        return encrypt_iterate(plaintext, round_keys)", "output": "definition present_64_40_encrypt_block :: \"64 word ⇒ 64 word list ⇒ 64 word\" where\n  \"present_64_40_encrypt_block state keys = \n    present_64_40_encrypt_iterate state keys ENCRYPTION_ROUNDS\"", "metadata": {"component_type": "Block Encryption", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.234890"}}
{"instruction": "Translate this Block Decryption from PRESENT-64/40 Python to Isabelle/HOL. Apply: apply SPN structure: AddRoundKey → S-box → Permutation, handle final round without permutation layer, use generated round keys from key schedule. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def decrypt_block(ciphertext, key):\n        \"\"\"Orchestration of key expansion and inverse state transformation\"\"\"\n        round_keys = generate_round_keys(key)\n        return decrypt_iterate(ciphertext, round_keys)", "output": "definition present_64_40_decrypt_block :: \"64 word ⇒ 64 word list ⇒ 64 word\" where\n  \"present_64_40_decrypt_block state keys = \n    present_64_40_decrypt_iterate state (rev keys) ENCRYPTION_ROUNDS\"", "metadata": {"component_type": "Block Decryption", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.235206"}}
{"instruction": "Translate this Top-Level: Encrypt from PRESENT-64/40 Python to Isabelle/HOL. Apply: apply SPN structure: AddRoundKey → S-box → Permutation, handle final round without permutation layer, use generated round keys from key schedule. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def encrypt(plaintext, key):\n        \"\"\"Top-level encryption entry point\"\"\"\n        return encrypt_block(plaintext, key)", "output": "definition present_64_40_encrypt :: \"64 word ⇒ 40 word ⇒ 64 word\" where\n  \"present_64_40_encrypt plaintext key = (\n    let keys = present_64_40_generate_key_schedule key\n    in present_64_40_encrypt_block plaintext keys)\"", "metadata": {"component_type": "Top-Level: Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.235741"}}
{"instruction": "Translate this Top-Level: Decrypt from PRESENT-64/40 Python to Isabelle/HOL. Apply: apply SPN structure: AddRoundKey → S-box → Permutation, handle final round without permutation layer, use generated round keys from key schedule. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def decrypt(ciphertext, key):\n        \"\"\"Top-level decryption entry point\"\"\"\n        return decrypt_block(ciphertext, key)", "output": "definition present_64_40_decrypt :: \"64 word ⇒ 40 word ⇒ 64 word\" where\n  \"present_64_40_decrypt ciphertext key = (\n    let keys = present_64_40_generate_key_schedule key\n    in present_64_40_decrypt_block ciphertext keys)\"", "metadata": {"component_type": "Top-Level: Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.236028"}}
{"instruction": "Translate this Helper: Word Slice from PRESENT-64/40 Python to Isabelle/HOL. Apply: extract bit slices using shift and mask operations. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def word_slice(start, length, word):\n    \"\"\"Extract a slice of bits from a word\"\"\"\n    mask = (1 << length) - 1\n    # return (word >> start) & mask\n    return (word >> start) & (1 << length) - 1", "output": "definition present_64_40_word_slice :: \"nat ⇒ nat ⇒ 'a::len word ⇒ 'b::len word\" where\n  \"present_64_40_word_slice start len w = \n    word_of_int ((uint w div 2^start) mod 2^len)\"", "metadata": {"component_type": "Helper: Word Slice", "difficulty": "medium", "semantic_group": "helpers", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.236283"}}
{"instruction": "Translate this Helper: S-Box Function from PRESENT-64/40 Python to Isabelle/HOL. Apply: apply 4-bit S-box using table lookup. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def sbox(nibble):\n    \"\"\"Apply S-box to a 4-bit nibble\"\"\"\n    return SBOX[nibble]", "output": "definition present_64_40_sbox :: \"4 word ⇒ 4 word\" where\n  \"present_64_40_sbox x = of_nat (present_64_40_sbox_table ! unat x)\"", "metadata": {"component_type": "Helper: S-Box Function", "difficulty": "easy", "semantic_group": "helpers", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.236479"}}
{"instruction": "Translate this Helper: Inverse S-Box Function from PRESENT-64/40 Python to Isabelle/HOL. Apply: apply 4-bit S-box using table lookup. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def inv_sbox(nibble):\n    \"\"\"Apply inverse S-box to a 4-bit nibble\"\"\"\n    return INV_SBOX[nibble]", "output": "definition present_64_40_sbox_inverse :: \"4 word ⇒ 4 word\" where\n  \"present_64_40_sbox_inverse x = of_nat (present_64_40_sbox_inv_table ! unat x)\"", "metadata": {"component_type": "Helper: Inverse S-Box Function", "difficulty": "easy", "semantic_group": "helpers", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.236688"}}
{"instruction": "Translate this Helper: Recursive Key Building from PRESENT-64/40 Python to Isabelle/HOL. Apply: implement key register rotation and S-box application, use round counter for key schedule. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def build_keys(key, n):\n    \"\"\"Recursively generate round keys\"\"\"\n    if n == 0:\n        return []\n\n    # uses key_update_40 function for key size =40\n    current_key = (key >> 16) & ((1 << 64) - 1)\n    next_key = key_update_40(key, n)\n    return [current_key] + build_keys(next_key, n - 1)", "output": "fun present_64_40_build_keys :: \"40 word ⇒ nat ⇒ 64 word list\" where\n  \"present_64_40_build_keys key 0 = []\"\n| \"present_64_40_build_keys key (Suc n) = \n    (ucast key :: 64 word) # \n    present_64_40_build_keys (present_64_40_key_update key (KEY_SCHEDULE_ROUNDS - n)) n\"", "metadata": {"component_type": "Helper: Recursive Key Building", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 40, "rounds": 8, "key_schedule_rounds": 9}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 21, "sbox_positions": [36], "counter_position": 0, "counter_mask": 31, "extract_position": 0, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 40, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "key_schedule"], "extraction_time": "2026-01-24T13:11:48.236943"}}
{"instruction": "Translate this Cipher Constant: BLOCK_SIZE from PRESENT-64/128 Python to Isabelle/HOL. Apply: define constants with explicit type annotations. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "# Block size in bits\nBLOCK_SIZE = 64", "output": "definition present_64_128_block_size :: nat where \"present_64_128_block_size = 64\"", "metadata": {"component_type": "Cipher Constant: BLOCK_SIZE", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.239539"}}
{"instruction": "Translate this Cipher Constant: KEY_SIZE from PRESENT-64/128 Python to Isabelle/HOL. Apply: define constants with explicit type annotations. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "# Key size in bits\nKEY_SIZE = 128", "output": "definition present_64_128_key_size :: nat where \"present_64_128_key_size = 128\"", "metadata": {"component_type": "Cipher Constant: KEY_SIZE", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.239562"}}
{"instruction": "Translate this Cipher Constant: ENCRYPTION_ROUNDS from PRESENT-64/128 Python to Isabelle/HOL. Apply: use natural number definition for round count, define constants with explicit type annotations. Note: PRESENT-64/128 uses 31 SPN rounds.", "input": "# Number of SPN rounds (without final whitening)\nENCRYPTION_ROUNDS = 31", "output": "definition present_64_128_encryption_rounds :: nat where \"present_64_128_encryption_rounds = 31\"", "metadata": {"component_type": "Cipher Constant: ENCRYPTION_ROUNDS", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.239574"}}
{"instruction": "Translate this Cipher Constant: TOTAL_ROUNDS from PRESENT-64/128 Python to Isabelle/HOL. Apply: use natural number definition for round count, define constants with explicit type annotations. Note: PRESENT-64/128 uses 31 SPN rounds.", "input": "# Total operations including final whitening\nTOTAL_ROUNDS = 32", "output": "definition present_64_128_total_rounds :: nat where \"present_64_128_total_rounds = 32\"", "metadata": {"component_type": "Cipher Constant: TOTAL_ROUNDS", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.239585"}}
{"instruction": "Translate this Cipher Constant: NIBBLES_PER_BLOCK from PRESENT-64/128 Python to Isabelle/HOL. Apply: define constants with explicit type annotations. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "# Number of 4-bit nibbles in a block\nNIBBLES_PER_BLOCK = 16", "output": "definition present_64_128_nibbles_per_block :: nat where \"present_64_128_nibbles_per_block = 16\"", "metadata": {"component_type": "Cipher Constant: NIBBLES_PER_BLOCK", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.239593"}}
{"instruction": "Translate this Cipher Constant: KEY_SCHEDULE_ROUNDS from PRESENT-64/128 Python to Isabelle/HOL. Apply: use natural number definition for round count, define constants with explicit type annotations. Note: PRESENT-64/128 uses 31 SPN rounds.", "input": "# Number of round keys needed\nKEY_SCHEDULE_ROUNDS = 32", "output": "definition present_64_128_key_schedule_rounds :: nat where \"present_64_128_key_schedule_rounds = 32\"", "metadata": {"component_type": "Cipher Constant: KEY_SCHEDULE_ROUNDS", "difficulty": "easy", "semantic_group": "constants", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.239606"}}
{"instruction": "Translate this S-Box Table from PRESENT-64/128 Python to Isabelle/HOL. Apply: use Isabelle list notation for tables, preserve 4-bit S-box values as hexadecimal. Note: PRESENT uses a 4-bit S-box with strong cryptographic properties.", "input": "# PRESENT S-Box (4-bit substitution)\nSBOX = [0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, \n        0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2]", "output": "definition present_64_128_sbox_table :: \"nat list\" where\n  \"present_64_128_sbox_table = \n    [0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, \n     0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2]\"", "metadata": {"component_type": "S-Box Table", "difficulty": "easy", "semantic_group": "primitives", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["table_definition"], "extraction_time": "2026-01-24T13:11:48.239855"}}
{"instruction": "Translate this Inverse S-Box Table from PRESENT-64/128 Python to Isabelle/HOL. Apply: use Isabelle list notation for tables, preserve 4-bit S-box values as hexadecimal. Note: PRESENT uses a 4-bit S-box with strong cryptographic properties.", "input": "# PRESENT Inverse S-Box\nINV_SBOX = [0x5, 0xE, 0xF, 0x8, 0xC, 0x1, 0x2, 0xD, \n        0xB, 0x4, 0x6, 0x3, 0x0, 0x7, 0x9, 0xA]", "output": "definition present_64_128_sbox_inv_table :: \"nat list\" where\n  \"present_64_128_sbox_inv_table = \n    [0x5, 0xE, 0xF, 0x8, 0xC, 0x1, 0x2, 0xD,\n     0xB, 0x4, 0x6, 0x3, 0x0, 0x7, 0x9, 0xA]\"", "metadata": {"component_type": "Inverse S-Box Table", "difficulty": "easy", "semantic_group": "primitives", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["table_definition"], "extraction_time": "2026-01-24T13:11:48.240063"}}
{"instruction": "Translate this Permutation Table from PRESENT-64/128 Python to Isabelle/HOL. Apply: use Isabelle list notation for tables, implement bit permutation using table lookup. Note: PRESENT permutation layer provides bit-level diffusion across the 64-bit state.", "input": "# PRESENT Permutation Table\nPERM = [0, 16, 32, 48, 1, 17, 33, 49, 2, 18, 34, 50, 3, 19, 35, 51,\n        4, 20, 36, 52, 5, 21, 37, 53, 6, 22, 38, 54, 7, 23, 39, 55,\n        8, 24, 40, 56, 9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,\n        12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63]", "output": "definition present_64_128_p_layer_order :: \"nat list\" where\n  \"present_64_128_p_layer_order = \n    [0, 16, 32, 48, 1, 17, 33, 49, 2, 18, 34, 50, 3, 19, 35, 51,\n     4, 20, 36, 52, 5, 21, 37, 53, 6, 22, 38, 54, 7, 23, 39, 55,\n     8, 24, 40, 56, 9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,\n     12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63]\"", "metadata": {"component_type": "Permutation Table", "difficulty": "easy", "semantic_group": "primitives", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["table_definition", "permutation_layer"], "extraction_time": "2026-01-24T13:11:48.240264"}}
{"instruction": "Translate this Core Operation: Add Round Key from PRESENT-64/128 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially, use XOR operation for key mixing. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def add_round_key(state, round_key):\n    \"\"\"Add round key via XOR (key mixing operation)\"\"\"\n    return state ^ round_key", "output": "definition present_64_128_add_round_key :: \"64 word ⇒ 64 word ⇒ 64 word\" where\n  \"present_64_128_add_round_key state round_key = xor state round_key\"", "metadata": {"component_type": "Core Operation: Add Round Key", "difficulty": "easy", "semantic_group": "core_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["bitwise_operations", "function_definition", "key_addition"], "extraction_time": "2026-01-24T13:11:48.240758"}}
{"instruction": "Translate this Core Operation: S-Box Layer from PRESENT-64/128 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially, apply 16 parallel 4-bit S-boxes, process 16 nibbles in parallel. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def sbox_layer(state):\n        \"\"\"Apply 4-bit S-Box to 16 parallel nibbles\"\"\"\n        res = 0\n        for i in range(16):\n            nibble = (state >> (4 * i)) & 0xF\n            res |= (SBOX[nibble] << (4 * i))\n        return res", "output": "definition present_64_128_sbox_layer :: \"64 word ⇒ 64 word\" where\n  \"present_64_128_sbox_layer s = \n    word_of_int (∑i < 16. \n      uint (present_64_128_sbox (word_of_int ((uint s div 2^(4*i)) mod 16))) * 2^(4*i))\"", "metadata": {"component_type": "Core Operation: S-Box Layer", "difficulty": "medium", "semantic_group": "core_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "substitution_layer"], "extraction_time": "2026-01-24T13:11:48.241034"}}
{"instruction": "Translate this Core Operation: Inverse S-Box Layer from PRESENT-64/128 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially, apply 16 parallel 4-bit S-boxes, process 16 nibbles in parallel. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def inv_sbox_layer(state):\n        \"\"\"Inverse S-box layer for decryption\"\"\"\n        res = 0\n        for i in range(16):\n            nibble = (state >> (4 * i)) & 0xF\n            res |= (INV_SBOX[nibble] << (4 * i))\n        return res", "output": "definition present_64_128_sbox_layer_inverse :: \"64 word ⇒ 64 word\" where\n  \"present_64_128_sbox_layer_inverse s = \n    word_of_int (∑i < 16. \n      uint (present_64_128_sbox_inverse (word_of_int ((uint s div 2^(4*i)) mod 16))) * 2^(4*i))\"", "metadata": {"component_type": "Core Operation: Inverse S-Box Layer", "difficulty": "medium", "semantic_group": "core_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "substitution_layer"], "extraction_time": "2026-01-24T13:11:48.241288"}}
{"instruction": "Translate this Core Operation: Permutation Layer from PRESENT-64/128 Python to Isabelle/HOL. Apply: use Isabelle list notation for tables, implement bit permutation using table lookup. Note: PRESENT permutation layer provides bit-level diffusion across the 64-bit state.", "input": "def p_layer(state):\n        \"\"\"Bit-level permutation layer\"\"\"\n        res = 0\n        for i in range(64):\n            bit = (state >> i) & 1\n            res |= (bit << PERM[i])\n        return res", "output": "definition present_64_128_p_layer :: \"64 word ⇒ 64 word\" where\n  \"present_64_128_p_layer s = \n    word_of_int (∑ i<64. \n      if bit s i then 2 ^ (present_64_128_p_layer_order ! i) else 0)\"", "metadata": {"component_type": "Core Operation: Permutation Layer", "difficulty": "medium", "semantic_group": "core_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "permutation_layer"], "extraction_time": "2026-01-24T13:11:48.241563"}}
{"instruction": "Translate this Core Operation: Inverse Permutation Layer from PRESENT-64/128 Python to Isabelle/HOL. Apply: use Isabelle list notation for tables, implement bit permutation using table lookup. Note: PRESENT permutation layer provides bit-level diffusion across the 64-bit state.", "input": "def inv_p_layer(state):\n        \"\"\"Inverse bit-level permutation layer\"\"\"\n        res = 0\n        for i in range(64):\n            bit = (state >> i) & 1\n            res |= (bit << INV_PERM[i])\n        return res", "output": "definition present_64_128_p_layer_inverse :: \"64 word ⇒ 64 word\" where\n  \"present_64_128_p_layer_inverse s = \n    word_of_int (∑ i<64. \n      if bit s i then 2 ^ (present_64_128_p_layer_inv_order ! i) else 0)\"", "metadata": {"component_type": "Core Operation: Inverse Permutation Layer", "difficulty": "medium", "semantic_group": "core_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "permutation_layer"], "extraction_time": "2026-01-24T13:11:48.241806"}}
{"instruction": "Translate this Round Function: Encrypt Round from PRESENT-64/128 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def encrypt_round(state, round_key):\n        \"\"\"Standard SPN round composition\"\"\"\n        state = add_round_key(state, round_key)\n        state = sbox_layer(state)\n        state = p_layer(state)\n        return state", "output": "definition present_64_128_encrypt_round :: \"64 word ⇒ 64 word ⇒ 64 word\" where\n  \"present_64_128_encrypt_round round_key state = \n    present_64_128_p_layer (present_64_128_sbox_layer (xor state round_key))\"", "metadata": {"component_type": "Round Function: Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition", "substitution_layer", "permutation_layer", "key_addition"], "extraction_time": "2026-01-24T13:11:48.242138"}}
{"instruction": "Translate this Round Function: Decrypt Round from PRESENT-64/128 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def decrypt_round(state, round_key):\n        \"\"\"Inverse SPN round composition\"\"\"\n        state = inv_p_layer(state)\n        state = inv_sbox_layer(state)\n        state = add_round_key(state, round_key)\n        return state", "output": "definition present_64_128_decrypt_round_inverse :: \"64 word ⇒ 64 word ⇒ 64 word\" where\n  \"present_64_128_decrypt_round_inverse round_key state = \n    xor (present_64_128_sbox_layer_inverse (present_64_128_p_layer_inverse state)) round_key\"", "metadata": {"component_type": "Round Function: Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition", "substitution_layer", "permutation_layer", "key_addition"], "extraction_time": "2026-01-24T13:11:48.242386"}}
{"instruction": "Translate this Key Extraction (128-bit variant) from PRESENT-64/128 Python to Isabelle/HOL. Apply: implement key register rotation and S-box application, use round counter for key schedule, rotate key register left by 67 bits. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def extract_round_key_128(key_state):\n        \"\"\"Extract 64-bit round key from 128-bit state (bits 64:127)\"\"\"\n        # key_extract_shift = 64\n        #mask = (1 << key_extract_shift) - 1\n        mask = (1 << 64) - 1\n        # return (key_state >> 64) & (1 << 64) - 1\n        return (key_state >> 64) & (1 << 64) - 1", "output": "definition present_64_128_extract_round_key :: \"128 word ⇒ 64 word\" where\n      \"present_64_128_extract_round_key key_state = \n        ucast (present_64_128_word_slice 64 64 key_state)\"", "metadata": {"component_type": "Key Extraction (128-bit variant)", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.242961"}}
{"instruction": "Translate this Key Update (128-bit variant) from PRESENT-64/128 Python to Isabelle/HOL. Apply: implement key register rotation and S-box application, use round counter for key schedule, rotate key register left by 67 bits. Note: PRESENT-128 key schedule rotates 128-bit register by 67 bits and applies S-box to two nibbles.", "input": "def key_update_128(key_state, round_counter):\n        \"\"\"Update 128-bit key state (Standard)\"\"\"\n        key_state = ((key_state << 61) & ((1 << 128) - 1)) | (key_state >> 67)\n        n1 = (key_state >> 124) & 0xF\n        n2 = (key_state >> 120) & 0xF\n        key_state = (SBOX[n1] << 124) | (SBOX[n2] << 120) | (key_state & ((1 << 120) - 1))\n        key_state ^= (round_counter << 62)\n        return key_state", "output": "definition present_64_128_key_update :: \"128 word ⇒ nat ⇒ 128 word\" where\n  \"present_64_128_key_update k r_count = (\n    let k_rot = word_rotl 67 k;                    \n        sbox_hi = present_64_128_sbox (present_64_128_word_slice 124 4 k_rot); \n        sbox_lo = present_64_128_sbox (present_64_128_word_slice 120 4 k_rot);  \n        k_sboxed = or (and k_rot (mask 120)) \n                     (or (push_bit 124 (ucast sbox_hi)) \n                         (push_bit 120 (ucast sbox_lo)));\n        xor_in = (present_64_128_word_slice 62 5 k_sboxed :: 5 word);  \n        xor_out = xor xor_in (of_nat r_count);\n        mask_62_66 = not (push_bit 62 (mask 5 :: 128 word));\n        k_final = or (and k_sboxed mask_62_66) (push_bit 62 (ucast xor_out))\n    in k_final)\"", "metadata": {"component_type": "Key Update (128-bit variant)", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "table_definition", "function_definition", "key_schedule"], "extraction_time": "2026-01-24T13:11:48.243570"}}
{"instruction": "Translate this Generate Round Keys (128-bit) from PRESENT-64/128 Python to Isabelle/HOL. Apply: implement SPN layer operations sequentially. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def generate_round_keys_128(key):\n    \"\"\"Generate round keys for PRESENT-64/128\"\"\"\n    #key_size = 128\n    \n    round_keys = []\n    k_state = key\n    \n    for r in range(1, 32):  # 31 round keys\n        # Extract round key (bits 64-127)\n        round_keys.append((k_state >> 64) & ((1 << 64) - 1))\n        # Update key state\n        k_state = key_update_128(k_state, r)\n    \n    # Final whitening key\n    round_keys.append((k_state >> 64) & ((1 << 64) - 1))\n    return round_keys", "output": "definition present_64_128_generate_key_schedule :: \"128 word ⇒ 64 word list\" where\n  \"present_64_128_generate_key_schedule initial_key = \n    present_64_128_build_keys initial_key KEY_SCHEDULE_ROUNDS\"", "metadata": {"component_type": "Generate Round Keys (128-bit)", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "key_schedule"], "extraction_time": "2026-01-24T13:11:48.243872"}}
{"instruction": "Translate this Iteration: Encrypt Iterate (Recursive) from PRESENT-64/128 Python to Isabelle/HOL. Apply: convert Python for-loops to recursion, handle round iteration with explicit counter, apply rounds in correct order (1-31 with final whitening). Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def encrypt_iterate(state, round_keys):\n        \"\"\"Recursive/Iterative layer for round application\"\"\"\n        for rk in round_keys[:-1]:\n            state = encrypt_round(state, rk)\n        # Final whitening XOR\n        return state ^ round_keys[-1]", "output": "fun present_64_128_encrypt_iterate :: \"64 word ⇒ 64 word list ⇒ nat ⇒ 64 word\" where\n  \"present_64_128_encrypt_iterate state [] _ = state\"\n| \"present_64_128_encrypt_iterate state (k#ks) rounds_left = \n     (if rounds_left = 1 then xor state k \n      else present_64_128_encrypt_iterate (present_64_128_encrypt_round k state) ks (rounds_left - 1))\"", "metadata": {"component_type": "Iteration: Encrypt Iterate (Recursive)", "difficulty": "medium", "semantic_group": "iteration", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "table_definition", "function_definition"], "extraction_time": "2026-01-24T13:11:48.244278"}}
{"instruction": "Translate this Iteration: Decrypt Iterate (Recursive) from PRESENT-64/128 Python to Isabelle/HOL. Apply: convert Python for-loops to recursion, handle round iteration with explicit counter, apply rounds in correct order (1-31 with final whitening). Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def decrypt_iterate(state, round_keys):\n        \"\"\"Recursive/Iterative layer for inverse round application\"\"\"\n        # Undo final whitening\n        state = state ^ round_keys[-1]\n        # Undo rounds in reverse\n        for rk in reversed(round_keys[:-1]):\n            state = decrypt_round(state, rk)\n        return state", "output": "fun present_64_128_decrypt_iterate :: \"64 word ⇒ 64 word list ⇒ nat ⇒ 64 word\" where\n  \"present_64_128_decrypt_iterate state [] _ = state\"\n| \"present_64_128_decrypt_iterate state (k#ks) rounds_left = \n     (if rounds_left = 1 then xor state k \n      else present_64_128_decrypt_iterate (present_64_128_decrypt_round_inverse k state) ks (rounds_left - 1))\"", "metadata": {"component_type": "Iteration: Decrypt Iterate (Recursive)", "difficulty": "medium", "semantic_group": "iteration", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "table_definition", "function_definition"], "extraction_time": "2026-01-24T13:11:48.244601"}}
{"instruction": "Translate this Semantic Boundary: Final Whitening from PRESENT-64/128 Python to Isabelle/HOL. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def final_whitening(state, key):\n    \"\"\"Final key addition (semantic boundary for last round)\"\"\"\n    return state ^ key", "output": "definition present_64_128_final_whitening :: \"64 word ⇒ 64 word ⇒ 64 word\" where\n  \"present_64_128_final_whitening state key = xor state key\"", "metadata": {"component_type": "Semantic Boundary: Final Whitening", "difficulty": "easy", "semantic_group": "iteration", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.244627"}}
{"instruction": "Translate this Block Encryption from PRESENT-64/128 Python to Isabelle/HOL. Apply: apply SPN structure: AddRoundKey → S-box → Permutation, handle final round without permutation layer, use generated round keys from key schedule. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def encrypt_block(plaintext, key):\n        \"\"\"Orchestration of key expansion and state transformation\"\"\"\n        round_keys = generate_round_keys(key)\n        return encrypt_iterate(plaintext, round_keys)", "output": "definition present_64_128_encrypt_block :: \"64 word ⇒ 64 word list ⇒ 64 word\" where\n  \"present_64_128_encrypt_block state keys = \n    present_64_128_encrypt_iterate state keys ENCRYPTION_ROUNDS\"", "metadata": {"component_type": "Block Encryption", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.244915"}}
{"instruction": "Translate this Block Decryption from PRESENT-64/128 Python to Isabelle/HOL. Apply: apply SPN structure: AddRoundKey → S-box → Permutation, handle final round without permutation layer, use generated round keys from key schedule. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def decrypt_block(ciphertext, key):\n        \"\"\"Orchestration of key expansion and inverse state transformation\"\"\"\n        round_keys = generate_round_keys(key)\n        return decrypt_iterate(ciphertext, round_keys)", "output": "definition present_64_128_decrypt_block :: \"64 word ⇒ 64 word list ⇒ 64 word\" where\n  \"present_64_128_decrypt_block state keys = \n    present_64_128_decrypt_iterate state (rev keys) ENCRYPTION_ROUNDS\"", "metadata": {"component_type": "Block Decryption", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.245180"}}
{"instruction": "Translate this Top-Level: Encrypt from PRESENT-64/128 Python to Isabelle/HOL. Apply: apply SPN structure: AddRoundKey → S-box → Permutation, handle final round without permutation layer, use generated round keys from key schedule. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def encrypt(plaintext, key):\n        \"\"\"Top-level encryption entry point\"\"\"\n        return encrypt_block(plaintext, key)", "output": "definition present_64_128_encrypt :: \"64 word ⇒ 128 word ⇒ 64 word\" where\n  \"present_64_128_encrypt plaintext key = (\n    let keys = present_64_128_generate_key_schedule key\n    in present_64_128_encrypt_block plaintext keys)\"", "metadata": {"component_type": "Top-Level: Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.245461"}}
{"instruction": "Translate this Top-Level: Decrypt from PRESENT-64/128 Python to Isabelle/HOL. Apply: apply SPN structure: AddRoundKey → S-box → Permutation, handle final round without permutation layer, use generated round keys from key schedule. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def decrypt(ciphertext, key):\n        \"\"\"Top-level decryption entry point\"\"\"\n        return decrypt_block(ciphertext, key)", "output": "definition present_64_128_decrypt :: \"64 word ⇒ 128 word ⇒ 64 word\" where\n  \"present_64_128_decrypt ciphertext key = (\n    let keys = present_64_128_generate_key_schedule key\n    in present_64_128_decrypt_block ciphertext keys)\"", "metadata": {"component_type": "Top-Level: Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.245692"}}
{"instruction": "Translate this Helper: Word Slice from PRESENT-64/128 Python to Isabelle/HOL. Apply: extract bit slices using shift and mask operations. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def word_slice(start, length, word):\n    \"\"\"Extract a slice of bits from a word\"\"\"\n    mask = (1 << length) - 1\n    # return (word >> start) & mask\n    return (word >> start) & (1 << length) - 1", "output": "definition present_64_128_word_slice :: \"nat ⇒ nat ⇒ 'a::len word ⇒ 'b::len word\" where\n  \"present_64_128_word_slice start len w = \n    word_of_int ((uint w div 2^start) mod 2^len)\"", "metadata": {"component_type": "Helper: Word Slice", "difficulty": "medium", "semantic_group": "helpers", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.245899"}}
{"instruction": "Translate this Helper: S-Box Function from PRESENT-64/128 Python to Isabelle/HOL. Apply: apply 4-bit S-box using table lookup. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def sbox(nibble):\n    \"\"\"Apply S-box to a 4-bit nibble\"\"\"\n    return SBOX[nibble]", "output": "definition present_64_128_sbox :: \"4 word ⇒ 4 word\" where\n  \"present_64_128_sbox x = of_nat (present_64_128_sbox_table ! unat x)\"", "metadata": {"component_type": "Helper: S-Box Function", "difficulty": "easy", "semantic_group": "helpers", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.246092"}}
{"instruction": "Translate this Helper: Inverse S-Box Function from PRESENT-64/128 Python to Isabelle/HOL. Apply: apply 4-bit S-box using table lookup. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def inv_sbox(nibble):\n    \"\"\"Apply inverse S-box to a 4-bit nibble\"\"\"\n    return INV_SBOX[nibble]", "output": "definition present_64_128_sbox_inverse :: \"4 word ⇒ 4 word\" where\n  \"present_64_128_sbox_inverse x = of_nat (present_64_128_sbox_inv_table ! unat x)\"", "metadata": {"component_type": "Helper: Inverse S-Box Function", "difficulty": "easy", "semantic_group": "helpers", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.246401"}}
{"instruction": "Translate this Helper: Recursive Key Building from PRESENT-64/128 Python to Isabelle/HOL. Apply: implement key register rotation and S-box application, use round counter for key schedule, rotate key register left by 67 bits. Note: PRESENT is an ultra-lightweight block cipher designed for hardware efficiency.", "input": "def build_keys(key, n):\n    \"\"\"Recursively generate round keys\"\"\"\n    if n == 0:\n        return []\n\n    # uses key_update_128 function for key size =128\n    current_key = (key >> 16) & ((1 << 64) - 1)\n    next_key = key_update_128(key, n)\n    return [current_key] + build_keys(next_key, n - 1)", "output": "fun present_64_128_build_keys :: \"128 word ⇒ nat ⇒ 64 word list\" where\n  \"present_64_128_build_keys key 0 = []\"\n| \"present_64_128_build_keys key (Suc n) = \n    (ucast (present_64_128_word_slice 64 64 key :: 64 word)) # \n    present_64_128_build_keys (present_64_128_key_update key (KEY_SCHEDULE_ROUNDS - n)) n\"", "metadata": {"component_type": "Helper: Recursive Key Building", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "PRESENT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 31, "key_schedule_rounds": 32}, "algorithm_params": {"sbox_count": 16, "block_nibbles": 16, "rotation_bits": 67, "sbox_positions": [124, 120], "counter_position": 62, "counter_mask": 31, "extract_position": 64, "extract_length": 64, "spn_structure": "S-box Layer → Permutation Layer → Add Round Key", "key_structure": "single register", "word_size": 128, "sbox_size": 4, "permutation_type": "bit_permutation"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "table_definition", "function_definition", "key_schedule"], "extraction_time": "2026-01-24T13:11:48.246665"}}
{"instruction": "Translate the SIMECK(48/96) Word_size Constant from Python to Isabelle/HOL. Note: SIMECK is a lightweight Feistel cipher optimized for hardware with 36 rounds.", "input": "# Word size in bits for SIMECK(48/96)\nword_size = 24", "output": "definition simeck_48_96_word_size :: nat where \"simeck_48_96_word_size = 24\"", "metadata": {"component_type": "Word_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.254718", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(48/96) Rounds Constant from Python to Isabelle/HOL. Note: SIMECK uses balanced Feistel network with rotations (5,1) instead of SIMON's (1,8,2).", "input": "# Number of rounds for SIMECK(48/96)\nrounds = 36", "output": "definition simeck_48_96_rounds :: nat where \"simeck_48_96_rounds = 36\"", "metadata": {"component_type": "Rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.254764", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "rotation_constants_5_1"]}}
{"instruction": "Translate the SIMECK(48/96) Block_size Constant from Python to Isabelle/HOL. Note: SIMECK processes 48-bit blocks as two 24-bit halves.", "input": "# 48-bit block size\nblock_size = 48", "output": "definition simeck_48_96_block_size :: nat where \"simeck_48_96_block_size = 48\"", "metadata": {"component_type": "Block_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.254793", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(48/96) Key_size Constant from Python to Isabelle/HOL. Note: Key expansion uses LFSR-generated constants (0xFFFF...FC ⊕ LFSR bit).", "input": "# 96-bit key size\nkey_size = 96", "output": "definition simeck_48_96_key_size :: nat where \"simeck_48_96_key_size = 96\"", "metadata": {"component_type": "Key_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.254826", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(48/96) Key Schedule Constant from Python to Isabelle/HOL. Note: Key expansion uses LFSR-generated constants (0xFFFF...FC ⊕ LFSR bit).", "input": "# Round constant for key schedule (0xFFFF...FC)\nkey_schedule_constant = (1 << 24) - 4", "output": "definition simeck_48_96_key_schedule_constant :: \"24 word\" where\n  \"simeck_48_96_key_schedule_constant = 0xFFFFFC\"", "metadata": {"component_type": "Key Schedule Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.254882", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["recursive_key_expansion", "lfsr_constant_integration"]}}
{"instruction": "Translate the SIMECK(48/96) Round Constants Sequence from Python to Isabelle/HOL. Note: SIMECK-48/96 uses LFSR-generated round constants.", "input": "# Sequence of round constants generated by LFSR\n# Generated by get_sequence() function", "output": "definition simeck_48_96_round_constants_sequence :: \"bool list\" where\n  \"simeck_48_96_round_constants_sequence = simeck_48_96_get_sequence_rec (36 - 5) 0 (replicate 5 True)\"", "metadata": {"component_type": "Round Constants Sequence", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.254921", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "rotation_constants_5_1", "lfsr_generation", "recursive_sequence"]}}
{"instruction": "Translate the SIMECK(48/96) F-Function from Python to Isabelle/HOL. Note: SIMECK F-function: F(x) = (x & (x <<< 5)) ^ (x <<< 1) with 24-bit words.", "input": "def simeck_f_function(x):\n    \"\"\"Simeck F-function: (x & (x <<< 5)) ^ (x <<< 1)\"\"\"\n    word_size=24\n    mask = (1 << 24) - 1\n    # USE | & mask (like Simon)\n    rot5 = ((x << 5) | (x >>  (24 - 5))) & (1 << 24) - 1\n    rot1 = ((x << 1) | (x >>  (24 - 1))) & (1 << 24) - 1\n    return (x & rot5) ^ rot1", "output": "definition simeck_48_96_F_function :: \"24 word \\<Rightarrow> 24 word\" where\n  \"simeck_48_96_F_function x = xor (and x (word_rotl 5 x)) (word_rotl 1 x)\"", "metadata": {"component_type": "F-Function", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.254996", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["and_xor_combination", "dual_rotation_operations"]}}
{"instruction": "Translate the SIMECK(48/96) Encrypt Round from Python to Isabelle/HOL. Note: SIMECK uses balanced Feistel network with rotations (5,1) instead of SIMON's (1,8,2).", "input": "def simeck_round(k, left, right):\n    \"\"\"Simeck round - consistent with Simon syntax\"\"\"\n    word_size=24\n    mask = (1 <<  24) - 1\n    temp = left\n    # USE | & mask (like Simon)\n    rot5 = ((left << 5) | (left >>  (24 - 5))) & (1 <<  24) - 1\n    rot1 = ((left << 1) | (left >>  (24 - 1))) & (1 <<  24) - 1\n    left = right ^ (left & rot5) ^ rot1 ^ k\n    right = temp\n    return left, right", "output": "definition simeck_48_96_encrypt_round :: \"24 word \\<Rightarrow> 24 word \\<times> 24 word \\<Rightarrow> 24 word \\<times> 24 word\" where\n  \"simeck_48_96_encrypt_round k xy = (\n    let (left, right) = xy in \n    (xor (xor (simeck_48_96_F_function left) right) k, left))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.255051", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "rotation_constants_5_1"]}}
{"instruction": "Translate the SIMECK(48/96) Decrypt Round from Python to Isabelle/HOL. Note: SIMECK uses balanced Feistel network with rotations (5,1) instead of SIMON's (1,8,2).", "input": "def simeck_decrypt_round(k, left, right):\n    \"\"\"Simeck Feistel decrypt round (inverse)\"\"\"\n    word_size=24\n    mask = (1 <<  24) - 1\n    \n    # For decryption: right is the F-function input\n    # Use | & mask pattern consistently\n    rot5 = ((right << 5) | (right >>  (24 - 5))) &  (1 <<  24) - 1\n    rot1 = ((right << 1) | (right >>  (24 - 1))) &  (1 <<  24) - 1\n    f_val = (right & rot5) ^ rot1\n\n    # Inverse Feistel\n    new_left = right\n    new_right = left ^ f_val ^ k\n    return new_left, new_right", "output": "definition simeck_48_96_decrypt_round_inverse :: \"24 word \\<Rightarrow> 24 word \\<times> 24 word \\<Rightarrow> 24 word \\<times> 24 word\" where\n  \"simeck_48_96_decrypt_round_inverse k xy_new = (\n    let (left_new, right_new) = xy_new in \n    (right_new, xor (xor left_new k) (simeck_48_96_F_function right_new)))\"", "metadata": {"component_type": "Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.255095", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "rotation_constants_5_1"]}}
{"instruction": "Translate the SIMECK(48/96) Key Schedule Constant from Python to Isabelle/HOL. Note: Key expansion uses LFSR-generated constants (0xFFFF...FC ⊕ LFSR bit).", "input": "key_schedule_constant = (1 <<  {params['word_size']}) - 4  # 0xFFFF...FC", "output": "definition simeck_48_96_key_schedule_constant :: \"24 word\" where\n  \"simeck_48_96_key_schedule_constant = 0xFFFFFC\"", "metadata": {"component_type": "Key Schedule Constant", "difficulty": "easy", "semantic_group": "key_expansion", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.255146", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["recursive_key_expansion", "lfsr_constant_integration"]}}
{"instruction": "Translate the SIMECK(48/96) Key Schedule Recursive from Python to Isabelle/HOL. Note: Key expansion uses LFSR-generated constants (0xFFFF...FC ⊕ LFSR bit).", "input": "def simeck_gen_key_schedule_rec(states, round_constants):\n    \"\"\"Recursive Simeck key schedule - using | & mask pattern\"\"\"\n    word_size=24\n    if not round_constants:\n        return []\n    mask = (1 <<  24) - 1\n    k0 = states[0]\n    left = states[1]\n    right = states[0]\n\n    # Use | & mask pattern\n    rot5 = ((left << 5) | (left >>  (24 - 5))) &  (1 <<  24) - 1\n    rot1 = ((left << 1) | (left >>  (24 - 1))) &  (1 <<  24) - 1\n    f_val = (left & rot5) ^ rot1\n    constant =  ((1 <<  24) - 1) ^ 3  # 0xFFFF...FC\n    new_left = right ^ f_val ^ (constant ^ round_constants[0])\n    new_right = left\n    \n    # Update states and recurse\n    new_states = states[1:] + [new_left]\n    new_states[0] = new_right\n    return [k0] + simeck_gen_key_schedule_rec(new_states, round_constants[1:],  24)", "output": "fun simeck_48_96_gen_key_schedule_rec :: \"24 word list \\<Rightarrow> bool list \\<Rightarrow> 24 word list\" where\n  \"simeck_48_96_gen_key_schedule_rec states [] = []\"\n| \"simeck_48_96_gen_key_schedule_rec states (c#cs) = (\n    let k_0 = states ! 0;\n        left = states ! 1;\n        right = states ! 0;\n        round_const = xor simeck_48_96_key_schedule_constant (if c then 1 else 0);\n        (new_left, new_right) = simeck_48_96_encrypt_round round_const (left, right);\n        new_states = (tl states) @ [new_left]\n    in k_0 # simeck_48_96_gen_key_schedule_rec (new_states[0 := new_right]) cs)\"", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.255210", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["recursive_key_expansion", "lfsr_constant_integration"]}}
{"instruction": "Translate the SIMECK(48/96) Key Schedule Wrapper from Python to Isabelle/HOL. Note: Key expansion uses LFSR-generated constants (0xFFFF...FC ⊕ LFSR bit).", "input": "def simeck_generate_key_schedule(master_key):\n    \"\"\"Generate Simeck round keys from master key\"\"\"\n    word_size=24\n    # Extract m key words from master key\n    states = []\n    for i in range(4):\n        word = master_key & ((1 <<  24) - 1)\n        states.append(word)\n        master_key >>= word_size\n    # Get round constants sequence\n    round_constants = get_round_sequence(36)\n    # Generate keys recursively\n    return simeck_gen_key_schedule_rec(states, round_constants)", "output": "definition simeck_48_96_generate_key_schedule :: \"24 word list \\<Rightarrow> 24 word list\" where\n  \"simeck_48_96_generate_key_schedule initial_keys = \n     simeck_48_96_gen_key_schedule_rec initial_keys simeck_48_96_round_constants_sequence\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.255386", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["recursive_key_expansion", "lfsr_constant_integration"]}}
{"instruction": "Translate the SIMECK(48/96) Sequence Generation Recursive from Python to Isabelle/HOL. Note: LFSR generates round constants: 5-bit (x^5+x^2+1) for <40 rounds, 6-bit (x^6+x+1) otherwise.", "input": "def get_round_sequence(num_rounds= 36):\n    \"\"\"Generate Simeck round constants using LFSR\"\"\"\n    num_rounds= 36\n    if num_rounds < 40:\n        # 5-bit LFSR: x^5 + x^2 + 1\n        states = [1] * 5\n        for i in range(num_rounds - 5):\n            feedback = states[i + 2] ^ states[i]\n            states.append(feedback)\n    else:\n        # 6-bit LFSR: x^6 + x + 1\n        states = [1] * 6\n        for i in range(num_rounds - 6):\n            feedback = states[i + 1] ^ states[i]\n            states.append(feedback)\n    return states", "output": "fun simeck_48_96_get_sequence_rec :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool list \\<Rightarrow> bool list\" where\n  \"simeck_48_96_get_sequence_rec 0 idx states = states\"\n| \"simeck_48_96_get_sequence_rec (Suc n) idx states = (\n    let feedback = (states ! idx) \\<noteq> (states ! (idx + 2))\n    in simeck_48_96_get_sequence_rec n (idx + 1) (states @ [feedback]))\"", "metadata": {"component_type": "Sequence Generation Recursive", "difficulty": "medium", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.255446", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["lfsr_generation", "recursive_sequence"]}}
{"instruction": "Translate the SIMECK(48/96) Round Constants Sequence from Python to Isabelle/HOL. Note: SIMECK-48/96 uses LFSR-generated round constants.", "input": "# Simeck round constants sequence\n# Generated by LFSR with initial state of all ones", "output": "definition simeck_48_96_round_constants_sequence :: \"bool list\" where\n  \"simeck_48_96_round_constants_sequence = simeck_48_96_get_sequence_rec (36 - 5) 0 (replicate 5 True)\"", "metadata": {"component_type": "Round Constants Sequence", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.255480", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "rotation_constants_5_1", "lfsr_generation", "recursive_sequence"]}}
{"instruction": "Translate the SIMECK(48/96) Encrypt Iteration from Python to Isabelle/HOL. Note: SIMECK applies 36 Feistel rounds in encryption/decryption.", "input": "def simeck_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply Simeck Feistel rounds for encryption\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    left, right = state\n    k = key_schedule[round_idx]\n    # Apply one round\n    new_left, new_right = simeck_encrypt_round(\n        k, left, right,\n        24,\n        (1 << 24) - 1\n    )\n    # Recursive call for next round\n    return simeck_encrypt_iterate((new_left, new_right), key_schedule, round_idx + 1)", "output": "fun simeck_48_96_encrypt_iterate :: \"24 word \\<times> 24 word \\<Rightarrow> 24 word list \\<Rightarrow> 24 word \\<times> 24 word\" where\n  \"simeck_48_96_encrypt_iterate state [] = state\"\n| \"simeck_48_96_encrypt_iterate state (k#ks) = simeck_48_96_encrypt_iterate (simeck_48_96_encrypt_round k state) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.255543", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(48/96) Decrypt Iteration from Python to Isabelle/HOL. Note: SIMECK applies 36 Feistel rounds in encryption/decryption.", "input": "def simeck_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply Simeck Feistel rounds for decryption (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    if round_idx < 0:\n        return state\n    left, right = state\n    k = key_schedule[round_idx]\n    # Apply one inverse round\n    new_left, new_right = simeck_decrypt_round(\n        k, left, right,\n        24,\n        (1 << 24) - 1\n    )\n    # Recursive call for previous round\n    return simeck_decrypt_iterate((new_left, new_right), key_schedule, round_idx - 1)", "output": "fun simeck_48_96_decrypt_iterate :: \"24 word \\<times> 24 word \\<Rightarrow> 24 word list \\<Rightarrow> 24 word \\<times> 24 word\" where\n  \"simeck_48_96_decrypt_iterate state ks = foldl (\\<lambda>st_new k. simeck_48_96_decrypt_round_inverse k st_new) state (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.255584", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(48/96) Encrypt Block from Python to Isabelle/HOL. Note: SIMECK processes 48-bit blocks as two 24-bit halves.", "input": "def simeck_encrypt_block(plaintext, key_schedule):\n        \"\"\"SIMECK block encryption\"\"\"\n        # Split into left and right halves\n        mask = (1 << 24) - 1\n        left = (plaintext >> 24) &  (1 <<  24) - 1\n        right = plaintext &  (1 <<  24) - 1\n        # Apply all rounds\n        cipher_left, cipher_right = simeck_encrypt_iterate(\n            (left, right),\n            key_schedule\n        )\n        # Combine back\n        return (cipher_left << 24) | cipher_right", "output": "definition simeck_48_96_encrypt_block :: \"24 word \\<times> 24 word \\<Rightarrow> 24 word list \\<Rightarrow> 24 word \\<times> 24 word\" where\n  \"simeck_48_96_encrypt_block plaintext keys = simeck_48_96_encrypt_iterate plaintext keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.255648", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(48/96) Decrypt Block from Python to Isabelle/HOL. Note: SIMECK processes 48-bit blocks as two 24-bit halves.", "input": "def simeck_decrypt_block(ciphertext, key_schedule):\n        \"\"\"SIMECK block decryption\"\"\"\n        # Split into left and right halves\n        mask = (1 << 24) - 1\n        left = (ciphertext >> 24) &  (1 <<  24) - 1\n        right = ciphertext &  (1 <<  24) - 1\n        # Apply all inverse rounds\n        plain_left, plain_right = simeck_decrypt_iterate(\n            (left, right),\n            key_schedule\n        )\n        # Combine back\n\n        return (plain_left << 24) | plain_right", "output": "definition simeck_48_96_decrypt_block :: \"24 word \\<times> 24 word \\<Rightarrow> 24 word list \\<Rightarrow> 24 word \\<times> 24 word\" where\n  \"simeck_48_96_decrypt_block ciphertext keys = simeck_48_96_decrypt_iterate ciphertext keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.255691", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(48/96) Top-Level Encrypt from Python to Isabelle/HOL. Note: SIMECK is a lightweight Feistel cipher optimized for hardware with 36 rounds.", "input": "def simeck_encrypt(plaintext, master_key):\n    \"\"\"Top-level SIMECK encryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simeck_generate_key_schedule(master_key)\n    # Encrypt block\n    return simeck_encrypt_block(plaintext, key_schedule)", "output": "definition simeck_48_96_encrypt :: \"48 word \\<Rightarrow> 24 word list \\<Rightarrow> 48 word\" where\n  \"simeck_48_96_encrypt plaintext keys = (\n    let left = ucast (drop_bit 24 plaintext);\n        right = ucast plaintext;\n        (c_left, c_right) = simeck_48_96_encrypt_block (left, right) keys\n    in or (push_bit 24 (ucast c_left)) (ucast c_right))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.256024", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(48/96) Top-Level Decrypt from Python to Isabelle/HOL. Note: SIMECK is a lightweight Feistel cipher optimized for hardware with 36 rounds.", "input": "def simeck_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SIMECK decryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simeck_generate_key_schedule(master_key)\n    # Decrypt block\n    return simeck_decrypt_block(ciphertext, key_schedule)", "output": "definition simeck_48_96_decrypt :: \"48 word \\<Rightarrow> 24 word list \\<Rightarrow> 48 word\" where\n  \"simeck_48_96_decrypt ciphertext keys = (\n    let left = ucast (drop_bit 24 ciphertext);\n        right = ucast ciphertext;\n        (p_left, p_right) = simeck_48_96_decrypt_block (left, right) keys\n    in or (push_bit 24 (ucast p_left)) (ucast p_right))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.256059", "variant": {"block_size": 48, "key_size": 96, "word_size": 24, "rounds": 36, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(32/64) Word_size Constant from Python to Isabelle/HOL. Note: SIMECK is a lightweight Feistel cipher optimized for hardware with 32 rounds.", "input": "# Word size in bits for SIMECK(32/64)\nword_size = 16", "output": "definition simeck_32_64_word_size :: nat where \"simeck_32_64_word_size = 16\"", "metadata": {"component_type": "Word_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.257816", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(32/64) Rounds Constant from Python to Isabelle/HOL. Note: SIMECK uses balanced Feistel network with rotations (5,1) instead of SIMON's (1,8,2).", "input": "# Number of rounds for SIMECK(32/64)\nrounds = 32", "output": "definition simeck_32_64_rounds :: nat where \"simeck_32_64_rounds = 32\"", "metadata": {"component_type": "Rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.257869", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "rotation_constants_5_1"]}}
{"instruction": "Translate the SIMECK(32/64) Block_size Constant from Python to Isabelle/HOL. Note: SIMECK processes 32-bit blocks as two 16-bit halves.", "input": "# 32-bit block size\nblock_size = 32", "output": "definition simeck_32_64_block_size :: nat where \"simeck_32_64_block_size = 32\"", "metadata": {"component_type": "Block_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.257898", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(32/64) Key_size Constant from Python to Isabelle/HOL. Note: Key expansion uses LFSR-generated constants (0xFFFF...FC ⊕ LFSR bit).", "input": "# 64-bit key size\nkey_size = 64", "output": "definition simeck_32_64_key_size :: nat where \"simeck_32_64_key_size = 64\"", "metadata": {"component_type": "Key_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.257926", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(32/64) Key Schedule Constant from Python to Isabelle/HOL. Note: Key expansion uses LFSR-generated constants (0xFFFF...FC ⊕ LFSR bit).", "input": "# Round constant for key schedule (0xFFFF...FC)\nkey_schedule_constant = (1 << 16) - 4", "output": "definition simeck_32_64_key_schedule_constant :: \"16 word\" where\n  \"simeck_32_64_key_schedule_constant = 0xFFFC\"", "metadata": {"component_type": "Key Schedule Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.257974", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["recursive_key_expansion", "lfsr_constant_integration"]}}
{"instruction": "Translate the SIMECK(32/64) Round Constants Sequence from Python to Isabelle/HOL. Note: SIMECK-32/64 uses LFSR-generated round constants.", "input": "# Sequence of round constants generated by LFSR\n# Generated by get_sequence() function", "output": "definition simeck_32_64_round_constants_sequence :: \"bool list\" where\n  \"simeck_32_64_round_constants_sequence = simeck_32_64_get_sequence_rec (32 - 5) 0 (replicate 5 True)\"", "metadata": {"component_type": "Round Constants Sequence", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.258012", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "rotation_constants_5_1", "lfsr_generation", "recursive_sequence"]}}
{"instruction": "Translate the SIMECK(32/64) F-Function from Python to Isabelle/HOL. Note: SIMECK F-function: F(x) = (x & (x <<< 5)) ^ (x <<< 1) with 16-bit words.", "input": "def simeck_f_function(x):\n    \"\"\"Simeck F-function: (x & (x <<< 5)) ^ (x <<< 1)\"\"\"\n    word_size=16\n    mask = (1 << 16) - 1\n    # USE | & mask (like Simon)\n    rot5 = ((x << 5) | (x >>  (16 - 5))) & (1 << 16) - 1\n    rot1 = ((x << 1) | (x >>  (16 - 1))) & (1 << 16) - 1\n    return (x & rot5) ^ rot1", "output": "definition simeck_32_64_F_function :: \"16 word \\<Rightarrow> 16 word\" where\n  \"simeck_32_64_F_function x = xor (and x (word_rotl 5 x)) (word_rotl 1 x)\"", "metadata": {"component_type": "F-Function", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.258065", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["and_xor_combination", "dual_rotation_operations"]}}
{"instruction": "Translate the SIMECK(32/64) Encrypt Round from Python to Isabelle/HOL. Note: SIMECK uses balanced Feistel network with rotations (5,1) instead of SIMON's (1,8,2).", "input": "def simeck_round(k, left, right):\n    \"\"\"Simeck round - consistent with Simon syntax\"\"\"\n    word_size=16\n    mask = (1 <<  16) - 1\n    temp = left\n    # USE | & mask (like Simon)\n    rot5 = ((left << 5) | (left >>  (16 - 5))) & (1 <<  16) - 1\n    rot1 = ((left << 1) | (left >>  (16 - 1))) & (1 <<  16) - 1\n    left = right ^ (left & rot5) ^ rot1 ^ k\n    right = temp\n    return left, right", "output": "definition simeck_32_64_encrypt_round :: \"16 word \\<Rightarrow> 16 word \\<times> 16 word \\<Rightarrow> 16 word \\<times> 16 word\" where\n  \"simeck_32_64_encrypt_round k xy = (\n    let (left, right) = xy in \n    (xor (xor (simeck_32_64_F_function left) right) k, left))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.258122", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "rotation_constants_5_1"]}}
{"instruction": "Translate the SIMECK(32/64) Decrypt Round from Python to Isabelle/HOL. Note: SIMECK uses balanced Feistel network with rotations (5,1) instead of SIMON's (1,8,2).", "input": "def simeck_decrypt_round(k, left, right):\n    \"\"\"Simeck Feistel decrypt round (inverse)\"\"\"\n    word_size=16\n    mask = (1 <<  16) - 1\n    \n    # For decryption: right is the F-function input\n    # Use | & mask pattern consistently\n    rot5 = ((right << 5) | (right >>  (16 - 5))) &  (1 <<  16) - 1\n    rot1 = ((right << 1) | (right >>  (16 - 1))) &  (1 <<  16) - 1\n    f_val = (right & rot5) ^ rot1\n\n    # Inverse Feistel\n    new_left = right\n    new_right = left ^ f_val ^ k\n    return new_left, new_right", "output": "definition simeck_32_64_decrypt_round_inverse :: \"16 word \\<Rightarrow> 16 word \\<times> 16 word \\<Rightarrow> 16 word \\<times> 16 word\" where\n  \"simeck_32_64_decrypt_round_inverse k xy_new = (\n    let (left_new, right_new) = xy_new in \n    (right_new, xor (xor left_new k) (simeck_32_64_F_function right_new)))\"", "metadata": {"component_type": "Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.258167", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "rotation_constants_5_1"]}}
{"instruction": "Translate the SIMECK(32/64) Key Schedule Constant from Python to Isabelle/HOL. Note: Key expansion uses LFSR-generated constants (0xFFFF...FC ⊕ LFSR bit).", "input": "key_schedule_constant = (1 <<  {params['word_size']}) - 4  # 0xFFFF...FC", "output": "definition simeck_32_64_key_schedule_constant :: \"16 word\" where\n  \"simeck_32_64_key_schedule_constant = 0xFFFC\"", "metadata": {"component_type": "Key Schedule Constant", "difficulty": "easy", "semantic_group": "key_expansion", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.258216", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["recursive_key_expansion", "lfsr_constant_integration"]}}
{"instruction": "Translate the SIMECK(32/64) Key Schedule Recursive from Python to Isabelle/HOL. Note: Key expansion uses LFSR-generated constants (0xFFFF...FC ⊕ LFSR bit).", "input": "def simeck_gen_key_schedule_rec(states, round_constants):\n    \"\"\"Recursive Simeck key schedule - using | & mask pattern\"\"\"\n    word_size=16\n    if not round_constants:\n        return []\n    mask = (1 <<  16) - 1\n    k0 = states[0]\n    left = states[1]\n    right = states[0]\n\n    # Use | & mask pattern\n    rot5 = ((left << 5) | (left >>  (16 - 5))) &  (1 <<  16) - 1\n    rot1 = ((left << 1) | (left >>  (16 - 1))) &  (1 <<  16) - 1\n    f_val = (left & rot5) ^ rot1\n    constant =  ((1 <<  16) - 1) ^ 3  # 0xFFFF...FC\n    new_left = right ^ f_val ^ (constant ^ round_constants[0])\n    new_right = left\n    \n    # Update states and recurse\n    new_states = states[1:] + [new_left]\n    new_states[0] = new_right\n    return [k0] + simeck_gen_key_schedule_rec(new_states, round_constants[1:],  16)", "output": "fun simeck_32_64_gen_key_schedule_rec :: \"16 word list \\<Rightarrow> bool list \\<Rightarrow> 16 word list\" where\n  \"simeck_32_64_gen_key_schedule_rec states [] = []\"\n| \"simeck_32_64_gen_key_schedule_rec states (c#cs) = (\n    let k_0 = states ! 0;\n        left = states ! 1;\n        right = states ! 0;\n        round_const = xor simeck_32_64_key_schedule_constant (if c then 1 else 0);\n        (new_left, new_right) = simeck_32_64_encrypt_round round_const (left, right);\n        new_states = (tl states) @ [new_left]\n    in k_0 # simeck_32_64_gen_key_schedule_rec (new_states[0 := new_right]) cs)\"", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.258269", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["recursive_key_expansion", "lfsr_constant_integration"]}}
{"instruction": "Translate the SIMECK(32/64) Key Schedule Wrapper from Python to Isabelle/HOL. Note: Key expansion uses LFSR-generated constants (0xFFFF...FC ⊕ LFSR bit).", "input": "def simeck_generate_key_schedule(master_key):\n    \"\"\"Generate Simeck round keys from master key\"\"\"\n    word_size=16\n    # Extract m key words from master key\n    states = []\n    for i in range(4):\n        word = master_key & ((1 <<  16) - 1)\n        states.append(word)\n        master_key >>= word_size\n    # Get round constants sequence\n    round_constants = get_round_sequence(32)\n    # Generate keys recursively\n    return simeck_gen_key_schedule_rec(states, round_constants)", "output": "definition simeck_32_64_generate_key_schedule :: \"16 word list \\<Rightarrow> 16 word list\" where\n  \"simeck_32_64_generate_key_schedule initial_keys = \n     simeck_32_64_gen_key_schedule_rec initial_keys simeck_32_64_round_constants_sequence\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.258316", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["recursive_key_expansion", "lfsr_constant_integration"]}}
{"instruction": "Translate the SIMECK(32/64) Sequence Generation Recursive from Python to Isabelle/HOL. Note: LFSR generates round constants: 5-bit (x^5+x^2+1) for <40 rounds, 6-bit (x^6+x+1) otherwise.", "input": "def get_round_sequence(num_rounds= 32):\n    \"\"\"Generate Simeck round constants using LFSR\"\"\"\n    num_rounds= 32\n    if num_rounds < 40:\n        # 5-bit LFSR: x^5 + x^2 + 1\n        states = [1] * 5\n        for i in range(num_rounds - 5):\n            feedback = states[i + 2] ^ states[i]\n            states.append(feedback)\n    else:\n        # 6-bit LFSR: x^6 + x + 1\n        states = [1] * 6\n        for i in range(num_rounds - 6):\n            feedback = states[i + 1] ^ states[i]\n            states.append(feedback)\n    return states", "output": "fun simeck_32_64_get_sequence_rec :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool list \\<Rightarrow> bool list\" where\n  \"simeck_32_64_get_sequence_rec 0 idx states = states\"\n| \"simeck_32_64_get_sequence_rec (Suc n) idx states = (\n    let feedback = (states ! idx) \\<noteq> (states ! (idx + 2))\n    in simeck_32_64_get_sequence_rec n (idx + 1) (states @ [feedback]))\"", "metadata": {"component_type": "Sequence Generation Recursive", "difficulty": "medium", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.258366", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["lfsr_generation", "recursive_sequence"]}}
{"instruction": "Translate the SIMECK(32/64) Round Constants Sequence from Python to Isabelle/HOL. Note: SIMECK-32/64 uses LFSR-generated round constants.", "input": "# Simeck round constants sequence\n# Generated by LFSR with initial state of all ones", "output": "definition simeck_32_64_round_constants_sequence :: \"bool list\" where\n  \"simeck_32_64_round_constants_sequence = simeck_32_64_get_sequence_rec (32 - 5) 0 (replicate 5 True)\"", "metadata": {"component_type": "Round Constants Sequence", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.258398", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "rotation_constants_5_1", "lfsr_generation", "recursive_sequence"]}}
{"instruction": "Translate the SIMECK(32/64) Encrypt Iteration from Python to Isabelle/HOL. Note: SIMECK applies 32 Feistel rounds in encryption/decryption.", "input": "def simeck_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply Simeck Feistel rounds for encryption\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    left, right = state\n    k = key_schedule[round_idx]\n    # Apply one round\n    new_left, new_right = simeck_encrypt_round(\n        k, left, right,\n        16,\n        (1 << 16) - 1\n    )\n    # Recursive call for next round\n    return simeck_encrypt_iterate((new_left, new_right), key_schedule, round_idx + 1)", "output": "fun simeck_32_64_encrypt_iterate :: \"16 word \\<times> 16 word \\<Rightarrow> 16 word list \\<Rightarrow> 16 word \\<times> 16 word\" where\n  \"simeck_32_64_encrypt_iterate state [] = state\"\n| \"simeck_32_64_encrypt_iterate state (k#ks) = simeck_32_64_encrypt_iterate (simeck_32_64_encrypt_round k state) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.258448", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(32/64) Decrypt Iteration from Python to Isabelle/HOL. Note: SIMECK applies 32 Feistel rounds in encryption/decryption.", "input": "def simeck_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply Simeck Feistel rounds for decryption (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    if round_idx < 0:\n        return state\n    left, right = state\n    k = key_schedule[round_idx]\n    # Apply one inverse round\n    new_left, new_right = simeck_decrypt_round(\n        k, left, right,\n        16,\n        (1 << 16) - 1\n    )\n    # Recursive call for previous round\n    return simeck_decrypt_iterate((new_left, new_right), key_schedule, round_idx - 1)", "output": "fun simeck_32_64_decrypt_iterate :: \"16 word \\<times> 16 word \\<Rightarrow> 16 word list \\<Rightarrow> 16 word \\<times> 16 word\" where\n  \"simeck_32_64_decrypt_iterate state ks = foldl (\\<lambda>st_new k. simeck_32_64_decrypt_round_inverse k st_new) state (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.258493", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(32/64) Encrypt Block from Python to Isabelle/HOL. Note: SIMECK processes 32-bit blocks as two 16-bit halves.", "input": "def simeck_encrypt_block(plaintext, key_schedule):\n        \"\"\"SIMECK block encryption\"\"\"\n        # Split into left and right halves\n        mask = (1 << 16) - 1\n        left = (plaintext >> 16) &  (1 <<  16) - 1\n        right = plaintext &  (1 <<  16) - 1\n        # Apply all rounds\n        cipher_left, cipher_right = simeck_encrypt_iterate(\n            (left, right),\n            key_schedule\n        )\n        # Combine back\n        return (cipher_left << 16) | cipher_right", "output": "definition simeck_32_64_encrypt_block :: \"16 word \\<times> 16 word \\<Rightarrow> 16 word list \\<Rightarrow> 16 word \\<times> 16 word\" where\n  \"simeck_32_64_encrypt_block plaintext keys = simeck_32_64_encrypt_iterate plaintext keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.258558", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(32/64) Decrypt Block from Python to Isabelle/HOL. Note: SIMECK processes 32-bit blocks as two 16-bit halves.", "input": "def simeck_decrypt_block(ciphertext, key_schedule):\n        \"\"\"SIMECK block decryption\"\"\"\n        # Split into left and right halves\n        mask = (1 << 16) - 1\n        left = (ciphertext >> 16) &  (1 <<  16) - 1\n        right = ciphertext &  (1 <<  16) - 1\n        # Apply all inverse rounds\n        plain_left, plain_right = simeck_decrypt_iterate(\n            (left, right),\n            key_schedule\n        )\n        # Combine back\n\n        return (plain_left << 16) | plain_right", "output": "definition simeck_32_64_decrypt_block :: \"16 word \\<times> 16 word \\<Rightarrow> 16 word list \\<Rightarrow> 16 word \\<times> 16 word\" where\n  \"simeck_32_64_decrypt_block ciphertext keys = simeck_32_64_decrypt_iterate ciphertext keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.258608", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(32/64) Top-Level Encrypt from Python to Isabelle/HOL. Note: SIMECK is a lightweight Feistel cipher optimized for hardware with 32 rounds.", "input": "def simeck_encrypt(plaintext, master_key):\n    \"\"\"Top-level SIMECK encryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simeck_generate_key_schedule(master_key)\n    # Encrypt block\n    return simeck_encrypt_block(plaintext, key_schedule)", "output": "definition simeck_32_64_encrypt :: \"32 word \\<Rightarrow> 16 word list \\<Rightarrow> 32 word\" where\n  \"simeck_32_64_encrypt plaintext keys = (\n    let left = ucast (drop_bit 16 plaintext);\n        right = ucast plaintext;\n        (c_left, c_right) = simeck_32_64_encrypt_block (left, right) keys\n    in or (push_bit 16 (ucast c_left)) (ucast c_right))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.258885", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(32/64) Top-Level Decrypt from Python to Isabelle/HOL. Note: SIMECK is a lightweight Feistel cipher optimized for hardware with 32 rounds.", "input": "def simeck_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SIMECK decryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simeck_generate_key_schedule(master_key)\n    # Decrypt block\n    return simeck_decrypt_block(ciphertext, key_schedule)", "output": "definition simeck_32_64_decrypt :: \"32 word \\<Rightarrow> 16 word list \\<Rightarrow> 32 word\" where\n  \"simeck_32_64_decrypt ciphertext keys = (\n    let left = ucast (drop_bit 16 ciphertext);\n        right = ucast ciphertext;\n        (p_left, p_right) = simeck_32_64_decrypt_block (left, right) keys\n    in or (push_bit 16 (ucast p_left)) (ucast p_right))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.258909", "variant": {"block_size": 32, "key_size": 64, "word_size": 16, "rounds": 32, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(64/128) Word_size Constant from Python to Isabelle/HOL. Note: SIMECK is a lightweight Feistel cipher optimized for hardware with 44 rounds.", "input": "# Word size in bits for SIMECK(64/128)\nword_size = 32", "output": "definition simeck_64_128_word_size :: nat where \"simeck_64_128_word_size = 32\"", "metadata": {"component_type": "Word_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.259931", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(64/128) Rounds Constant from Python to Isabelle/HOL. Note: SIMECK uses balanced Feistel network with rotations (5,1) instead of SIMON's (1,8,2).", "input": "# Number of rounds for SIMECK(64/128)\nrounds = 44", "output": "definition simeck_64_128_rounds :: nat where \"simeck_64_128_rounds = 44\"", "metadata": {"component_type": "Rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.259978", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "rotation_constants_5_1"]}}
{"instruction": "Translate the SIMECK(64/128) Block_size Constant from Python to Isabelle/HOL. Note: SIMECK processes 64-bit blocks as two 32-bit halves.", "input": "# 64-bit block size\nblock_size = 64", "output": "definition simeck_64_128_block_size :: nat where \"simeck_64_128_block_size = 64\"", "metadata": {"component_type": "Block_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.260009", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(64/128) Key_size Constant from Python to Isabelle/HOL. Note: Key expansion uses LFSR-generated constants (0xFFFF...FC ⊕ LFSR bit).", "input": "# 128-bit key size\nkey_size = 128", "output": "definition simeck_64_128_key_size :: nat where \"simeck_64_128_key_size = 128\"", "metadata": {"component_type": "Key_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.260038", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(64/128) Key Schedule Constant from Python to Isabelle/HOL. Note: Key expansion uses LFSR-generated constants (0xFFFF...FC ⊕ LFSR bit).", "input": "# Round constant for key schedule (0xFFFF...FC)\nkey_schedule_constant = (1 << 32) - 4", "output": "definition simeck_64_128_key_schedule_constant :: \"32 word\" where\n  \"simeck_64_128_key_schedule_constant = 0xFFFFFFFC\"", "metadata": {"component_type": "Key Schedule Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.260094", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["recursive_key_expansion", "lfsr_constant_integration"]}}
{"instruction": "Translate the SIMECK(64/128) Round Constants Sequence from Python to Isabelle/HOL. Note: SIMECK-64/128 uses LFSR-generated round constants.", "input": "# Sequence of round constants generated by LFSR\n# Generated by get_sequence() function", "output": "definition simeck_64_128_round_constants_sequence :: \"bool list\" where\n  \"simeck_64_128_round_constants_sequence = simeck_64_128_get_sequence_rec (44 - 6) 0 (replicate 6 True)\"", "metadata": {"component_type": "Round Constants Sequence", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.260156", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "rotation_constants_5_1", "lfsr_generation", "recursive_sequence"]}}
{"instruction": "Translate the SIMECK(64/128) F-Function from Python to Isabelle/HOL. Note: SIMECK F-function: F(x) = (x & (x <<< 5)) ^ (x <<< 1) with 32-bit words.", "input": "def simeck_f_function(x):\n    \"\"\"Simeck F-function: (x & (x <<< 5)) ^ (x <<< 1)\"\"\"\n    word_size=32\n    mask = (1 << 32) - 1\n    # USE | & mask (like Simon)\n    rot5 = ((x << 5) | (x >>  (32 - 5))) & (1 << 32) - 1\n    rot1 = ((x << 1) | (x >>  (32 - 1))) & (1 << 32) - 1\n    return (x & rot5) ^ rot1", "output": "definition simeck_64_128_F_function :: \"32 word \\<Rightarrow> 32 word\" where\n  \"simeck_64_128_F_function x = xor (and x (word_rotl 5 x)) (word_rotl 1 x)\"", "metadata": {"component_type": "F-Function", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.260229", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["and_xor_combination", "dual_rotation_operations"]}}
{"instruction": "Translate the SIMECK(64/128) Encrypt Round from Python to Isabelle/HOL. Note: SIMECK uses balanced Feistel network with rotations (5,1) instead of SIMON's (1,8,2).", "input": "def simeck_round(k, left, right):\n    \"\"\"Simeck round - consistent with Simon syntax\"\"\"\n    word_size=32\n    mask = (1 <<  32) - 1\n    temp = left\n    # USE | & mask (like Simon)\n    rot5 = ((left << 5) | (left >>  (32 - 5))) & (1 <<  32) - 1\n    rot1 = ((left << 1) | (left >>  (32 - 1))) & (1 <<  32) - 1\n    left = right ^ (left & rot5) ^ rot1 ^ k\n    right = temp\n    return left, right", "output": "definition simeck_64_128_encrypt_round :: \"32 word \\<Rightarrow> 32 word \\<times> 32 word \\<Rightarrow> 32 word \\<times> 32 word\" where\n  \"simeck_64_128_encrypt_round k xy = (\n    let (left, right) = xy in \n    (xor (xor (simeck_64_128_F_function left) right) k, left))\"", "metadata": {"component_type": "Encrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.260285", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "rotation_constants_5_1"]}}
{"instruction": "Translate the SIMECK(64/128) Decrypt Round from Python to Isabelle/HOL. Note: SIMECK uses balanced Feistel network with rotations (5,1) instead of SIMON's (1,8,2).", "input": "def simeck_decrypt_round(k, left, right):\n    \"\"\"Simeck Feistel decrypt round (inverse)\"\"\"\n    word_size=32\n    mask = (1 <<  32) - 1\n    \n    # For decryption: right is the F-function input\n    # Use | & mask pattern consistently\n    rot5 = ((right << 5) | (right >>  (32 - 5))) &  (1 <<  32) - 1\n    rot1 = ((right << 1) | (right >>  (32 - 1))) &  (1 <<  32) - 1\n    f_val = (right & rot5) ^ rot1\n\n    # Inverse Feistel\n    new_left = right\n    new_right = left ^ f_val ^ k\n    return new_left, new_right", "output": "definition simeck_64_128_decrypt_round_inverse :: \"32 word \\<Rightarrow> 32 word \\<times> 32 word \\<Rightarrow> 32 word \\<times> 32 word\" where\n  \"simeck_64_128_decrypt_round_inverse k xy_new = (\n    let (left_new, right_new) = xy_new in \n    (right_new, xor (xor left_new k) (simeck_64_128_F_function right_new)))\"", "metadata": {"component_type": "Decrypt Round", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.260329", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "rotation_constants_5_1"]}}
{"instruction": "Translate the SIMECK(64/128) Key Schedule Constant from Python to Isabelle/HOL. Note: Key expansion uses LFSR-generated constants (0xFFFF...FC ⊕ LFSR bit).", "input": "key_schedule_constant = (1 <<  {params['word_size']}) - 4  # 0xFFFF...FC", "output": "definition simeck_64_128_key_schedule_constant :: \"32 word\" where\n  \"simeck_64_128_key_schedule_constant = 0xFFFFFFFC\"", "metadata": {"component_type": "Key Schedule Constant", "difficulty": "easy", "semantic_group": "key_expansion", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.260423", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["recursive_key_expansion", "lfsr_constant_integration"]}}
{"instruction": "Translate the SIMECK(64/128) Key Schedule Recursive from Python to Isabelle/HOL. Note: Key expansion uses LFSR-generated constants (0xFFFF...FC ⊕ LFSR bit).", "input": "def simeck_gen_key_schedule_rec(states, round_constants):\n    \"\"\"Recursive Simeck key schedule - using | & mask pattern\"\"\"\n    word_size=32\n    if not round_constants:\n        return []\n    mask = (1 <<  32) - 1\n    k0 = states[0]\n    left = states[1]\n    right = states[0]\n\n    # Use | & mask pattern\n    rot5 = ((left << 5) | (left >>  (32 - 5))) &  (1 <<  32) - 1\n    rot1 = ((left << 1) | (left >>  (32 - 1))) &  (1 <<  32) - 1\n    f_val = (left & rot5) ^ rot1\n    constant =  ((1 <<  32) - 1) ^ 3  # 0xFFFF...FC\n    new_left = right ^ f_val ^ (constant ^ round_constants[0])\n    new_right = left\n    \n    # Update states and recurse\n    new_states = states[1:] + [new_left]\n    new_states[0] = new_right\n    return [k0] + simeck_gen_key_schedule_rec(new_states, round_constants[1:],  32)", "output": "fun simeck_64_128_gen_key_schedule_rec :: \"32 word list \\<Rightarrow> bool list \\<Rightarrow> 32 word list\" where\n  \"simeck_64_128_gen_key_schedule_rec states [] = []\"\n| \"simeck_64_128_gen_key_schedule_rec states (c#cs) = (\n    let k_0 = states ! 0;\n        left = states ! 1;\n        right = states ! 0;\n        round_const = xor simeck_64_128_key_schedule_constant (if c then 1 else 0);\n        (new_left, new_right) = simeck_64_128_encrypt_round round_const (left, right);\n        new_states = (tl states) @ [new_left]\n    in k_0 # simeck_64_128_gen_key_schedule_rec (new_states[0 := new_right]) cs)\"", "metadata": {"component_type": "Key Schedule Recursive", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.260474", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["recursive_key_expansion", "lfsr_constant_integration"]}}
{"instruction": "Translate the SIMECK(64/128) Key Schedule Wrapper from Python to Isabelle/HOL. Note: Key expansion uses LFSR-generated constants (0xFFFF...FC ⊕ LFSR bit).", "input": "def simeck_generate_key_schedule(master_key):\n    \"\"\"Generate Simeck round keys from master key\"\"\"\n    word_size=32\n    # Extract m key words from master key\n    states = []\n    for i in range(4):\n        word = master_key & ((1 <<  32) - 1)\n        states.append(word)\n        master_key >>= word_size\n    # Get round constants sequence\n    round_constants = get_round_sequence(44)\n    # Generate keys recursively\n    return simeck_gen_key_schedule_rec(states, round_constants)", "output": "definition simeck_64_128_generate_key_schedule :: \"32 word list \\<Rightarrow> 32 word list\" where\n  \"simeck_64_128_generate_key_schedule initial_keys = \n     simeck_64_128_gen_key_schedule_rec initial_keys simeck_64_128_round_constants_sequence\"", "metadata": {"component_type": "Key Schedule Wrapper", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.260516", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["recursive_key_expansion", "lfsr_constant_integration"]}}
{"instruction": "Translate the SIMECK(64/128) Sequence Generation Recursive from Python to Isabelle/HOL. Note: LFSR generates round constants: 5-bit (x^5+x^2+1) for <40 rounds, 6-bit (x^6+x+1) otherwise.", "input": "def get_round_sequence(num_rounds= 44):\n    \"\"\"Generate Simeck round constants using LFSR\"\"\"\n    num_rounds= 44\n    if num_rounds < 40:\n        # 5-bit LFSR: x^5 + x^2 + 1\n        states = [1] * 5\n        for i in range(num_rounds - 5):\n            feedback = states[i + 2] ^ states[i]\n            states.append(feedback)\n    else:\n        # 6-bit LFSR: x^6 + x + 1\n        states = [1] * 6\n        for i in range(num_rounds - 6):\n            feedback = states[i + 1] ^ states[i]\n            states.append(feedback)\n    return states", "output": "fun simeck_64_128_get_sequence_rec :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool list \\<Rightarrow> bool list\" where\n  \"simeck_64_128_get_sequence_rec 0 idx states = states\"\n| \"simeck_64_128_get_sequence_rec (Suc n) idx states = (\n    let feedback = (states ! idx) \\<noteq> (states ! (idx + 1))\n    in simeck_64_128_get_sequence_rec n (idx + 1) (states @ [feedback]))\"", "metadata": {"component_type": "Sequence Generation Recursive", "difficulty": "medium", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.260570", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["lfsr_generation", "recursive_sequence"]}}
{"instruction": "Translate the SIMECK(64/128) Round Constants Sequence from Python to Isabelle/HOL. Note: SIMECK-64/128 uses LFSR-generated round constants.", "input": "# Simeck round constants sequence\n# Generated by LFSR with initial state of all ones", "output": "definition simeck_64_128_round_constants_sequence :: \"bool list\" where\n  \"simeck_64_128_round_constants_sequence = simeck_64_128_get_sequence_rec (44 - 6) 0 (replicate 6 True)\"", "metadata": {"component_type": "Round Constants Sequence", "difficulty": "easy", "semantic_group": "constants", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.260610", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": ["feistel_structure", "word_halves_swap", "rotation_constants_5_1", "lfsr_generation", "recursive_sequence"]}}
{"instruction": "Translate the SIMECK(64/128) Encrypt Iteration from Python to Isabelle/HOL. Note: SIMECK applies 44 Feistel rounds in encryption/decryption.", "input": "def simeck_encrypt_iterate(state, key_schedule, round_idx=0):\n    \"\"\"Recursively apply Simeck Feistel rounds for encryption\"\"\"\n    if round_idx >= len(key_schedule):\n        return state\n    left, right = state\n    k = key_schedule[round_idx]\n    # Apply one round\n    new_left, new_right = simeck_encrypt_round(\n        k, left, right,\n        32,\n        (1 << 32) - 1\n    )\n    # Recursive call for next round\n    return simeck_encrypt_iterate((new_left, new_right), key_schedule, round_idx + 1)", "output": "fun simeck_64_128_encrypt_iterate :: \"32 word \\<times> 32 word \\<Rightarrow> 32 word list \\<Rightarrow> 32 word \\<times> 32 word\" where\n  \"simeck_64_128_encrypt_iterate state [] = state\"\n| \"simeck_64_128_encrypt_iterate state (k#ks) = simeck_64_128_encrypt_iterate (simeck_64_128_encrypt_round k state) ks\"", "metadata": {"component_type": "Encrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.260661", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(64/128) Decrypt Iteration from Python to Isabelle/HOL. Note: SIMECK applies 44 Feistel rounds in encryption/decryption.", "input": "def simeck_decrypt_iterate(state, key_schedule, round_idx=None):\n    \"\"\"Recursively apply Simeck Feistel rounds for decryption (reverse order)\"\"\"\n    if round_idx is None:\n        round_idx = len(key_schedule) - 1\n    if round_idx < 0:\n        return state\n    left, right = state\n    k = key_schedule[round_idx]\n    # Apply one inverse round\n    new_left, new_right = simeck_decrypt_round(\n        k, left, right,\n        32,\n        (1 << 32) - 1\n    )\n    # Recursive call for previous round\n    return simeck_decrypt_iterate((new_left, new_right), key_schedule, round_idx - 1)", "output": "fun simeck_64_128_decrypt_iterate :: \"32 word \\<times> 32 word \\<Rightarrow> 32 word list \\<Rightarrow> 32 word \\<times> 32 word\" where\n  \"simeck_64_128_decrypt_iterate state ks = foldl (\\<lambda>st_new k. simeck_64_128_decrypt_round_inverse k st_new) state (rev ks)\"", "metadata": {"component_type": "Decrypt Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.260704", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(64/128) Encrypt Block from Python to Isabelle/HOL. Note: SIMECK processes 64-bit blocks as two 32-bit halves.", "input": "def simeck_encrypt_block(plaintext, key_schedule):\n        \"\"\"SIMECK block encryption\"\"\"\n        # Split into left and right halves\n        mask = (1 << 32) - 1\n        left = (plaintext >> 32) &  (1 <<  32) - 1\n        right = plaintext &  (1 <<  32) - 1\n        # Apply all rounds\n        cipher_left, cipher_right = simeck_encrypt_iterate(\n            (left, right),\n            key_schedule\n        )\n        # Combine back\n        return (cipher_left << 32) | cipher_right", "output": "definition simeck_64_128_encrypt_block :: \"32 word \\<times> 32 word \\<Rightarrow> 32 word list \\<Rightarrow> 32 word \\<times> 32 word\" where\n  \"simeck_64_128_encrypt_block plaintext keys = simeck_64_128_encrypt_iterate plaintext keys\"", "metadata": {"component_type": "Encrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.260757", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(64/128) Decrypt Block from Python to Isabelle/HOL. Note: SIMECK processes 64-bit blocks as two 32-bit halves.", "input": "def simeck_decrypt_block(ciphertext, key_schedule):\n        \"\"\"SIMECK block decryption\"\"\"\n        # Split into left and right halves\n        mask = (1 << 32) - 1\n        left = (ciphertext >> 32) &  (1 <<  32) - 1\n        right = ciphertext &  (1 <<  32) - 1\n        # Apply all inverse rounds\n        plain_left, plain_right = simeck_decrypt_iterate(\n            (left, right),\n            key_schedule\n        )\n        # Combine back\n\n        return (plain_left << 32) | plain_right", "output": "definition simeck_64_128_decrypt_block :: \"32 word \\<times> 32 word \\<Rightarrow> 32 word list \\<Rightarrow> 32 word \\<times> 32 word\" where\n  \"simeck_64_128_decrypt_block ciphertext keys = simeck_64_128_decrypt_iterate ciphertext keys\"", "metadata": {"component_type": "Decrypt Block", "difficulty": "easy", "semantic_group": "block_operations", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.260800", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(64/128) Top-Level Encrypt from Python to Isabelle/HOL. Note: SIMECK is a lightweight Feistel cipher optimized for hardware with 44 rounds.", "input": "def simeck_encrypt(plaintext, master_key):\n    \"\"\"Top-level SIMECK encryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simeck_generate_key_schedule(master_key)\n    # Encrypt block\n    return simeck_encrypt_block(plaintext, key_schedule)", "output": "definition simeck_64_128_encrypt :: \"64 word \\<Rightarrow> 32 word list \\<Rightarrow> 64 word\" where\n  \"simeck_64_128_encrypt plaintext keys = (\n    let left = ucast (drop_bit 32 plaintext);\n        right = ucast plaintext;\n        (c_left, c_right) = simeck_64_128_encrypt_block (left, right) keys\n    in or (push_bit 32 (ucast c_left)) (ucast c_right))\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.261076", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate the SIMECK(64/128) Top-Level Decrypt from Python to Isabelle/HOL. Note: SIMECK is a lightweight Feistel cipher optimized for hardware with 44 rounds.", "input": "def simeck_decrypt(ciphertext, master_key):\n    \"\"\"Top-level SIMECK decryption (ECB mode)\"\"\"\n    # Generate key schedule\n    key_schedule = simeck_generate_key_schedule(master_key)\n    # Decrypt block\n    return simeck_decrypt_block(ciphertext, key_schedule)", "output": "definition simeck_64_128_decrypt :: \"64 word \\<Rightarrow> 32 word list \\<Rightarrow> 64 word\" where\n  \"simeck_64_128_decrypt ciphertext keys = (\n    let left = ucast (drop_bit 32 ciphertext);\n        right = ucast ciphertext;\n        (p_left, p_right) = simeck_64_128_decrypt_block (left, right) keys\n    in or (push_bit 32 (ucast p_left)) (ucast p_right))\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SIMECK", "family": "Feistel", "extraction_time": "2026-01-24T13:11:48.261102", "variant": {"block_size": 64, "key_size": 128, "word_size": 32, "rounds": 44, "rotation_constants": [5, 1], "feistel_structure": "balanced", "key_expansion": "lfsr_based", "lfsr_type": "5-bit (x^5 + x^2 + 1) for rounds < 40, 6-bit (x^6 + x + 1) otherwise"}, "algorithm_params": {"cipher_family": "Feistel", "feistel_type": "balanced", "f_function": "(x & (x <<< 5)) ^ (x <<< 1)", "lfsr_usage": "Generates round constants for key schedule", "operations": ["rotation", "and", "xor"], "modulus_operations": true, "similar_to_simon": "SIMECK is a variant of SIMON with different rotation constants"}, "transformation_patterns": []}}
{"instruction": "Translate this Block Size Constant from GIFT-64/128 Python to Isabelle/HOL. Apply: coordinate key setup, iteration, and round functions, handle initial and final operations, maintain block state throughout encryption/decryption. Note: GIFT-64/128 processes blocks through 28 rounds.", "input": "# Block size in bits\nblock_size = 64", "output": "definition gift_64_128_block_size :: nat where \" gift_64_128_block_size = 64\"", "metadata": {"component_type": "Block Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.266303"}}
{"instruction": "Translate this Key Size Constant from GIFT-64/128 Python to Isabelle/HOL. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "# Key size in bits\nkey_size = 128", "output": "definition gift_64_128_key_size   :: nat where \" gift_64_128_key_size = 128\"", "metadata": {"component_type": "Key Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.266519"}}
{"instruction": "Translate this Rounds Constant from GIFT-64/128 Python to Isabelle/HOL. Apply: implement SPN structure: SubCells → PermBits → AddRoundKey, apply all operations in sequence, handle round constants and key addition. Note: GIFT round: SubCells (S-box layer) → PermBits (bit permutation) → AddRoundKey (key + round constant).", "input": "# Number of encryption rounds\nrounds = 28", "output": "definition gift_64_128_rounds     :: nat where \" gift_64_128_rounds = 28\"", "metadata": {"component_type": "Rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.266720"}}
{"instruction": "Translate this S-Box Table from GIFT-64/128 Python to Isabelle/HOL. Apply: use table lookup for 4-bit substitutions, handle nibble extraction and insertion, implement both forward and inverse S-boxes. Note: GIFT uses a 4-bit S-box applied to all nibbles in parallel.", "input": "# GIFT S-Box (4-bit substitution)\nSBOX = [0x1, 0xA, 0x4, 0xC, 0x6, 0xF, 0x3, 0x9,\n        0x2, 0xD, 0xB, 0x7, 0x5, 0x0, 0x8, 0xE]", "output": "definition gift_64_128_sbox_table :: \"nat list\" where\n  \"gift_64_128_sbox_table =\n   [1,10,4,12,6,15,3,9,2,13,11,7,5,0,8,14]\"", "metadata": {"component_type": "S-Box Table", "difficulty": "easy", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["list_operations", "sbox_substitution"], "extraction_time": "2026-01-24T13:11:48.267907"}}
{"instruction": "Translate this Inverse S-Box Table from GIFT-64/128 Python to Isabelle/HOL. Apply: use table lookup for 4-bit substitutions, handle nibble extraction and insertion, implement both forward and inverse S-boxes. Note: GIFT uses a 4-bit S-box applied to all nibbles in parallel.", "input": "# GIFT Inverse S-Box\nINV_SBOX = [0xD, 0x0, 0x8, 0x6, 0x2, 0xC, 0x4, 0xB,\n            0xE, 0x7, 0x1, 0xA, 0x3, 0x9, 0xF, 0x5]", "output": "definition gift_64_128_sbox_inv_table :: \"nat list\" where\n  \"gift_64_128_sbox_inv_table =\n   [13,0,8,6,2,12,4,11,14,7,1,10,3,9,15,5]\"", "metadata": {"component_type": "Inverse S-Box Table", "difficulty": "easy", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["list_operations", "sbox_substitution"], "extraction_time": "2026-01-24T13:11:48.268128"}}
{"instruction": "Translate this S-Box Function from GIFT-64/128 Python to Isabelle/HOL. Apply: use table lookup for 4-bit substitutions, handle nibble extraction and insertion, implement both forward and inverse S-boxes. Note: GIFT uses a 4-bit S-box applied to all nibbles in parallel.", "input": "def sbox(nibble: int) -> int:\n    \"\"\"Apply GIFT S-box to a 4-bit nibble\"\"\"\n    return SBOX[nibble]", "output": "definition gift_64_128_sbox :: \"4 word \\<Rightarrow> 4 word\" where\n  \"gift_64_128_sbox x = of_nat (gift_64_128_sbox_table ! unat x)\"", "metadata": {"component_type": "S-Box Function", "difficulty": "medium", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["list_operations", "function_definition", "sbox_substitution", "nibble_operations"], "extraction_time": "2026-01-24T13:11:48.268378"}}
{"instruction": "Translate this Inverse S-Box Function from GIFT-64/128 Python to Isabelle/HOL. Apply: use table lookup for 4-bit substitutions, handle nibble extraction and insertion, implement both forward and inverse S-boxes. Note: GIFT uses a 4-bit S-box applied to all nibbles in parallel.", "input": "def sbox_inv(nibble: int) -> int:\n    \"\"\"Apply inverse GIFT S-box to a 4-bit nibble\"\"\"\n    return INV_SBOX[nibble]", "output": "definition gift_64_128_sbox_inv :: \"4 word \\<Rightarrow> 4 word\" where\n  \"gift_64_128_sbox_inv x = of_nat (gift_64_128_sbox_inv_table ! unat x)\"", "metadata": {"component_type": "Inverse S-Box Function", "difficulty": "medium", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["list_operations", "function_definition", "sbox_substitution", "nibble_operations"], "extraction_time": "2026-01-24T13:11:48.268617"}}
{"instruction": "Translate this Permutation Order Table from GIFT-64/128 Python to Isabelle/HOL. Apply: implement permutation using formula: (16 * i) % 63, handle exception bit position, use bit extraction and insertion. Note: GIFT permutation: P(i) = (16 * i) % 63 for i < 63, P(63) = 63.", "input": "# GIFT Permutation Order\n# P(i) = (16 * i) % 63 for i < 63, P(63) = 63\nPERM_ORDER = [...]", "output": "definition gift_64_128_perm_order :: \"nat list\" where\n  \"gift_64_128_perm_order =\n   [0,16,32,48,1,17,33,49,2,18,34,50,3,19,35,51,\n    4,20,36,52,5,21,37,53,6,22,38,54,7,23,39,55,\n    8,24,40,56,9,25,41,57,10,26,42,58,11,27,43,59,\n    12,28,44,60,13,29,45,61,14,30,46,62,15,31,47,63]\"", "metadata": {"component_type": "Permutation Order Table", "difficulty": "medium", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "list_operations", "bit_permutation"], "extraction_time": "2026-01-24T13:11:48.268894"}}
{"instruction": "Translate this Inverse Permutation Order Table from GIFT-64/128 Python to Isabelle/HOL. Apply: implement permutation using formula: (16 * i) % 63, handle exception bit position, use bit extraction and insertion. Note: GIFT permutation: P(i) = (16 * i) % 63 for i < 63, P(63) = 63.", "input": "# GIFT Inverse Permutation Order\n# Inverse mapping for P(i)\nPERM_INV_ORDER = [...]", "output": "definition gift_64_128_perm_inv_order :: \"nat list\" where\n  \"gift_64_128_perm_inv_order =\n   [0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,\n    1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,\n    2,6,10,14,18,22,26,30,34,38,42,46,50,54,58,62,\n    3,7,11,15,19,23,27,31,35,39,43,47,51,55,59,63]\"", "metadata": {"component_type": "Inverse Permutation Order Table", "difficulty": "medium", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "list_operations", "bit_permutation"], "extraction_time": "2026-01-24T13:11:48.269171"}}
{"instruction": "Translate this Round Constants from GIFT-64/128 Python to Isabelle/HOL. Apply: implement SPN structure: SubCells → PermBits → AddRoundKey, apply all operations in sequence, handle round constants and key addition. Note: GIFT round: SubCells (S-box layer) → PermBits (bit permutation) → AddRoundKey (key + round constant).", "input": "# GIFT Round Constants for 28 rounds\n    ROUND_CONSTANTS = [0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3E, 0x3D, 0x3B, 0x37, 0x2F, 0x1E, 0x3C, 0x39, 0x33, 0x27, 0x0E, 0x1D, 0x3A, 0x35, 0x2B, 0x16, 0x2C, 0x18, 0x30, 0x21, 0x02, 0x05, 0x0B]", "output": "definition gift_64_128_round_constants :: \"nat list\" where\n  \"gift_64_128_round_constants =\n   [1,3,7,15,31,62,61,59,55,47,30,60,57,51,\n    39,14,29,58,53,43,22,44,24,48,33,2,5,11]\"\n\n\n\ntype_synonym key_state = \"16 word list\"", "metadata": {"component_type": "Round Constants", "difficulty": "easy", "semantic_group": "constants", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "list_operations"], "extraction_time": "2026-01-24T13:11:48.269691"}}
{"instruction": "Translate this Get Nibble Helper from GIFT-64/128 Python to Isabelle/HOL. Apply: implement nibble/bit extraction operations, use bit masking and shifting, handle word boundaries correctly. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def get_nibble(state: int, i: int) -> int:\n    \"\"\"Extract nibble i from state\"\"\"\n    return (state >> (4 * i)) & 0xF", "output": "definition gift_64_128_get_nibble :: \"64 word \\<Rightarrow> nat \\<Rightarrow> 4 word\" where\n  \"gift_64_128_get_nibble s i =\n     ucast (take_bit 4 (drop_bit (4*i) s))\"", "metadata": {"component_type": "Get Nibble Helper", "difficulty": "medium", "semantic_group": "helpers", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition", "nibble_operations"], "extraction_time": "2026-01-24T13:11:48.269988"}}
{"instruction": "Translate this Set Nibble Helper from GIFT-64/128 Python to Isabelle/HOL. Apply: implement nibble/bit extraction operations, use bit masking and shifting, handle word boundaries correctly. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def set_nibble(state: int, i: int, value: int) -> int:\n    \"\"\"Set nibble i in state to value\"\"\"\n    mask = 0xF << (4 * i)\n    return (state & ~mask) | ((value & 0xF) << (4 * i))", "output": "definition gift_64_128_set_nibble :: \"64 word \\<Rightarrow> nat \\<Rightarrow> 4 word \\<Rightarrow> 64 word\" where\n  \"gift_64_128_set_nibble s i v =\n     or (and s (not (push_bit (4*i) (mask 4)))) (push_bit (4*i) (ucast v))\"", "metadata": {"component_type": "Set Nibble Helper", "difficulty": "medium", "semantic_group": "helpers", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition", "nibble_operations"], "extraction_time": "2026-01-24T13:11:48.270242"}}
{"instruction": "Translate this Get Bit Helper from GIFT-64/128 Python to Isabelle/HOL. Apply: implement nibble/bit extraction operations, use bit masking and shifting, handle word boundaries correctly. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def get_bit(state: int, i: int) -> int:\n    \"\"\"Extract bit i from state\"\"\"\n    return (state >> i) & 1", "output": "definition gift_64_128_get_bit :: \"64 word \\<Rightarrow> nat \\<Rightarrow> 1 word\" where\n  \"gift_64_128_get_bit s i = ucast (take_bit 1 (drop_bit i s))\"", "metadata": {"component_type": "Get Bit Helper", "difficulty": "medium", "semantic_group": "helpers", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.270523"}}
{"instruction": "Translate this Set Bit Helper from GIFT-64/128 Python to Isabelle/HOL. Apply: implement nibble/bit extraction operations, use bit masking and shifting, handle word boundaries correctly. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def set_bit(state: int, i: int, value: int) -> int:\n    \"\"\"Set bit i in state to value (0 or 1)\"\"\"\n    if value:\n        return state | (1 << i)\n    else:\n        return state & ~(1 << i)", "output": "definition gift_64_128_set_bit :: \"64 word \\<Rightarrow> nat \\<Rightarrow> 1 word \\<Rightarrow> 64 word\" where\n  \"gift_64_128_set_bit s i v =\n     or (and s (not (push_bit i 1))) (push_bit i (ucast v))\"", "metadata": {"component_type": "Set Bit Helper", "difficulty": "medium", "semantic_group": "helpers", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.270796"}}
{"instruction": "Translate this Key Setup Function from GIFT-64/128 Python to Isabelle/HOL. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def key_setup(key: int):\n        \"\"\"Convert 128-bit key to 8×16-bit words (key_state)\n        \n        Semantic: Decompose key into word array [W7, W6, W5, W4, W3, W2, W1, W0]\n        Composition: Extract 16-bit slices from MSB to LSB\n        \"\"\"\n        if key < 0 or key >= (1 << 128):\n            raise ValueError(\"Key must be 128-bit (0 <= key < 2^128)\")\n        \n        key_words = []\n        for i in range(7, -1, -1):  # Extract W7 (MSB) to W0 (LSB)\n            word = (key >> (16 * i)) & 0xFFFF\n            key_words.append(word)\n        \n        return key_words  # [W7, W6, W5, W4, W3, W2, W1, W0]", "output": "definition gift_64_128_key_setup :: \"128 word \\<Rightarrow> key_state\" where\n  \"gift_64_128_key_setup k =\n   [ ucast (take_bit 16 (drop_bit 112 k)),\n     ucast (take_bit 16 (drop_bit 96 k)),\n     ucast (take_bit 16 (drop_bit 80 k)),\n     ucast (take_bit 16 (drop_bit 64 k)),\n     ucast (take_bit 16 (drop_bit 48 k)),\n     ucast (take_bit 16 (drop_bit 32 k)),\n     ucast (take_bit 16 (drop_bit 16 k)),\n     ucast (take_bit 16 k) ]\"", "metadata": {"component_type": "Key Setup Function", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "list_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.271304"}}
{"instruction": "Translate this Key Update Function from GIFT-64/128 Python to Isabelle/HOL. Apply: implement word rotation and reordering, use 16-bit word operations, handle key state as list of words. Note: GIFT key update rotates and reorders 16-bit words in the key state.", "input": "def update_key(key_words):\n        \"\"\"Update key state for next round (key schedule)\n        \n        Semantic: Circular shift + rotations on W1 and W0\n        Transformation: [W7,W6,W5,W4,W3,W2,W1,W0] → [ROR(W1,12), ROR(W0,2), W7,W6,W5,W4,W3,W2]\n        \"\"\"\n        W7, W6, W5, W4, W3, W2, W1, W0 = key_words\n        \n        # Step 1: Circular shift\n        new_words = [W1, W0, W7, W6, W5, W4, W3, W2]\n        \n        # Step 2: Apply rotations to new W0 and W1\n        w0_new = ror_16(new_words[1], 2)    # ROR(W0, 2)\n        w1_new = ror_16(new_words[0], 12)   # ROR(W1, 12)\n        \n        new_words[1] = w0_new\n        new_words[0] = w1_new\n        \n        return new_words\n    \n    # =========================================================================\n    # ROUND PRIMITIVES (Match Isabelle subsections)\n    # =========================================================================", "output": "definition gift_64_128_key_update :: \"key_state \\<Rightarrow> key_state\" where\n  \"gift_64_128_key_update ks =\n   (case ks of\n     [W7,W6,W5,W4,W3,W2,W1,W0] \\<Rightarrow>\n       [ gift_64_128_ror16 W1 12,   \n         gift_64_128_ror16 W0 2,    \n         W7,                 \n         W6,                 \n         W5,                 \n         W4,                 \n         W3,                 \n         W2 ]                \n   | _ \\<Rightarrow> ks)\"", "metadata": {"component_type": "Key Update Function", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "list_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.271913"}}
{"instruction": "Translate this Rotation Helper from GIFT-64/128 Python to Isabelle/HOL. Apply: implement nibble/bit extraction operations, use bit masking and shifting, handle word boundaries correctly. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def ror_16(word: int, n: int) -> int:\n    \"\"\"Right rotate 16-bit word by n bits\"\"\"\n    return ((word >> n) | (word << (16 - n))) & 0xFFFF", "output": "definition gift_64_128_ror16 :: \"16 word \\<Rightarrow> nat \\<Rightarrow> 16 word\" where\n  \"gift_64_128_ror16 w n =\n     or (drop_bit n w) (push_bit (16 - n) (take_bit n w))\"", "metadata": {"component_type": "Rotation Helper", "difficulty": "medium", "semantic_group": "helpers", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.272611"}}
{"instruction": "Translate this Add Round Key Iteration from GIFT-64/128 Python to Isabelle/HOL. Apply: implement SPN structure: SubCells → PermBits → AddRoundKey, apply all operations in sequence, handle round constants and key addition. Note: GIFT round: SubCells (S-box layer) → PermBits (bit permutation) → AddRoundKey (key + round constant).", "input": "def add_round_key_iter(state: int, key_words: list) -> int:\n    \"\"\"Add key bits from W6 and W2 to state\"\"\"\n    result = state\n    U = key_words[1]  # W6\n    V = key_words[5]  # W2\n    \n    for i in range(16):\n        u_bit = (U >> i) & 1\n        v_bit = (V >> i) & 1\n        result ^= (u_bit << (4 * i))\n        result ^= (v_bit << (4 * i + 1))\n    \n    return result", "output": "definition gift_64_128_add_round_key_iter :: \"64 word \\<Rightarrow> key_state \\<Rightarrow> nat \\<Rightarrow> 64 word\" where\n  \"gift_64_128_add_round_key_iter s ks r =\n     fold (\\<lambda>i acc.\n            xor (xor acc \n                  (push_bit (4*i)\n                    (ucast (take_bit 1 (drop_bit i (ks ! 1))))))\n                 (push_bit (4*i+1)\n                    (ucast (take_bit 1 (drop_bit i (ks ! 5))))))\n          [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n          s\"", "metadata": {"component_type": "Add Round Key Iteration", "difficulty": "hard", "semantic_group": "key_mixing", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "list_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.272982"}}
{"instruction": "Translate this Add Round Constant from GIFT-64/128 Python to Isabelle/HOL. Apply: implement SPN structure: SubCells → PermBits → AddRoundKey, apply all operations in sequence, handle round constants and key addition. Note: GIFT round: SubCells (S-box layer) → PermBits (bit permutation) → AddRoundKey (key + round constant).", "input": "def add_round_constant(state: int, round_idx: int) -> int:\n    \"\"\"Add round constant bits to state\"\"\"\n    result = state\n    rc = ROUND_CONSTANTS[round_idx]\n    \n    for i in range(6):\n        rc_bit = (rc >> i) & 1\n        result ^= (rc_bit << (4 * i + 3))\n    \n    result ^= (1 << 63)\n    \n    return result", "output": "definition gift_64_128_add_round_constant :: \"64 word \\<Rightarrow> nat \\<Rightarrow> 64 word\" where\n  \"gift_64_128_add_round_constant s r =\n     xor \n       (fold \n         (\\<lambda>i acc. xor acc\n           (push_bit (4*i+3)\n             (ucast (take_bit 1 (drop_bit i\n               (of_nat (gift_64_128_round_constants ! r) :: 6 word))))))\n         [0,1,2,3,4,5]\n         s)\n       (push_bit 63 1)\"", "metadata": {"component_type": "Add Round Constant", "difficulty": "medium", "semantic_group": "key_mixing", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "list_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.273354"}}
{"instruction": "Translate this Add Round Key Function from GIFT-64/128 Python to Isabelle/HOL. Apply: implement SPN structure: SubCells → PermBits → AddRoundKey, apply all operations in sequence, handle round constants and key addition. Note: GIFT round: SubCells (S-box layer) → PermBits (bit permutation) → AddRoundKey (key + round constant).", "input": "def add_round_key(state: int, key_words: list, round_idx: int) -> int:\n    \"\"\"Complete AddRoundKey: key bits + round constant\"\"\"\n    state = add_round_key_iter(state, key_words)\n    state = add_round_constant(state, round_idx)\n    return state", "output": "definition gift_64_128_add_round_key :: \"64 word \\<Rightarrow> key_state \\<Rightarrow> nat \\<Rightarrow> 64 word\" where\n  \"gift_64_128_add_round_key s ks r =\n     gift_64_128_add_round_constant\n       (gift_64_128_add_round_key_iter s ks r) r\"", "metadata": {"component_type": "Add Round Key Function", "difficulty": "hard", "semantic_group": "key_mixing", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.274111"}}
{"instruction": "Translate this S-Box Layer Function from GIFT-64/128 Python to Isabelle/HOL. Apply: use table lookup for 4-bit substitutions, handle nibble extraction and insertion, implement both forward and inverse S-boxes. Note: GIFT uses a 4-bit S-box applied to all nibbles in parallel.", "input": "def sub_cells(state: int) -> int:\n    \"\"\"SubCells: Apply S-box to each 4-bit nibble\"\"\"\n    result = 0\n    for i in range(16):  # 16 nibbles in 64-bit state\n        nibble = (state >> (4 * i)) & 0xF\n        substituted = SBOX[nibble]\n        result |= (substituted << (4 * i))\n    return result", "output": "definition gift_64_128_sbox_layer :: \"64 word \\<Rightarrow> 64 word\" where\n  \"gift_64_128_sbox_layer s =\n     fold (\\<lambda>i acc. \n            gift_64_128_set_nibble acc i (gift_64_128_sbox (gift_64_128_get_nibble acc i)))\n          [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n          s\"", "metadata": {"component_type": "S-Box Layer Function", "difficulty": "medium", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "list_operations", "function_definition", "sbox_substitution", "nibble_operations"], "extraction_time": "2026-01-24T13:11:48.274718"}}
{"instruction": "Translate this Inverse S-Box Layer Function from GIFT-64/128 Python to Isabelle/HOL. Apply: use table lookup for 4-bit substitutions, handle nibble extraction and insertion, implement both forward and inverse S-boxes. Note: GIFT uses a 4-bit S-box applied to all nibbles in parallel.", "input": "def inv_sub_cells(state: int) -> int:\n    \"\"\"Inverse SubCells for decryption\"\"\"\n    result = 0\n    for i in range(16):\n        nibble = (state >> (4 * i)) & 0xF\n        substituted = INV_SBOX[nibble]\n        result |= (substituted << (4 * i))\n    return result", "output": "definition gift_64_128_sbox_layer_inv :: \"64 word \\<Rightarrow> 64 word\" where\n  \"gift_64_128_sbox_layer_inv s =\n     fold (\\<lambda>i acc. \n            gift_64_128_set_nibble acc i (gift_64_128_sbox_inv (gift_64_128_get_nibble acc i)))\n          [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n          s\"", "metadata": {"component_type": "Inverse S-Box Layer Function", "difficulty": "medium", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "list_operations", "function_definition", "sbox_substitution", "nibble_operations"], "extraction_time": "2026-01-24T13:11:48.275321"}}
{"instruction": "Translate this Permutation Layer Function from GIFT-64/128 Python to Isabelle/HOL. Apply: implement permutation using formula: (16 * i) % 63, handle exception bit position, use bit extraction and insertion. Note: GIFT permutation: P(i) = (16 * i) % 63 for i < 63, P(63) = 63.", "input": "def perm_bits(state: int) -> int:\n    \"\"\"PermBits: Bit permutation (Diffusion primitive)\"\"\"\n    result = 0\n    \n    # Process bits 0-62: P(i) = 16*i mod 63\n    for src_pos in range(63):\n        src_bit = (state >> src_pos) & 1\n        dst_pos = (16 * src_pos) % 63\n        result |= (src_bit << dst_pos)\n    \n    # Bit 63 remains at position 63\n    result |= (state & (1 << 63))\n    \n    return result", "output": "definition gift_64_128_perm_layer :: \"64 word \\<Rightarrow> 64 word\" where\n  \"gift_64_128_perm_layer s =\n     fold (\\<lambda>i acc.\n            if gift_64_128_get_bit s i = 1\n            then gift_64_128_set_bit acc (gift_64_128_perm_order ! i) 1\n            else acc)\n          [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n           16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n           32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n           48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63]\n          (0 :: 64 word)\"", "metadata": {"component_type": "Permutation Layer Function", "difficulty": "hard", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "function_definition", "bit_permutation"], "extraction_time": "2026-01-24T13:11:48.275979"}}
{"instruction": "Translate this Inverse Permutation Layer Function from GIFT-64/128 Python to Isabelle/HOL. Apply: implement permutation using formula: (16 * i) % 63, handle exception bit position, use bit extraction and insertion. Note: GIFT permutation: P(i) = (16 * i) % 63 for i < 63, P(63) = 63.", "input": "def inv_perm_bits(state: int) -> int:\n    \"\"\"Inverse PermBits for decryption\"\"\"\n    result = 0\n    \n    # Process bits 0-62 using precomputed inverse mapping\n    for dst_pos in range(63):\n        src_bit = (state >> dst_pos) & 1\n        src_pos = INV_PERM[dst_pos]\n        result |= (src_bit << src_pos)\n    \n    # Bit 63\n    result |= (state & (1 << 63))\n    \n    return result", "output": "definition gift_64_128_perm_layer_inv :: \"64 word \\<Rightarrow> 64 word\" where\n  \"gift_64_128_perm_layer_inv s =\n     fold (\\<lambda>i acc.\n            if gift_64_128_get_bit s i = 1\n            then gift_64_128_set_bit acc (gift_64_128_perm_inv_order ! i) 1\n            else acc)\n          [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n           16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n           32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n           48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63]\n          (0 :: 64 word)\"", "metadata": {"component_type": "Inverse Permutation Layer Function", "difficulty": "hard", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "list_operations", "function_definition", "bit_permutation"], "extraction_time": "2026-01-24T13:11:48.276634"}}
{"instruction": "Translate this Encrypt Round Function from GIFT-64/128 Python to Isabelle/HOL. Apply: implement SPN structure: SubCells → PermBits → AddRoundKey, apply all operations in sequence, handle round constants and key addition. Note: GIFT round: SubCells (S-box layer) → PermBits (bit permutation) → AddRoundKey (key + round constant).", "input": "def encrypt_round(state: int, key_words, round_idx: int):\n        \"\"\"SPN Round Composition: SubCells → PermBits → AddRoundKey\n        \n        Semantic: Standard SPN round structure\n        Property: Deterministic state and key update\n        Composition: sub_cells ∘ perm_bits ∘ add_round_key\n        Return: (new_state, new_key_words)\n        \"\"\"\n        # 1. SubCells (non-linear substitution)\n        state = sub_cells(state)\n        \n        # 2. PermBits (linear diffusion)\n        state = perm_bits(state)\n        \n        # 3. AddRoundKey (key mixing)\n        state = add_round_key(state, key_words, round_idx)\n        \n        # 4. Update key for next round\n        new_key_words = update_key(key_words)\n        \n        return state, new_key_words", "output": "definition gift_64_128_encrypt_round ::\n  \"64 word \\<Rightarrow> key_state \\<Rightarrow> nat \\<Rightarrow> (64 word \\<times> key_state)\" where\n  \"gift_64_128_encrypt_round s ks r =\n   (let s1 = gift_64_128_sbox_layer s;\n        s2 = gift_64_128_perm_layer s1;\n        s3 = gift_64_128_add_round_key s2 ks r;\n        ks' = gift_64_128_key_update ks\n    in (s3, ks'))\"", "metadata": {"component_type": "Encrypt Round Function", "difficulty": "hard", "semantic_group": "round_operations", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "function_definition", "bit_permutation"], "extraction_time": "2026-01-24T13:11:48.277169"}}
{"instruction": "Translate this Decrypt Round Function from GIFT-64/128 Python to Isabelle/HOL. Apply: implement SPN structure: SubCells → PermBits → AddRoundKey, apply all operations in sequence, handle round constants and key addition. Note: GIFT round: SubCells (S-box layer) → PermBits (bit permutation) → AddRoundKey (key + round constant).", "input": "def decrypt_round(state: int, key_words, round_idx: int):\n        \"\"\"Inverse SPN Round Composition\n        \n        Semantic: AddRoundKey⁻¹ ∘ PermBits⁻¹ ∘ SubCells⁻¹\n        Composition: add_round_key ∘ inv_perm_bits ∘ inv_sub_cells\n        Note: Key update not needed for decryption rounds\n        \"\"\"\n        # 1. Inverse AddRoundKey (XOR is self-inverse)\n        state = add_round_key(state, key_words, round_idx)\n        \n        # 2. Inverse PermBits\n        state = inv_perm_bits(state)\n        \n        # 3. Inverse SubCells\n        state = inv_sub_cells(state)\n        \n        return state, key_words  # Key stays same for decryption\n    \n    # =========================================================================\n    # ITERATION (Match gift_64_128_encrypt_iterate)\n    # =========================================================================", "output": "definition gift_64_128_decrypt_round ::\n  \"64 word \\<Rightarrow> key_state \\<Rightarrow> nat \\<Rightarrow> (64 word \\<times> key_state)\" where\n  \"gift_64_128_decrypt_round s ks r =\n   (let s1 = gift_64_128_add_round_key s ks r;   \n        s2 = gift_64_128_perm_layer_inv s1;      \n        s3 = gift_64_128_sbox_layer_inv s2       \n    in (s3, ks))\"  (* Note: for decryption, we use the same key, not updated *)", "metadata": {"component_type": "Decrypt Round Function", "difficulty": "hard", "semantic_group": "round_operations", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "function_definition", "bit_permutation"], "extraction_time": "2026-01-24T13:11:48.277663"}}
{"instruction": "Translate this Generate Round Keys (Recursive) from GIFT-64/128 Python to Isabelle/HOL. Apply: implement SPN structure: SubCells → PermBits → AddRoundKey, apply all operations in sequence, handle round constants and key addition. Note: GIFT round: SubCells (S-box layer) → PermBits (bit permutation) → AddRoundKey (key + round constant).", "input": "def generate_round_keys(key_state: list, n: int) -> list:\n    \"\"\"Recursively generate n round keys\"\"\"\n    if n == 0:\n        return []\n    return [key_state] + generate_round_keys(update_key(key_state), n - 1)", "output": "fun gift_64_128_generate_round_keys :: \"key_state \\<Rightarrow> nat \\<Rightarrow> key_state list\" where\n  \"gift_64_128_generate_round_keys ks 0 = []\"\n| \"gift_64_128_generate_round_keys ks (Suc n) = \n     ks # gift_64_128_generate_round_keys (gift_64_128_key_update ks) n\"", "metadata": {"component_type": "Generate Round Keys (Recursive)", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["list_operations", "function_definition", "recursive_function"], "extraction_time": "2026-01-24T13:11:48.278103"}}
{"instruction": "Translate this Key Schedule Function from GIFT-64/128 Python to Isabelle/HOL. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def key_schedule(key: int) -> list:\n    \"\"\"Generate complete key schedule for decryption\"\"\"\n    initial_key = key_setup(key)\n    return generate_round_keys(initial_key, 28)", "output": "definition gift_64_128_key_schedule :: \"128 word \\<Rightarrow> key_state list\" where\n  \"gift_64_128_key_schedule k = \n     gift_64_128_generate_round_keys (gift_64_128_key_setup k)  gift_64_128_rounds\"", "metadata": {"component_type": "Key Schedule Function", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "function_definition"], "extraction_time": "2026-01-24T13:11:48.278530"}}
{"instruction": "Translate this Encrypt Iterate Wrapper from GIFT-64/128 Python to Isabelle/HOL. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def encrypt_iterate(state: int, key_state):\n        \"\"\"Iterative Round Application\n        \n        Semantic: Apply all rounds sequentially\n        Implementation: Loop over round count\n        Composition: Repeated application of encrypt_round\n        \"\"\"\n        key_words = key_state\n        \n        for r in range(rounds):\n            state, key_words = encrypt_round(state, key_words, r)\n        \n        return state", "output": "definition gift_64_128_encrypt_iterate ::\n  \"64 word \\<Rightarrow> key_state \\<Rightarrow> 64 word\" where\n\"gift_64_128_encrypt_iterate s ks =\n   gift_64_128_encrypt_iter s ks 0 gift_64_128_rounds\"", "metadata": {"component_type": "Encrypt Iterate Wrapper", "difficulty": "medium", "semantic_group": "iteration", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "function_definition"], "extraction_time": "2026-01-24T13:11:48.279053"}}
{"instruction": "Translate this Decrypt Iterate Wrapper from GIFT-64/128 Python to Isabelle/HOL. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def decrypt_iterate(state: int, key_schedule):\n        \"\"\"Inverse Iterative Round Application\n        \n        Semantic: Apply all rounds in reverse order\n        Implementation: Process rounds backwards\n        Composition: Repeated application of decrypt_round\n        \"\"\"\n        # Execute rounds in reverse order\n        for r in range(rounds - 1, -1, -1):\n            key_words = key_schedule[r]\n            state, _ = decrypt_round(state, key_words, r)\n        \n        return state\n    \n    # =========================================================================\n    # BLOCK OPERATIONS (Match gift_64_128_encrypt_block / decrypt_block)\n    # =========================================================================", "output": "definition gift_64_128_decrypt_iterate ::\n  \"64 word \\<Rightarrow> key_state list \\<Rightarrow> 64 word\" where\n\"gift_64_128_decrypt_iterate s keys =\n   gift_64_128_decrypt_iter s (rev keys) (gift_64_128_rounds - 1)\"", "metadata": {"component_type": "Decrypt Iterate Wrapper", "difficulty": "medium", "semantic_group": "iteration", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "list_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.279572"}}
{"instruction": "Translate this Encrypt Iteration (Recursive) from GIFT-64/128 Python to Isabelle/HOL. Apply: convert for-loops to recursion, use base case and recursive case, handle round counter and state updates. Note: GIFT uses 28 rounds in an SPN structure.", "input": "def encrypt_iter(state: int, key_state: list, round_idx: int, rounds_left: int) -> int:\n    \"\"\"Recursive encryption iteration\"\"\"\n    if rounds_left == 0:\n        return state\n    new_state, new_key = encrypt_round(state, key_state, round_idx)\n    return encrypt_iter(new_state, new_key, round_idx + 1, rounds_left - 1)", "output": "fun gift_64_128_encrypt_iter ::\n  \"64 word \\<Rightarrow> key_state \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 64 word\" where\n  \"gift_64_128_encrypt_iter s ks r 0 = s\"\n| \"gift_64_128_encrypt_iter s ks r (Suc n) =\n     (let (s', ks') = gift_64_128_encrypt_round s ks r\n      in gift_64_128_encrypt_iter s' ks' (r + 1) n)\"", "metadata": {"component_type": "Encrypt Iteration (Recursive)", "difficulty": "hard", "semantic_group": "iteration", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["function_definition", "recursive_function"], "extraction_time": "2026-01-24T13:11:48.280066"}}
{"instruction": "Translate this Decrypt Iteration (Recursive) from GIFT-64/128 Python to Isabelle/HOL. Apply: convert for-loops to recursion, use base case and recursive case, handle round counter and state updates. Note: GIFT uses 28 rounds in an SPN structure.", "input": "def decrypt_iter(state: int, key_schedule: list, round_idx: int) -> int:\n    \"\"\"Recursive decryption iteration\"\"\"\n    if round_idx < 0:\n        return state\n    key_words = key_schedule[round_idx]\n    state, _ = decrypt_round(state, key_words, round_idx)\n    return decrypt_iter(state, key_schedule, round_idx - 1)", "output": "fun gift_64_128_decrypt_iter ::\n  \"64 word \\<Rightarrow> key_state list \\<Rightarrow> nat \\<Rightarrow> 64 word\" where\n  \"gift_64_128_decrypt_iter s [] _ = s\"\n| \"gift_64_128_decrypt_iter s (k#ks) r =\n     (if r = 0 then gift_64_128_add_round_key s k r\n      else let (s', _) = gift_64_128_decrypt_round s k r\n           in gift_64_128_decrypt_iter s' ks (r-1))\"", "metadata": {"component_type": "Decrypt Iteration (Recursive)", "difficulty": "hard", "semantic_group": "iteration", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["list_operations", "function_definition", "recursive_function"], "extraction_time": "2026-01-24T13:11:48.280562"}}
{"instruction": "Translate this Encrypt Block Function from GIFT-64/128 Python to Isabelle/HOL. Apply: coordinate key setup, iteration, and round functions, handle initial and final operations, maintain block state throughout encryption/decryption. Note: GIFT-64/128 processes blocks through 28 rounds.", "input": "def encrypt_block(plaintext: int, key: int) -> int:\n    \"\"\"Block Encryption: Key Setup → Iteration\"\"\"\n    # 1. Setup initial key state\n    key_state = key_setup(key)\n    \n    # 2. Apply all rounds via iteration\n    return encrypt_iterate(plaintext, key_state)", "output": "definition gift_64_128_encrypt_block :: \"64 word \\<Rightarrow> 128 word \\<Rightarrow> 64 word\" where\n\"gift_64_128_encrypt_block plaintext key =\n   gift_64_128_encrypt_iterate plaintext (gift_64_128_key_setup key)\"", "metadata": {"component_type": "Encrypt Block Function", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.281514"}}
{"instruction": "Translate this Decrypt Block Function from GIFT-64/128 Python to Isabelle/HOL. Apply: coordinate key setup, iteration, and round functions, handle initial and final operations, maintain block state throughout encryption/decryption. Note: GIFT-64/128 processes blocks through 28 rounds.", "input": "def decrypt_block(ciphertext: int, key: int) -> int:\n    \"\"\"Block Decryption: Key Schedule → Inverse Iteration\"\"\"\n    # 1. Generate all round keys (key schedule)\n    key_state = key_setup(key)\n    key_schedule = []\n    \n    for r in range(28):\n        key_schedule.append(key_state)\n        key_state = update_key(key_state)\n    \n    # 2. Apply inverse rounds via iteration\n    return decrypt_iterate(ciphertext, key_schedule)", "output": "definition gift_64_128_decrypt_block :: \"64 word \\<Rightarrow> 128 word \\<Rightarrow> 64 word\" where\n  \"gift_64_128_decrypt_block ciphertext key = \n      gift_64_128_decrypt_iterate ciphertext (gift_64_128_key_schedule key) \"", "metadata": {"component_type": "Decrypt Block Function", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "list_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.282488"}}
{"instruction": "Translate this Encrypt (Top-level) from GIFT-64/128 Python to Isabelle/HOL. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def encrypt(plaintext: int, key: int) -> int:\n    \"\"\"Top-level Encryption Interface\"\"\"\n    return encrypt_block(plaintext, key)", "output": "definition gift_64_128_encrypt ::\n  \"128 word \\<Rightarrow> 64 word \\<Rightarrow> 64 word\" where\n\"gift_64_128_encrypt key plaintext =\n   gift_64_128_encrypt_block plaintext key\"", "metadata": {"component_type": "Encrypt (Top-level)", "difficulty": "medium", "semantic_group": "top_level", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.283454"}}
{"instruction": "Translate this Decrypt (Top-level) from GIFT-64/128 Python to Isabelle/HOL. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def decrypt(ciphertext: int, key: int) -> int:\n    \"\"\"Top-level Decryption Interface\"\"\"\n    return decrypt_block(ciphertext, key)", "output": "definition gift_64_128_decrypt ::\n  \"128 word \\<Rightarrow> 64 word \\<Rightarrow> 64 word\" where\n\"gift_64_128_decrypt key ciphertext =\n   gift_64_128_decrypt_block ciphertext key\"", "metadata": {"component_type": "Decrypt (Top-level)", "difficulty": "medium", "semantic_group": "top_level", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 64, "key_size": 128, "rounds": 28, "nibbles_per_block": 16}, "algorithm_params": {"word_size": 16, "sbox_count": 16, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(16 * i) % 63", "permutation_exception": 63, "permutation_size": 64, "key_update": "word rotation and reordering"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.284403"}}
{"instruction": "Translate this Block Size Constant from GIFT-128/128 Python to Isabelle/HOL. Apply: coordinate key setup, iteration, and round functions, handle initial and final operations, maintain block state throughout encryption/decryption. Note: GIFT-128/128 processes blocks through 40 rounds.", "input": "# Block size in bits\nblock_size = 128", "output": "definition gift_128_128_block_size :: nat where \"gift_128_128_block_size = 128\"", "metadata": {"component_type": "Block Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.286312"}}
{"instruction": "Translate this Key Size Constant from GIFT-128/128 Python to Isabelle/HOL. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "# Key size in bits\nkey_size = 128", "output": "definition gift_128_128_key_size   :: nat where \"gift_128_128_key_size = 128\"", "metadata": {"component_type": "Key Size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.286523"}}
{"instruction": "Translate this Rounds Constant from GIFT-128/128 Python to Isabelle/HOL. Apply: implement SPN structure: SubCells → PermBits → AddRoundKey, apply all operations in sequence, handle round constants and key addition. Note: GIFT round: SubCells (S-box layer) → PermBits (bit permutation) → AddRoundKey (key + round constant).", "input": "# Number of encryption rounds\nrounds = 40", "output": "definition gift_128_128_rounds     :: nat where \"gift_128_128_rounds = 40\"", "metadata": {"component_type": "Rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.286728"}}
{"instruction": "Translate this S-Box Table from GIFT-128/128 Python to Isabelle/HOL. Apply: use table lookup for 4-bit substitutions, handle nibble extraction and insertion, implement both forward and inverse S-boxes. Note: GIFT uses a 4-bit S-box applied to all nibbles in parallel.", "input": "# GIFT S-Box (4-bit substitution)\nSBOX = [0x1, 0xA, 0x4, 0xC, 0x6, 0xF, 0x3, 0x9,\n        0x2, 0xD, 0xB, 0x7, 0x5, 0x0, 0x8, 0xE]", "output": "definition gift_128_128_sbox_table :: \"nat list\" where\n  \"gift_128_128_sbox_table =\n   [1,10,4,12,6,15,3,9,2,13,11,7,5,0,8,14]\"", "metadata": {"component_type": "S-Box Table", "difficulty": "easy", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["list_operations", "sbox_substitution"], "extraction_time": "2026-01-24T13:11:48.287926"}}
{"instruction": "Translate this Inverse S-Box Table from GIFT-128/128 Python to Isabelle/HOL. Apply: use table lookup for 4-bit substitutions, handle nibble extraction and insertion, implement both forward and inverse S-boxes. Note: GIFT uses a 4-bit S-box applied to all nibbles in parallel.", "input": "# GIFT Inverse S-Box\nINV_SBOX = [0xD, 0x0, 0x8, 0x6, 0x2, 0xC, 0x4, 0xB,\n            0xE, 0x7, 0x1, 0xA, 0x3, 0x9, 0xF, 0x5]", "output": "definition gift_128_128_sbox_inv_table :: \"nat list\" where\n  \"gift_128_128_sbox_inv_table =\n   [13,0,8,6,2,12,4,11,14,7,1,10,3,9,15,5]\"", "metadata": {"component_type": "Inverse S-Box Table", "difficulty": "easy", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["list_operations", "sbox_substitution"], "extraction_time": "2026-01-24T13:11:48.288156"}}
{"instruction": "Translate this S-Box Function from GIFT-128/128 Python to Isabelle/HOL. Apply: use table lookup for 4-bit substitutions, handle nibble extraction and insertion, implement both forward and inverse S-boxes. Note: GIFT uses a 4-bit S-box applied to all nibbles in parallel.", "input": "def sbox(nibble: int) -> int:\n    \"\"\"Apply GIFT S-box to a 4-bit nibble\"\"\"\n    return SBOX[nibble]", "output": "definition gift_128_128_sbox :: \"4 word \\<Rightarrow> 4 word\" where\n  \"gift_128_128_sbox x = of_nat (gift_128_128_sbox_table ! unat x)\"", "metadata": {"component_type": "S-Box Function", "difficulty": "medium", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["list_operations", "function_definition", "sbox_substitution", "nibble_operations"], "extraction_time": "2026-01-24T13:11:48.288389"}}
{"instruction": "Translate this Inverse S-Box Function from GIFT-128/128 Python to Isabelle/HOL. Apply: use table lookup for 4-bit substitutions, handle nibble extraction and insertion, implement both forward and inverse S-boxes. Note: GIFT uses a 4-bit S-box applied to all nibbles in parallel.", "input": "def sbox_inv(nibble: int) -> int:\n    \"\"\"Apply inverse GIFT S-box to a 4-bit nibble\"\"\"\n    return INV_SBOX[nibble]", "output": "definition gift_128_128_sbox_inv :: \"4 word \\<Rightarrow> 4 word\" where\n  \"gift_128_128_sbox_inv x = of_nat (gift_128_128_sbox_inv_table ! unat x)\"", "metadata": {"component_type": "Inverse S-Box Function", "difficulty": "medium", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["list_operations", "function_definition", "sbox_substitution", "nibble_operations"], "extraction_time": "2026-01-24T13:11:48.288659"}}
{"instruction": "Translate this Permutation Order Table from GIFT-128/128 Python to Isabelle/HOL. Apply: implement permutation using formula: (32 * i) % 127, handle exception bit position, use bit extraction and insertion. Note: GIFT permutation: P(i) = (32 * i) % 127 for i < 127, P(127) = 127.", "input": "# GIFT Permutation Order\n# P(i) = (16 * i) % 63 for i < 63, P(63) = 63\nPERM_ORDER = [...]", "output": "definition gift_128_128_perm_order :: \"nat list\" where\n  \"gift_128_128_perm_order = map (\\<lambda>i. if i = 127 then 127 else (32 * i) mod 127) [0..<128]\"", "metadata": {"component_type": "Permutation Order Table", "difficulty": "medium", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "list_operations", "bit_permutation"], "extraction_time": "2026-01-24T13:11:48.288936"}}
{"instruction": "Translate this Inverse Permutation Order Table from GIFT-128/128 Python to Isabelle/HOL. Apply: implement permutation using formula: (32 * i) % 127, handle exception bit position, use bit extraction and insertion. Note: GIFT permutation: P(i) = (32 * i) % 127 for i < 127, P(127) = 127.", "input": "# GIFT Inverse Permutation Order\n# Inverse mapping for P(i)\nPERM_INV_ORDER = [...]", "output": "definition gift_128_128_perm_inv_order :: \"nat list\" where\n  \"gift_128_128_perm_inv_order = map (\\<lambda>i. if i = 127 then 127 else (4 * i) mod 127) [0..<128]\"", "metadata": {"component_type": "Inverse Permutation Order Table", "difficulty": "medium", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "list_operations", "bit_permutation"], "extraction_time": "2026-01-24T13:11:48.289208"}}
{"instruction": "Translate this Round Constants from GIFT-128/128 Python to Isabelle/HOL. Apply: implement SPN structure: SubCells → PermBits → AddRoundKey, apply all operations in sequence, handle round constants and key addition. Note: GIFT round: SubCells (S-box layer) → PermBits (bit permutation) → AddRoundKey (key + round constant).", "input": "# GIFT Round Constants for 40 rounds\n    ROUND_CONSTANTS = [0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3E, 0x3D, 0x3B, 0x37, 0x2F, 0x1E, 0x3C, 0x39, 0x33, 0x27, 0x0E, 0x1D, 0x3A, 0x35, 0x2B, 0x16, 0x2C, 0x18, 0x30, 0x21, 0x02, 0x05, 0x0B]", "output": "definition gift_128_128_round_constants :: \"nat list\" where\n  \"gift_128_128_round_constants =\n   [1,3,7,15,31,62,61,59,55,47,30,60,57,51,39,14,29,58,53,43,\n    22,44,24,48,33,2,5,11,23,46,28,56,49,35,6,13,27,54,45,26]\"\n\ntype_synonym key_state = \"16 word list\"", "metadata": {"component_type": "Round Constants", "difficulty": "easy", "semantic_group": "constants", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "list_operations"], "extraction_time": "2026-01-24T13:11:48.289604"}}
{"instruction": "Translate this Get Nibble Helper from GIFT-128/128 Python to Isabelle/HOL. Apply: implement nibble/bit extraction operations, use bit masking and shifting, handle word boundaries correctly. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def get_nibble(state: int, i: int) -> int:\n    \"\"\"Extract nibble i from state\"\"\"\n    return (state >> (4 * i)) & 0xF", "output": "definition gift_128_128_get_nibble :: \"128 word \\<Rightarrow> nat \\<Rightarrow> 4 word\" where\n  \"gift_128_128_get_nibble s i =\n     ucast (take_bit 4 (drop_bit (4*i) s))\"", "metadata": {"component_type": "Get Nibble Helper", "difficulty": "medium", "semantic_group": "helpers", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition", "nibble_operations"], "extraction_time": "2026-01-24T13:11:48.289854"}}
{"instruction": "Translate this Set Nibble Helper from GIFT-128/128 Python to Isabelle/HOL. Apply: implement nibble/bit extraction operations, use bit masking and shifting, handle word boundaries correctly. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def set_nibble(state: int, i: int, value: int) -> int:\n    \"\"\"Set nibble i in state to value\"\"\"\n    mask = 0xF << (4 * i)\n    return (state & ~mask) | ((value & 0xF) << (4 * i))", "output": "definition gift_128_128_set_nibble :: \"128 word \\<Rightarrow> nat \\<Rightarrow> 4 word \\<Rightarrow> 128 word\" where\n  \"gift_128_128_set_nibble s i v =\n     or (and s (not (push_bit (4*i) (mask 4)))) (push_bit (4*i) (ucast v))\"", "metadata": {"component_type": "Set Nibble Helper", "difficulty": "medium", "semantic_group": "helpers", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition", "nibble_operations"], "extraction_time": "2026-01-24T13:11:48.290071"}}
{"instruction": "Translate this Get Bit Helper from GIFT-128/128 Python to Isabelle/HOL. Apply: implement nibble/bit extraction operations, use bit masking and shifting, handle word boundaries correctly. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def get_bit(state: int, i: int) -> int:\n    \"\"\"Extract bit i from state\"\"\"\n    return (state >> i) & 1", "output": "definition gift_128_128_get_bit :: \"128 word \\<Rightarrow> nat \\<Rightarrow> 1 word\" where\n  \"gift_128_128_get_bit s i = ucast (take_bit 1 (drop_bit i s))\"", "metadata": {"component_type": "Get Bit Helper", "difficulty": "medium", "semantic_group": "helpers", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.290316"}}
{"instruction": "Translate this Set Bit Helper from GIFT-128/128 Python to Isabelle/HOL. Apply: implement nibble/bit extraction operations, use bit masking and shifting, handle word boundaries correctly. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def set_bit(state: int, i: int, value: int) -> int:\n    \"\"\"Set bit i in state to value (0 or 1)\"\"\"\n    if value:\n        return state | (1 << i)\n    else:\n        return state & ~(1 << i)", "output": "definition gift_128_128_set_bit :: \"128 word \\<Rightarrow> nat \\<Rightarrow> 1 word \\<Rightarrow> 128 word\" where\n  \"gift_128_128_set_bit s i v =\n     or (and s (not (push_bit i 1))) (push_bit i (ucast v))\"", "metadata": {"component_type": "Set Bit Helper", "difficulty": "medium", "semantic_group": "helpers", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.290558"}}
{"instruction": "Translate this Key Setup Function from GIFT-128/128 Python to Isabelle/HOL. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def key_setup(key: int):\n        \"\"\"Convert 128-bit key to 8×16-bit words (key_state)\n        \n        Semantic: Decompose key into word array [W7, W6, W5, W4, W3, W2, W1, W0]\n        Composition: Extract 16-bit slices from MSB to LSB\n        \"\"\"\n        if key < 0 or key >= (1 << 128):\n            raise ValueError(\"Key must be 128-bit (0 <= key < 2^128)\")\n        \n        key_words = []\n        for i in range(7, -1, -1):  # Extract W7 (MSB) to W0 (LSB)\n            word = (key >> (16 * i)) & 0xFFFF\n            key_words.append(word)\n        \n        return key_words  # [W7, W6, W5, W4, W3, W2, W1, W0]", "output": "definition gift_128_128_key_setup :: \"128 word \\<Rightarrow> key_state\" where\n  \"gift_128_128_key_setup k =\n   [ ucast (take_bit 16 (drop_bit 112 k)),\n     ucast (take_bit 16 (drop_bit 96 k)),\n     ucast (take_bit 16 (drop_bit 80 k)),\n     ucast (take_bit 16 (drop_bit 64 k)),\n     ucast (take_bit 16 (drop_bit 48 k)),\n     ucast (take_bit 16 (drop_bit 32 k)),\n     ucast (take_bit 16 (drop_bit 16 k)),\n     ucast (take_bit 16 k) ]\"", "metadata": {"component_type": "Key Setup Function", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "list_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.290913"}}
{"instruction": "Translate this Key Update Function from GIFT-128/128 Python to Isabelle/HOL. Apply: implement word rotation and reordering, use 16-bit word operations, handle key state as list of words. Note: GIFT key update rotates and reorders 16-bit words in the key state.", "input": "def update_key(key_words):\n        \"\"\"Update key state for next round (key schedule)\n        \n        Semantic: Circular shift + rotations on W1 and W0\n        Transformation: [W7,W6,W5,W4,W3,W2,W1,W0] → [ROR(W1,12), ROR(W0,2), W7,W6,W5,W4,W3,W2]\n        \"\"\"\n        W7, W6, W5, W4, W3, W2, W1, W0 = key_words\n        \n        # Step 1: Circular shift\n        new_words = [W1, W0, W7, W6, W5, W4, W3, W2]\n        \n        # Step 2: Apply rotations to new W0 and W1\n        w0_new = ror_16(new_words[1], 2)    # ROR(W0, 2)\n        w1_new = ror_16(new_words[0], 12)   # ROR(W1, 12)\n        \n        new_words[1] = w0_new\n        new_words[0] = w1_new\n        \n        return new_words\n    \n    # =========================================================================\n    # ROUND PRIMITIVES (Match Isabelle subsections)\n    # =========================================================================", "output": "definition gift_128_128_key_update :: \"key_state \\<Rightarrow> key_state\" where\n  \"gift_128_128_key_update ks =\n   (case ks of\n     [W7,W6,W5,W4,W3,W2,W1,W0] \\<Rightarrow>\n       [ gift_128_128_ror16 W1 12,   \n         gift_128_128_ror16 W0 2,    \n         W7, W6, W5, W4, W3, W2 ]\n   | _ \\<Rightarrow> ks)\"", "metadata": {"component_type": "Key Update Function", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "list_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.291284"}}
{"instruction": "Translate this Rotation Helper from GIFT-128/128 Python to Isabelle/HOL. Apply: implement nibble/bit extraction operations, use bit masking and shifting, handle word boundaries correctly. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def ror_16(word: int, n: int) -> int:\n    \"\"\"Right rotate 16-bit word by n bits\"\"\"\n    return ((word >> n) | (word << (16 - n))) & 0xFFFF", "output": "definition gift_128_128_ror16 :: \"16 word \\<Rightarrow> nat \\<Rightarrow> 16 word\" where\n  \"gift_128_128_ror16 w n =\n     or (drop_bit n w) (push_bit (16 - n) (take_bit n w))\"", "metadata": {"component_type": "Rotation Helper", "difficulty": "medium", "semantic_group": "helpers", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.291677"}}
{"instruction": "Translate this Add Round Key Iteration from GIFT-128/128 Python to Isabelle/HOL. Apply: implement SPN structure: SubCells → PermBits → AddRoundKey, apply all operations in sequence, handle round constants and key addition. Note: GIFT round: SubCells (S-box layer) → PermBits (bit permutation) → AddRoundKey (key + round constant).", "input": "def add_round_key_iter(state: int, key_words: list) -> int:\n    \"\"\"Add key bits from W6 and W2 to state\"\"\"\n    result = state\n    U = key_words[1]  # W6\n    V = key_words[5]  # W2\n    \n    for i in range(16):\n        u_bit = (U >> i) & 1\n        v_bit = (V >> i) & 1\n        result ^= (u_bit << (4 * i))\n        result ^= (v_bit << (4 * i + 1))\n    \n    return result", "output": "definition gift_128_128_add_round_key_iter :: \"128 word \\<Rightarrow> key_state \\<Rightarrow> nat \\<Rightarrow> 128 word\" where\n  \"gift_128_128_add_round_key_iter s ks r =\n     fold (\\<lambda>i acc.\n            xor (xor acc \n                  (push_bit (4*i)\n                    (ucast (take_bit 1 (drop_bit i (ks ! 1))))))\n                  (push_bit (4*i+1)\n                    (ucast (take_bit 1 (drop_bit i (ks ! 5))))))\n          [0..<32]\n          s\"", "metadata": {"component_type": "Add Round Key Iteration", "difficulty": "hard", "semantic_group": "key_mixing", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "list_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.292097"}}
{"instruction": "Translate this Add Round Constant from GIFT-128/128 Python to Isabelle/HOL. Apply: implement SPN structure: SubCells → PermBits → AddRoundKey, apply all operations in sequence, handle round constants and key addition. Note: GIFT round: SubCells (S-box layer) → PermBits (bit permutation) → AddRoundKey (key + round constant).", "input": "def add_round_constant(state: int, round_idx: int) -> int:\n    \"\"\"Add round constant bits to state\"\"\"\n    result = state\n    rc = ROUND_CONSTANTS[round_idx]\n    \n    for i in range(6):\n        rc_bit = (rc >> i) & 1\n        result ^= (rc_bit << (4 * i + 3))\n    \n    result ^= (1 << 63)\n    \n    return result", "output": "definition gift_128_128_add_round_constant :: \"128 word \\<Rightarrow> nat \\<Rightarrow> 128 word\" where\n  \"gift_128_128_add_round_constant s r =\n     xor \n       (fold \n         (\\<lambda>i acc. xor acc\n           (push_bit (4*i+3)\n             (ucast (take_bit 1 (drop_bit i\n               (of_nat (gift_128_128_round_constants ! r) :: 6 word))))))\n         [0..<6]\n         s)\n       (push_bit 127 1)\"", "metadata": {"component_type": "Add Round Constant", "difficulty": "medium", "semantic_group": "key_mixing", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "list_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.292512"}}
{"instruction": "Translate this Add Round Key Function from GIFT-128/128 Python to Isabelle/HOL. Apply: implement SPN structure: SubCells → PermBits → AddRoundKey, apply all operations in sequence, handle round constants and key addition. Note: GIFT round: SubCells (S-box layer) → PermBits (bit permutation) → AddRoundKey (key + round constant).", "input": "def add_round_key(state: int, key_words: list, round_idx: int) -> int:\n    \"\"\"Complete AddRoundKey: key bits + round constant\"\"\"\n    state = add_round_key_iter(state, key_words)\n    state = add_round_constant(state, round_idx)\n    return state", "output": "definition gift_128_128_add_round_key :: \"128 word \\<Rightarrow> key_state \\<Rightarrow> nat \\<Rightarrow> 128 word\" where\n  \"gift_128_128_add_round_key s ks r =\n     gift_128_128_add_round_constant\n       (gift_128_128_add_round_key_iter s ks r) r\"", "metadata": {"component_type": "Add Round Key Function", "difficulty": "hard", "semantic_group": "key_mixing", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.293095"}}
{"instruction": "Translate this S-Box Layer Function from GIFT-128/128 Python to Isabelle/HOL. Apply: use table lookup for 4-bit substitutions, handle nibble extraction and insertion, implement both forward and inverse S-boxes. Note: GIFT uses a 4-bit S-box applied to all nibbles in parallel.", "input": "def sub_cells(state: int) -> int:\n    \"\"\"SubCells: Apply S-box to each 4-bit nibble\"\"\"\n    result = 0\n    for i in range(16):  # 16 nibbles in 64-bit state\n        nibble = (state >> (4 * i)) & 0xF\n        substituted = SBOX[nibble]\n        result |= (substituted << (4 * i))\n    return result", "output": "definition gift_128_128_sbox_layer :: \"128 word \\<Rightarrow> 128 word\" where\n  \"gift_128_128_sbox_layer s =\n     fold (\\<lambda>i acc. \n            gift_128_128_set_nibble acc i (gift_128_128_sbox (gift_128_128_get_nibble acc i)))\n          [0..<32]\n          s\"", "metadata": {"component_type": "S-Box Layer Function", "difficulty": "medium", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "list_operations", "function_definition", "sbox_substitution", "nibble_operations"], "extraction_time": "2026-01-24T13:11:48.293530"}}
{"instruction": "Translate this Inverse S-Box Layer Function from GIFT-128/128 Python to Isabelle/HOL. Apply: use table lookup for 4-bit substitutions, handle nibble extraction and insertion, implement both forward and inverse S-boxes. Note: GIFT uses a 4-bit S-box applied to all nibbles in parallel.", "input": "def inv_sub_cells(state: int) -> int:\n    \"\"\"Inverse SubCells for decryption\"\"\"\n    result = 0\n    for i in range(16):\n        nibble = (state >> (4 * i)) & 0xF\n        substituted = INV_SBOX[nibble]\n        result |= (substituted << (4 * i))\n    return result", "output": "definition gift_128_128_sbox_layer_inv :: \"128 word \\<Rightarrow> 128 word\" where\n  \"gift_128_128_sbox_layer_inv s =\n     fold (\\<lambda>i acc. \n            gift_128_128_set_nibble acc i (gift_128_128_sbox_inv (gift_128_128_get_nibble acc i)))\n          [0..<32]\n          s\"", "metadata": {"component_type": "Inverse S-Box Layer Function", "difficulty": "medium", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "list_operations", "function_definition", "sbox_substitution", "nibble_operations"], "extraction_time": "2026-01-24T13:11:48.293939"}}
{"instruction": "Translate this Permutation Layer Function from GIFT-128/128 Python to Isabelle/HOL. Apply: implement permutation using formula: (32 * i) % 127, handle exception bit position, use bit extraction and insertion. Note: GIFT permutation: P(i) = (32 * i) % 127 for i < 127, P(127) = 127.", "input": "def perm_bits(state: int) -> int:\n    \"\"\"PermBits: Bit permutation (Diffusion primitive)\"\"\"\n    result = 0\n    \n    # Process bits 0-62: P(i) = 16*i mod 63\n    for src_pos in range(63):\n        src_bit = (state >> src_pos) & 1\n        dst_pos = (16 * src_pos) % 63\n        result |= (src_bit << dst_pos)\n    \n    # Bit 63 remains at position 63\n    result |= (state & (1 << 63))\n    \n    return result", "output": "definition gift_128_128_perm_layer :: \"128 word \\<Rightarrow> 128 word\" where\n  \"gift_128_128_perm_layer s =\n     fold (\\<lambda>i acc.\n            if gift_128_128_get_bit s i = 1\n            then gift_128_128_set_bit acc (gift_128_128_perm_order ! i) 1\n            else acc)\n          [0..<128]\n          (0 :: 128 word)\"", "metadata": {"component_type": "Permutation Layer Function", "difficulty": "hard", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "function_definition", "bit_permutation"], "extraction_time": "2026-01-24T13:11:48.294506"}}
{"instruction": "Translate this Inverse Permutation Layer Function from GIFT-128/128 Python to Isabelle/HOL. Apply: implement permutation using formula: (32 * i) % 127, handle exception bit position, use bit extraction and insertion. Note: GIFT permutation: P(i) = (32 * i) % 127 for i < 127, P(127) = 127.", "input": "def inv_perm_bits(state: int) -> int:\n    \"\"\"Inverse PermBits for decryption\"\"\"\n    result = 0\n    \n    # Process bits 0-62 using precomputed inverse mapping\n    for dst_pos in range(63):\n        src_bit = (state >> dst_pos) & 1\n        src_pos = INV_PERM[dst_pos]\n        result |= (src_bit << src_pos)\n    \n    # Bit 63\n    result |= (state & (1 << 63))\n    \n    return result", "output": "definition gift_128_128_perm_layer_inv :: \"128 word \\<Rightarrow> 128 word\" where\n  \"gift_128_128_perm_layer_inv s =\n     fold (\\<lambda>i acc.\n            if gift_128_128_get_bit s i = 1\n            then gift_128_128_set_bit acc (gift_128_128_perm_inv_order ! i) 1\n            else acc)\n          [0..<128]\n          (0 :: 128 word)\"", "metadata": {"component_type": "Inverse Permutation Layer Function", "difficulty": "hard", "semantic_group": "primitives", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "list_operations", "function_definition", "bit_permutation"], "extraction_time": "2026-01-24T13:11:48.294932"}}
{"instruction": "Translate this Encrypt Round Function from GIFT-128/128 Python to Isabelle/HOL. Apply: implement SPN structure: SubCells → PermBits → AddRoundKey, apply all operations in sequence, handle round constants and key addition. Note: GIFT round: SubCells (S-box layer) → PermBits (bit permutation) → AddRoundKey (key + round constant).", "input": "def encrypt_round(state: int, key_words, round_idx: int):\n        \"\"\"SPN Round Composition: SubCells → PermBits → AddRoundKey\n        \n        Semantic: Standard SPN round structure\n        Property: Deterministic state and key update\n        Composition: sub_cells ∘ perm_bits ∘ add_round_key\n        Return: (new_state, new_key_words)\n        \"\"\"\n        # 1. SubCells (non-linear substitution)\n        state = sub_cells(state)\n        \n        # 2. PermBits (linear diffusion)\n        state = perm_bits(state)\n        \n        # 3. AddRoundKey (key mixing)\n        state = add_round_key(state, key_words, round_idx)\n        \n        # 4. Update key for next round\n        new_key_words = update_key(key_words)\n        \n        return state, new_key_words", "output": "definition gift_128_128_encrypt_round ::\n  \"128 word \\<Rightarrow> key_state \\<Rightarrow> nat \\<Rightarrow> (128 word \\<times> key_state)\" where\n  \"gift_128_128_encrypt_round s ks r =\n   (let s1 = gift_128_128_sbox_layer s;\n        s2 = gift_128_128_perm_layer s1;\n        s3 = gift_128_128_add_round_key s2 ks r;\n        ks' = gift_128_128_key_update ks\n    in (s3, ks'))\"", "metadata": {"component_type": "Encrypt Round Function", "difficulty": "hard", "semantic_group": "round_operations", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "function_definition", "bit_permutation"], "extraction_time": "2026-01-24T13:11:48.295460"}}
{"instruction": "Translate this Decrypt Round Function from GIFT-128/128 Python to Isabelle/HOL. Apply: implement SPN structure: SubCells → PermBits → AddRoundKey, apply all operations in sequence, handle round constants and key addition. Note: GIFT round: SubCells (S-box layer) → PermBits (bit permutation) → AddRoundKey (key + round constant).", "input": "def decrypt_round(state: int, key_words, round_idx: int):\n        \"\"\"Inverse SPN Round Composition\n        \n        Semantic: AddRoundKey⁻¹ ∘ PermBits⁻¹ ∘ SubCells⁻¹\n        Composition: add_round_key ∘ inv_perm_bits ∘ inv_sub_cells\n        Note: Key update not needed for decryption rounds\n        \"\"\"\n        # 1. Inverse AddRoundKey (XOR is self-inverse)\n        state = add_round_key(state, key_words, round_idx)\n        \n        # 2. Inverse PermBits\n        state = inv_perm_bits(state)\n        \n        # 3. Inverse SubCells\n        state = inv_sub_cells(state)\n        \n        return state, key_words  # Key stays same for decryption\n    \n    # =========================================================================\n    # ITERATION (Match gift_64_128_encrypt_iterate)\n    # =========================================================================", "output": "definition gift_128_128_decrypt_round ::\n  \"128 word \\<Rightarrow> key_state \\<Rightarrow> nat \\<Rightarrow> (128 word \\<times> key_state)\" where\n  \"gift_128_128_decrypt_round s ks r =\n   (let s1 = gift_128_128_add_round_key s ks r;   \n        s2 = gift_128_128_perm_layer_inv s1;      \n        s3 = gift_128_128_sbox_layer_inv s2       \n    in (s3, ks))\"", "metadata": {"component_type": "Decrypt Round Function", "difficulty": "hard", "semantic_group": "round_operations", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "function_definition", "bit_permutation"], "extraction_time": "2026-01-24T13:11:48.295995"}}
{"instruction": "Translate this Generate Round Keys (Recursive) from GIFT-128/128 Python to Isabelle/HOL. Apply: implement SPN structure: SubCells → PermBits → AddRoundKey, apply all operations in sequence, handle round constants and key addition. Note: GIFT round: SubCells (S-box layer) → PermBits (bit permutation) → AddRoundKey (key + round constant).", "input": "def generate_round_keys(key_state: list, n: int) -> list:\n    \"\"\"Recursively generate n round keys\"\"\"\n    if n == 0:\n        return []\n    return [key_state] + generate_round_keys(update_key(key_state), n - 1)", "output": "fun gift_128_128_generate_round_keys :: \"key_state \\<Rightarrow> nat \\<Rightarrow> key_state list\" where\n  \"gift_128_128_generate_round_keys ks 0 = []\"\n| \"gift_128_128_generate_round_keys ks (Suc n) = \n     ks # gift_128_128_generate_round_keys (gift_128_128_key_update ks) n\"", "metadata": {"component_type": "Generate Round Keys (Recursive)", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["list_operations", "function_definition", "recursive_function"], "extraction_time": "2026-01-24T13:11:48.296674"}}
{"instruction": "Translate this Key Schedule Function from GIFT-128/128 Python to Isabelle/HOL. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def key_schedule(key: int) -> list:\n    \"\"\"Generate complete key schedule for decryption\"\"\"\n    initial_key = key_setup(key)\n    return generate_round_keys(initial_key, 40)", "output": "definition gift_128_128_key_schedule :: \"128 word \\<Rightarrow> key_state list\" where\n  \"gift_128_128_key_schedule k = \n     gift_128_128_generate_round_keys (gift_128_128_key_setup k) 40\"", "metadata": {"component_type": "Key Schedule Function", "difficulty": "medium", "semantic_group": "key_expansion", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "function_definition"], "extraction_time": "2026-01-24T13:11:48.297213"}}
{"instruction": "Translate this Encrypt Iterate Wrapper from GIFT-128/128 Python to Isabelle/HOL. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def encrypt_iterate(state: int, key_state):\n        \"\"\"Iterative Round Application\n        \n        Semantic: Apply all rounds sequentially\n        Implementation: Loop over round count\n        Composition: Repeated application of encrypt_round\n        \"\"\"\n        key_words = key_state\n        \n        for r in range(rounds):\n            state, key_words = encrypt_round(state, key_words, r)\n        \n        return state", "output": "definition gift_128_128_encrypt_iterate ::\n  \"128 word \\<Rightarrow> key_state \\<Rightarrow> 128 word\" where\n\"gift_128_128_encrypt_iterate s ks =\n   gift_128_128_encrypt_iter s ks 0 40\"", "metadata": {"component_type": "Encrypt Iterate Wrapper", "difficulty": "medium", "semantic_group": "iteration", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "function_definition"], "extraction_time": "2026-01-24T13:11:48.298001"}}
{"instruction": "Translate this Decrypt Iterate Wrapper from GIFT-128/128 Python to Isabelle/HOL. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def decrypt_iterate(state: int, key_schedule):\n        \"\"\"Inverse Iterative Round Application\n        \n        Semantic: Apply all rounds in reverse order\n        Implementation: Process rounds backwards\n        Composition: Repeated application of decrypt_round\n        \"\"\"\n        # Execute rounds in reverse order\n        for r in range(rounds - 1, -1, -1):\n            key_words = key_schedule[r]\n            state, _ = decrypt_round(state, key_words, r)\n        \n        return state\n    \n    # =========================================================================\n    # BLOCK OPERATIONS (Match gift_64_128_encrypt_block / decrypt_block)\n    # =========================================================================", "output": "definition gift_128_128_decrypt_iterate ::\n  \"128 word \\<Rightarrow> key_state list \\<Rightarrow> 128 word\" where\n\"gift_128_128_decrypt_iterate s keys =\n   gift_128_128_decrypt_iter s (rev keys) (40 - 1)\"", "metadata": {"component_type": "Decrypt Iterate Wrapper", "difficulty": "medium", "semantic_group": "iteration", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "list_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.298556"}}
{"instruction": "Translate this Encrypt Iteration (Recursive) from GIFT-128/128 Python to Isabelle/HOL. Apply: convert for-loops to recursion, use base case and recursive case, handle round counter and state updates. Note: GIFT uses 40 rounds in an SPN structure.", "input": "def encrypt_iter(state: int, key_state: list, round_idx: int, rounds_left: int) -> int:\n    \"\"\"Recursive encryption iteration\"\"\"\n    if rounds_left == 0:\n        return state\n    new_state, new_key = encrypt_round(state, key_state, round_idx)\n    return encrypt_iter(new_state, new_key, round_idx + 1, rounds_left - 1)", "output": "fun gift_128_128_encrypt_iter ::\n  \"128 word \\<Rightarrow> key_state \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 128 word\" where\n  \"gift_128_128_encrypt_iter s ks r 0 = s\"\n| \"gift_128_128_encrypt_iter s ks r (Suc n) =\n     (let (s', ks') = gift_128_128_encrypt_round s ks r\n      in gift_128_128_encrypt_iter s' ks' (r + 1) n)\"", "metadata": {"component_type": "Encrypt Iteration (Recursive)", "difficulty": "hard", "semantic_group": "iteration", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["function_definition", "recursive_function"], "extraction_time": "2026-01-24T13:11:48.298978"}}
{"instruction": "Translate this Decrypt Iteration (Recursive) from GIFT-128/128 Python to Isabelle/HOL. Apply: convert for-loops to recursion, use base case and recursive case, handle round counter and state updates. Note: GIFT uses 40 rounds in an SPN structure.", "input": "def decrypt_iter(state: int, key_schedule: list, round_idx: int) -> int:\n    \"\"\"Recursive decryption iteration\"\"\"\n    if round_idx < 0:\n        return state\n    key_words = key_schedule[round_idx]\n    state, _ = decrypt_round(state, key_words, round_idx)\n    return decrypt_iter(state, key_schedule, round_idx - 1)", "output": "fun gift_128_128_decrypt_iter ::\n  \"128 word \\<Rightarrow> key_state list \\<Rightarrow> nat \\<Rightarrow> 128 word\" where\n  \"gift_128_128_decrypt_iter s [] _ = s\"\n| \"gift_128_128_decrypt_iter s (k#ks) r =\n     (if r = 0 then gift_128_128_add_round_key s k r\n      else let (s', _) = gift_128_128_decrypt_round s k r\n            in gift_128_128_decrypt_iter s' ks (r-1))\"", "metadata": {"component_type": "Decrypt Iteration (Recursive)", "difficulty": "hard", "semantic_group": "iteration", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["list_operations", "function_definition", "recursive_function"], "extraction_time": "2026-01-24T13:11:48.299413"}}
{"instruction": "Translate this Encrypt Block Function from GIFT-128/128 Python to Isabelle/HOL. Apply: coordinate key setup, iteration, and round functions, handle initial and final operations, maintain block state throughout encryption/decryption. Note: GIFT-128/128 processes blocks through 40 rounds.", "input": "def encrypt_block(plaintext: int, key: int) -> int:\n    \"\"\"Block Encryption: Key Setup → Iteration\"\"\"\n    # 1. Setup initial key state\n    key_state = key_setup(key)\n    \n    # 2. Apply all rounds via iteration\n    return encrypt_iterate(plaintext, key_state)", "output": "definition gift_128_128_encrypt_block :: \"128 word \\<Rightarrow> 128 word \\<Rightarrow> 128 word\" where\n\"gift_128_128_encrypt_block plaintext key =\n   gift_128_128_encrypt_iterate plaintext (gift_128_128_key_setup key)\"", "metadata": {"component_type": "Encrypt Block Function", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.300042"}}
{"instruction": "Translate this Decrypt Block Function from GIFT-128/128 Python to Isabelle/HOL. Apply: coordinate key setup, iteration, and round functions, handle initial and final operations, maintain block state throughout encryption/decryption. Note: GIFT-128/128 processes blocks through 40 rounds.", "input": "def decrypt_block(ciphertext: int, key: int) -> int:\n    \"\"\"Block Decryption: Key Schedule → Inverse Iteration\"\"\"\n    # 1. Generate all round keys (key schedule)\n    key_state = key_setup(key)\n    key_schedule = []\n    \n    for r in range(28):\n        key_schedule.append(key_state)\n        key_state = update_key(key_state)\n    \n    # 2. Apply inverse rounds via iteration\n    return decrypt_iterate(ciphertext, key_schedule)", "output": "definition gift_128_128_decrypt_block :: \"128 word \\<Rightarrow> 128 word \\<Rightarrow> 128 word\" where\n  \"gift_128_128_decrypt_block ciphertext key = \n      gift_128_128_decrypt_iterate ciphertext (gift_128_128_key_schedule key) \"", "metadata": {"component_type": "Decrypt Block Function", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["loop_to_recursion", "list_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.300579"}}
{"instruction": "Translate this Encrypt (Top-level) from GIFT-128/128 Python to Isabelle/HOL. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def encrypt(plaintext: int, key: int) -> int:\n    \"\"\"Top-level Encryption Interface\"\"\"\n    return encrypt_block(plaintext, key)", "output": "definition gift_128_128_encrypt :: \"128 word \\<Rightarrow> 128 word \\<Rightarrow> 128 word\" where\n\"gift_128_128_encrypt key plaintext = gift_128_128_encrypt_block plaintext key\"", "metadata": {"component_type": "Encrypt (Top-level)", "difficulty": "medium", "semantic_group": "top_level", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.301124"}}
{"instruction": "Translate this Decrypt (Top-level) from GIFT-128/128 Python to Isabelle/HOL. Note: GIFT is a lightweight SPN cipher with 4-bit S-box and bit permutation.", "input": "def decrypt(ciphertext: int, key: int) -> int:\n    \"\"\"Top-level Decryption Interface\"\"\"\n    return decrypt_block(ciphertext, key)", "output": "definition gift_128_128_decrypt :: \"128 word \\<Rightarrow> 128 word \\<Rightarrow> 128 word\" where\n\"gift_128_128_decrypt key ciphertext = gift_128_128_decrypt_block ciphertext key\"\n\n\n\nend", "metadata": {"component_type": "Decrypt (Top-level)", "difficulty": "medium", "semantic_group": "top_level", "cipher": "GIFT", "family": "SPN", "variant": {"block_size": 128, "key_size": 128, "rounds": 40, "nibbles_per_block": 32}, "algorithm_params": {"word_size": 16, "sbox_count": 32, "key_words": 8, "constant_bits": 6, "structure": "SPN (SubCells → PermBits → AddRoundKey)", "sbox_size": 4, "permutation_formula": "(32 * i) % 127", "permutation_exception": 127, "permutation_size": 128, "key_update": "word rotation and reordering"}, "transformation_patterns": ["function_definition"], "extraction_time": "2026-01-24T13:11:48.301652"}}
{"instruction": "Translate this word_size Constant from SPARX-128/128 Python to Isabelle/HOL. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "# 16-bit words for SPARX operations\nword_size = 16", "output": "definition sparx_128_128_word_size :: nat where \"sparx_128_128_word_size = 16\"", "metadata": {"component_type": "word_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.308970"}}
{"instruction": "Translate this n_branches Constant from SPARX-128/128 Python to Isabelle/HOL. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "# 4 branches\nn_branches = 4", "output": "definition sparx_128_128_n_branches :: nat where \"sparx_128_128_n_branches = 4\"", "metadata": {"component_type": "n_branches Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.309403"}}
{"instruction": "Translate this n_words Constant from SPARX-128/128 Python to Isabelle/HOL. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "# 8 total words in state\nn_words = 8", "output": "definition sparx_128_128_n_words :: nat where \"sparx_128_128_n_words = 8\"", "metadata": {"component_type": "n_words Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.309925"}}
{"instruction": "Translate this n_steps Constant from SPARX-128/128 Python to Isabelle/HOL. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "# Number of steps\nn_steps = 8", "output": "definition sparx_128_128_n_steps :: nat where \"sparx_128_128_n_steps = 8\"", "metadata": {"component_type": "n_steps Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["step_iteration"], "extraction_time": "2026-01-24T13:11:48.310322"}}
{"instruction": "Translate this rounds_per_step Constant from SPARX-128/128 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "# Rounds per step\nrounds_per_step = 4", "output": "definition sparx_128_128_rounds_per_step :: nat where \"sparx_128_128_rounds_per_step = 4\"", "metadata": {"component_type": "rounds_per_step Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["step_iteration"], "extraction_time": "2026-01-24T13:11:48.310716"}}
{"instruction": "Translate this total_rounds Constant from SPARX-128/128 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "# Total encryption rounds\ntotal_rounds = 32", "output": "definition sparx_128_128_total_rounds :: nat where \n  \"sparx_128_128_total_rounds = sparx_128_128_n_steps * sparx_128_128_rounds_per_step\"", "metadata": {"component_type": "total_rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.311032"}}
{"instruction": "Translate this key_size Constant from SPARX-128/128 Python to Isabelle/HOL. Apply: implement key expansion with rotations, generate round keys for all steps, handle whitening key extraction. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "# 128-bit key\nkey_size = 128", "output": "definition sparx_128_128_key_size :: nat where \"sparx_128_128_key_size = 128\"", "metadata": {"component_type": "key_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.311488"}}
{"instruction": "Translate this block_size Constant from SPARX-128/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle 8 words per block, maintain block structure. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "# 128-bit block\nblock_size = 128", "output": "definition sparx_128_128_block_size :: nat where \"sparx_128_128_block_size = 128\"", "metadata": {"component_type": "block_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.311901"}}
{"instruction": "Translate this A Permutation from SPARX-128/128 Python to Isabelle/HOL. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_A(x, y, width):\n        \"\"\"ARX A-permutation. Parametric by width (16 or 32).\"\"\"\n        mask = (1 << width) - 1\n        x = _ror(x, 7, width)\n        x = (x + y) & mask\n        y = _rol(y, 2, width)\n        y ^= x\n        return x, y", "output": "definition sparx_128_128_A_perm_16 :: \"16 word \\<Rightarrow> 16 word \\<Rightarrow> (16 word \\<times> 16 word)\" where\n  \"sparx_128_128_A_perm_16 x y = (\n    let x_rot = sparx_128_128_ror x 7;\n        x_new = x_rot + y;\n        y_rot = sparx_128_128_rol y 2;\n        y_new = xor y_rot x_new\n    in (x_new, y_new))\"", "metadata": {"component_type": "A Permutation", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.312621"}}
{"instruction": "Translate this A Permutation Inverse from SPARX-128/128 Python to Isabelle/HOL. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_A_inv(x, y, width):\n        \"\"\"Inverse A-permutation.\"\"\"\n        mask = (1 << width) - 1\n        y = _ror(y ^ x, 2, width)\n        x = _rol((x - y) & mask, 7, width)\n        return x, y\n\n    # -------------------------------------------------\n    # Linear Layer\n    # -------------------------------------------------", "output": "definition sparx_128_128_A_perm_16_inv :: \"16 word \\<Rightarrow> 16 word \\<Rightarrow> (16 word \\<times> 16 word)\" where\n  \"sparx_128_128_A_perm_16_inv x y = (\n    let y_temp = xor y x;\n        y_new = sparx_128_128_ror y_temp 2;\n        x_temp = x - y_new;\n        x_new = sparx_128_128_rol x_temp 7\n    in (x_new, y_new))\"", "metadata": {"component_type": "A Permutation Inverse", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.312990"}}
{"instruction": "Translate this Linear Word Function from SPARX-128/128 Python to Isabelle/HOL. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_L_w(x):\n        \"\"\"SPARX linear word function\"\"\"\n        return ((x << 8) ^ (x >> 8)) & 0xFFFF", "output": "definition sparx_128_128_L_w :: \"16 word \\<Rightarrow> 16 word\" where\n  \"sparx_128_128_L_w x = xor (push_bit 8 x) (drop_bit 8 x)\"", "metadata": {"component_type": "Linear Word Function", "difficulty": "easy", "semantic_group": "diffusion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition", "linear_diffusion"], "extraction_time": "2026-01-24T13:11:48.313297"}}
{"instruction": "Translate this Linear Layer from SPARX-128/128 Python to Isabelle/HOL. Apply: implement diffusion across branches, use XOR operations between words, handle 4 branches. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_linear_layer(s):\n        \"\"\"SPARX linear layer for 4 branches\"\"\"\n        t = sparx_L_w(s[0] ^ s[1] ^ s[2] ^ s[3])\n        return [\n            s[4] ^ t, s[5] ^ t,\n            s[6] ^ t, s[7] ^ t,\n            s[0], s[1], s[2], s[3]\n        ]", "output": "definition sparx_128_128_linear_layer :: \"16 word list \\<Rightarrow> 16 word list\" where\n\"sparx_128_128_linear_layer s = (\n  if length s = sparx_128_128_n_words then\n    let\n      t = sparx_128_128_L_w (xor (xor (s ! 0) (s ! 1)) (xor (s ! 2) (s ! 3)))\n    in\n      [ xor (s ! 4) t, xor (s ! 5) t,\n        xor (s ! 6) t, xor (s ! 7) t,\n        s ! 0, s ! 1, s ! 2, s ! 3 ]\n  else s)\"", "metadata": {"component_type": "Linear Layer", "difficulty": "medium", "semantic_group": "diffusion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "function_definition", "linear_diffusion"], "extraction_time": "2026-01-24T13:11:48.313782"}}
{"instruction": "Translate this Linear Layer Inverse from SPARX-128/128 Python to Isabelle/HOL. Apply: implement diffusion across branches, use XOR operations between words, handle 4 branches. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_linear_layer_inv(s):\n        \"\"\"Inverse SPARX linear layer for 4 branches\"\"\"\n        t = sparx_L_w(s[4] ^ s[5] ^ s[6] ^ s[7])\n        return [\n            s[4], s[5], s[6], s[7],\n            s[0] ^ t, s[1] ^ t, s[2] ^ t, s[3] ^ t\n        ]", "output": "definition sparx_128_128_linear_layer_inv :: \"16 word list \\<Rightarrow> 16 word list\" where\n\"sparx_128_128_linear_layer_inv s = (\n  if length s = sparx_128_128_n_words then\n    let\n      t = sparx_128_128_L_w (xor (xor (s ! 4) (s ! 5)) (xor (s ! 6) (s ! 7)))\n    in\n      [ s ! 4, s ! 5, s ! 6, s ! 7,\n        xor (s ! 0) t, xor (s ! 1) t, \n        xor (s ! 2) t, xor (s ! 3) t ]\n  else s)\"", "metadata": {"component_type": "Linear Layer Inverse", "difficulty": "medium", "semantic_group": "diffusion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "function_definition", "linear_diffusion"], "extraction_time": "2026-01-24T13:11:48.314175"}}
{"instruction": "Translate this Round Application from SPARX-128/128 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_apply_encrypt_round(state, round_keys):\n    \"\"\"Apply SPARX encrypt round\"\"\"\n    # n_branches = 4\n    if len(state) != 8 or len(round_keys) < 4:\n        return state\n    \n    result = []\n    for b in range(4):\n        s0 = state[2*b] ^ round_keys[b]\n        s0_new, s1_new = sparx_A(s0, state[2*b + 1], 16)\n        result.extend([s0_new, s1_new])\n    \n    return result", "output": "definition sparx_128_128_apply_encrypt_round ::\n  \"16 word list \\<Rightarrow> 16 word list \\<Rightarrow> 16 word list\" where\n\"sparx_128_128_apply_encrypt_round state round_keys = (\n  if length state = sparx_128_128_n_words \\<and> length round_keys = 4 then\n    let\n      (a0,a1) = sparx_128_128_A_perm_16 (xor (state!0) (round_keys!0))(state!1);\n      (a2,a3) = sparx_128_128_A_perm_16 (xor (state!2) (round_keys!1))(state!3);\n      (a4,a5) = sparx_128_128_A_perm_16 (xor (state!4) (round_keys!2))(state!5);\n      (a6,a7) = sparx_128_128_A_perm_16  (xor (state!6) (round_keys!3))(state!7)\n    in\n      [a0,a1,a2,a3,a4,a5,a6,a7]\n  else state\n)\"", "metadata": {"component_type": "Round Application", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.315030"}}
{"instruction": "Translate this Round Application Inverse from SPARX-128/128 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_apply_decrypt_round(state, round_keys):\n    \"\"\"Apply SPARX decrypt round (inverse)\"\"\"\n    # n_branches = 4\n    \n    if len(state) != 8 or len(round_keys) < 4:\n        return state\n    \n    result = []\n    for b in range(4):\n        s0_new, s1_new = sparx_A_inv(state[2*b], state[2*b + 1], 16)\n        s0_final = s0_new ^ round_keys[b]\n        result.extend([s0_final, s1_new])\n    \n    return result", "output": "definition sparx_128_128_apply_decrypt_round ::\n  \"16 word list \\<Rightarrow> 16 word list \\<Rightarrow> 16 word list\" where\n\"sparx_128_128_apply_decrypt_round state round_keys = (\n  if length state = sparx_128_128_n_words \\<and> length round_keys = 4 then\n    let\n      (s0', s1') = sparx_128_128_A_perm_16_inv (state ! 0) (state ! 1);\n      s0 = xor s0' (round_keys ! 0);\n      (s2', s3') = sparx_128_128_A_perm_16_inv (state ! 2) (state ! 3);\n      s2 = xor s2' (round_keys ! 1);\n      (s4', s5') = sparx_128_128_A_perm_16_inv (state ! 4) (state ! 5);\n      s4 = xor s4' (round_keys ! 2);\n      (s6', s7') = sparx_128_128_A_perm_16_inv (state ! 6) (state ! 7);\n      s6 = xor s6' (round_keys ! 3)\n    in\n      [ s0, s1',\n        s2, s3',\n        s4, s5',\n        s6, s7' ]\n  else state)\"", "metadata": {"component_type": "Round Application Inverse", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.315047"}}
{"instruction": "Translate this Key Schedule from SPARX-128/128 Python to Isabelle/HOL. Apply: implement key expansion with rotations, generate round keys for all steps, handle whitening key extraction. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_generate_key_schedule():\n        \"\"\"\n        Generates subkeys using 16-bit words.\n        Produces enough 16-bit words to satisfy all rounds + whitening.\n        \"\"\"\n        k = [(master_key >> (16 * i)) & 0xFFFF for i in range(key_size // 16)]\n        rk = []\n        c = 1\n        \n        # We need enough 16-bit words for (total_rounds + 1) injections.\n        # Each injection XORs the first word of each branch.\n        # S-64 (b=2, w=16): 1 word per branch = 2 words per round.\n        # Each injection XORs the first 16-bit word of each branch.\n        # words_per_injection = n_branches\n\n        words_per_injection = n_branches * (word_size // 16)\n        total_k_words = (total_rounds + 1) * words_per_injection\n\n        while len(rk) < total_k_words:\n            # Current subkeys are k0, k1\n            rk.extend([k[0], k[1]])\n            \n            # Update key state using 16-bit A-permutation\n            k[0], k[1] = A(k[0], k[1], 16)\n            \n            if key_size == 128:\n                k[2] = (k[2] + k[0]) & 0xFFFF\n                k[3] = (k[3] + k[1] + c) & 0xFFFF\n                k = k[2:] + k[:2]\n            else: # 256-bit key\n                k[2] = (k[2] + k[0]) & 0xFFFF\n                k[3] = (k[3] + k[1]) & 0xFFFF\n                k[4] = (k[4] + c) & 0xFFFF\n                k[5] = (k[5] + (c >> 8)) & 0xFFFF\n                k = k[3:] + k[:3]\n            c += 1\n            \n        return rk", "output": "definition sparx_128_128_generate_key_schedule :: \"128 word \\<Rightarrow> 16 word list\" where\n  \"sparx_128_128_generate_key_schedule master_key = (\n    let key_words = sparx_128_128_key_size div 16;\n        total_needed = (sparx_128_128_total_rounds + 1) * sparx_128_128_n_branches;\n        initial_k = sparx_128_128_extract_key_words master_key\n    in sparx_128_128_gen_key_schedule_iterate initial_k 1 0 [])\"", "metadata": {"component_type": "Key Schedule", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.315583"}}
{"instruction": "Translate this Step Iteration from SPARX-128/128 Python to Isabelle/HOL. Apply: convert nested loops to recursion, handle step and round indices, maintain state across iterations. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_encrypt_step_iterate(state, all_keys, round, step):\n    \"\"\"Iterate through rounds within a step for encryption\"\"\"\n    # rounds_per_step = 4\n    if round >= 4:\n        return state\n\n    # n_branches = 4\n    idx = step * 4 + round\n    # Extract keys for this round\n    round_keys = all_keys[idx*4:(idx+1)*4]\n    \n    new_state = sparx_apply_encrypt_round(state, round_keys)\n    return sparx_encrypt_step_iterate(new_state, all_keys, round + 1, step)", "output": "function sparx_128_128_encrypt_step_iterate :: \n  \"16 word list \\<Rightarrow> 16 word list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 16 word list\" where\n\"sparx_128_128_encrypt_step_iterate state all_keys round step = (\n  if round \\<ge> sparx_128_128_rounds_per_step then state\n  else\n    let\n      idx = step * sparx_128_128_rounds_per_step + round;\n      k0 = if idx * 4 < length all_keys then all_keys ! (idx * 4) else 0;\n      k1 = if idx * 4 + 1 < length all_keys then all_keys ! (idx * 4 + 1) else 0;\n      k2 = if idx * 4 + 2 < length all_keys then all_keys ! (idx * 4 + 2) else 0;\n      k3 = if idx * 4 + 3 < length all_keys then all_keys ! (idx * 4 + 3) else 0;\n      round_keys = [k0, k1, k2, k3];\n      new_state = sparx_128_128_apply_encrypt_round state round_keys\n    in\n      sparx_128_128_encrypt_step_iterate new_state all_keys (round + 1) step\n)\"\nby pat_completeness auto\ntermination\n  apply (relation \"measure (\\<lambda>(state, all_keys, round, step). sparx_128_128_rounds_per_step - round)\")\n  apply auto\n  done", "metadata": {"component_type": "Step Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition", "step_iteration"], "extraction_time": "2026-01-24T13:11:48.316100"}}
{"instruction": "Translate this Step Iteration Inverse from SPARX-128/128 Python to Isabelle/HOL. Apply: convert nested loops to recursion, handle step and round indices, maintain state across iterations. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_decrypt_step_iterate(state, all_keys, round, step):\n    \"\"\"Iterate through rounds within a step for decryption (reverse)\"\"\"\n    # rounds_per_step = 4\n    if round >= 4:\n        return state\n        \n    # n_branches = 4\n    \n    idx = step * 4 + (4 - round - 1)\n    round_keys = all_keys[idx*4:(idx+1)*4]\n    \n    new_state = sparx_apply_decrypt_round(state, round_keys)\n    return sparx_decrypt_step_iterate(new_state, all_keys, round + 1, step)", "output": "function sparx_128_128_decrypt_step_iterate :: \n  \"16 word list \\<Rightarrow> 16 word list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 16 word list\" where\n\"sparx_128_128_decrypt_step_iterate state all_keys round step = (\n  if round \\<ge> sparx_128_128_rounds_per_step then state\n  else\n    let\n      idx = step * sparx_128_128_rounds_per_step + (sparx_128_128_rounds_per_step - round - 1);\n      k0 = if idx * 4 < length all_keys then all_keys ! (idx * 4) else 0;\n      k1 = if idx * 4 + 1 < length all_keys then all_keys ! (idx * 4 + 1) else 0;\n      k2 = if idx * 4 + 2 < length all_keys then all_keys ! (idx * 4 + 2) else 0;\n      k3 = if idx * 4 + 3 < length all_keys then all_keys ! (idx * 4 + 3) else 0;\n      round_keys = [k0, k1, k2, k3];\n      new_state = sparx_128_128_apply_decrypt_round state round_keys\n    in\n      sparx_128_128_decrypt_step_iterate new_state all_keys (round + 1) step\n)\"\nby pat_completeness auto\ntermination\n  apply (relation \"measure (\\<lambda>(state, all_keys, round, step). sparx_128_128_rounds_per_step - round)\")\n  apply auto\n  done", "metadata": {"component_type": "Step Iteration Inverse", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition", "step_iteration"], "extraction_time": "2026-01-24T13:11:48.316611"}}
{"instruction": "Translate this Steps Iteration from SPARX-128/128 Python to Isabelle/HOL. Apply: convert nested loops to recursion, handle step and round indices, maintain state across iterations. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_encrypt_steps_iterate(state, all_keys, step):\n    \"\"\"Iterate through steps for encryption\"\"\"\n    # rounds_per_step = 4\n    \n    if step >= 8:\n        return state\n    \n    # Process rounds in current step\n    state_after_rounds = sparx_encrypt_step_iterate(state, all_keys, 0, step)\n\n    # step = 8\n    # Apply linear layer (except after last step)\n    if step < 8 - 1:\n        state_after_linear = sparx_linear_layer(state_after_rounds)\n    else:\n        state_after_linear = state_after_rounds\n    \n    return sparx_encrypt_steps_iterate(state_after_linear, all_keys, step + 1)", "output": "function sparx_128_128_encrypt_steps_iterate :: \n  \"16 word list \\<Rightarrow> 16 word list \\<Rightarrow> nat \\<Rightarrow> 16 word list\" where\n  \"sparx_128_128_encrypt_steps_iterate state all_keys step = (\n    if step \\<ge> sparx_128_128_n_steps then state\n    else\n      let state_after_rounds = sparx_128_128_encrypt_step_iterate state all_keys 0 step;\n          state_after_linear = \n            if step < sparx_128_128_n_steps - 1 then\n              sparx_128_128_linear_layer state_after_rounds\n            else state_after_rounds\n      in sparx_128_128_encrypt_steps_iterate state_after_linear all_keys (step + 1))\"\n  by pat_completeness auto\ntermination\n  apply (relation \"measure (\\<lambda>(state, all_keys, step). sparx_128_128_n_steps - step)\")\n  apply auto\n  done", "metadata": {"component_type": "Steps Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition", "step_iteration"], "extraction_time": "2026-01-24T13:11:48.317124"}}
{"instruction": "Translate this Steps Iteration Inverse from SPARX-128/128 Python to Isabelle/HOL. Apply: convert nested loops to recursion, handle step and round indices, maintain state across iterations. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_decrypt_steps_iterate(state, all_keys, step):\n    \"\"\"Iterate through steps for decryption (reverse)\"\"\"\n    # step = 8\n    if step >= 8:\n        return state\n        \n    # step = 8\n    rev_step = 8 - step - 1\n    \n    # Apply linear layer inverse (except before first step)\n    if rev_step > 0:\n        state_before_linear = sparx_linear_layer_inv(state)\n    else:\n        state_before_linear = state\n    \n    # Process rounds in current step\n    state_after_rounds = sparx_decrypt_step_iterate(state_before_linear, all_keys, 0, rev_step)\n    \n    return sparx_decrypt_steps_iterate(state_after_rounds, all_keys, step + 1)", "output": "function sparx_128_128_decrypt_steps_iterate ::\n  \"16 word list \\<Rightarrow> 16 word list \\<Rightarrow> nat \\<Rightarrow> 16 word list\" where\n\"sparx_128_128_decrypt_steps_iterate state all_keys step = (\n  if step \\<ge> sparx_128_128_n_steps then state\n  else\n    let rev_step = sparx_128_128_n_steps - step - 1;\n        state_after_rounds =\n          sparx_128_128_decrypt_step_iterate\n            state\n            all_keys\n            0\n            rev_step;\n        state_after_linear =\n          if rev_step > 0 then\n            sparx_128_128_linear_layer_inv state_after_rounds\n          else state_after_rounds\n    in sparx_128_128_decrypt_steps_iterate\n         state_after_linear\n         all_keys\n         (step + 1))\"\nby pat_completeness auto\ntermination\n  apply (relation \"measure (\\<lambda>(s, k, i). sparx_128_128_n_steps - i)\")\n  apply auto\n  done", "metadata": {"component_type": "Steps Iteration Inverse", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition", "step_iteration"], "extraction_time": "2026-01-24T13:11:48.317620"}}
{"instruction": "Translate this Block Conversion from SPARX-128/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle 8 words per block, maintain block structure. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_block_to_words(block):\n    \"\"\"Convert block to 8 16-bit words\"\"\"\n    #n_words = 8\n    return [(block >> (16 * i)) & 0xFFFF for i in range(8)]", "output": "definition sparx_128_128_block_to_words :: \"128 word \\<Rightarrow> 16 word list\" where\n\"sparx_128_128_block_to_words block =\n  [ ucast block,\n    ucast (drop_bit 16 block),\n    ucast (drop_bit 32 block),\n    ucast (drop_bit 48 block),\n    ucast (drop_bit 64 block),\n    ucast (drop_bit 80 block),\n    ucast (drop_bit 96 block),\n    ucast (drop_bit 112 block) ]\"", "metadata": {"component_type": "Block Conversion", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.318108"}}
{"instruction": "Translate this Words Conversion from SPARX-128/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle 8 words per block, maintain block structure. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_words_to_block(words):\n    \"\"\"Convert 8 16-bit words to block\"\"\"\n    if len(words) != 8:\n        return 0\n    \n    result = 0\n    for i in range(8):\n        result |= (words[i] & 0xFFFF) << (16 * i)\n    return result", "output": "definition sparx_128_128_words_to_block :: \"16 word list \\<Rightarrow> 128 word\" where\n  \"sparx_128_128_words_to_block words = (\n    if length words = sparx_128_128_n_words then\n      foldl (\\<lambda>acc i. \n        let idx = sparx_128_128_n_words - i - 1;\n            shift = 16 * idx;\n            word_val = if idx < length words then ucast (words ! idx) else 0\n        in or (push_bit shift word_val) acc) 0 [0..<sparx_128_128_n_words]\n    else 0)\"", "metadata": {"component_type": "Words Conversion", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.318515"}}
{"instruction": "Translate this Key Extraction from SPARX-128/128 Python to Isabelle/HOL. Apply: implement key expansion with rotations, generate round keys for all steps, handle whitening key extraction. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_extract_key_words(master_key):\n    \"\"\"Extract 8 16-bit words from master key\"\"\"\n    return [(master_key >> (16 * i)) & 0xFFFF for i in range(8)]", "output": "definition sparx_128_128_extract_key_words :: \"128 word \\<Rightarrow> 16 word list\" where\n  \"sparx_128_128_extract_key_words master_key = \n    [ucast master_key,\n     ucast (drop_bit 16 master_key),\n     ucast (drop_bit 32 master_key),\n     ucast (drop_bit 48 master_key),\n     ucast (drop_bit 64 master_key),\n     ucast (drop_bit 80 master_key),\n     ucast (drop_bit 96 master_key),\n     ucast (drop_bit 112 master_key)]\"", "metadata": {"component_type": "Key Extraction", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.318804"}}
{"instruction": "Translate this Block Bridge from SPARX-128/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle 8 words per block, maintain block structure. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_encrypt_block(plaintext, rk_words):\n    \"\"\"SPARX block encryption\"\"\"\n    # Convert to words\n    state = sparx_block_to_words(plaintext)\n    \n    # Get all round keys\n    # total_rounds = 32\n    # n_branches = 4\n    all_keys = sparx_get_all_round_keys(rk_words, 32, 4)\n    \n    # Process steps\n    state = sparx_encrypt_steps_iterate(state, all_keys, 0)\n    \n    # Final whitening\n    wk = sparx_get_round_key(32, rk_words, 4)\n    for b in range(4):\n        state[2*b] ^= wk[b]\n    \n    # Convert back to block\n    return sparx_words_to_block(state)", "output": "definition sparx_128_128_encrypt_block ::\n  \"128 word \\<Rightarrow> 16 word list \\<Rightarrow> 128 word\" where\n\"sparx_128_128_encrypt_block plaintext rk_words = (\n  let\n    state = sparx_128_128_block_to_words plaintext;\n    all_keys = sparx_128_128_get_all_round_keys rk_words;\n    wk_idx = sparx_128_128_whitening_index;\n    wk0 = if wk_idx     < length all_keys then all_keys ! wk_idx     else 0;\n    wk1 = if wk_idx + 1 < length all_keys then all_keys ! (wk_idx+1) else 0;\n    wk2 = if wk_idx + 2 < length all_keys then all_keys ! (wk_idx+2) else 0;\n    wk3 = if wk_idx + 3 < length all_keys then all_keys ! (wk_idx+3) else 0;\n    state_after_steps = sparx_128_128_encrypt_steps_iterate state all_keys 0;\n    state_final =\n      if length state_after_steps = 8 then\n        [ xor (state_after_steps!0) wk0, state_after_steps!1,\n          xor (state_after_steps!2) wk1, state_after_steps!3,\n          xor (state_after_steps!4) wk2, state_after_steps!5,\n          xor (state_after_steps!6) wk3, state_after_steps!7 ]\n      else state_after_steps\n  in\n    sparx_128_128_words_to_block state_final\n)\"", "metadata": {"component_type": "Block Bridge", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.319294"}}
{"instruction": "Translate this Block Bridge Inverse from SPARX-128/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle 8 words per block, maintain block structure. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_decrypt_block(ciphertext, rk_words):\n    \"\"\"SPARX block decryption\"\"\"\n    # Convert to words\n    state = sparx_block_to_words(ciphertext)\n    \n    # Get all round keys\n    # total_rounds = 32\n    # n_branches = 4\n    all_keys = sparx_get_all_round_keys(rk_words, 32, 4)\n    \n    # Undo final whitening\n    wk = sparx_get_round_key(32, rk_words, 4)\n    for b in range(4):\n        state[2*b] ^= wk[b]\n    \n    # Process steps in reverse\n    state = sparx_decrypt_steps_iterate(state, all_keys, 0)\n    \n    # Convert back to block\n    return sparx_words_to_block(state)", "output": "definition sparx_128_128_decrypt_block ::\n  \"128 word \\<Rightarrow> 16 word list \\<Rightarrow> 128 word\" where\n\"sparx_128_128_decrypt_block ciphertext rk_words = (\n  let\n    state = sparx_128_128_block_to_words ciphertext;\n    all_keys = sparx_128_128_get_all_round_keys rk_words;\n    wk_idx = sparx_128_128_whitening_index;\n    wk0 = if wk_idx     < length all_keys then all_keys ! wk_idx     else 0;\n    wk1 = if wk_idx + 1 < length all_keys then all_keys ! (wk_idx+1) else 0;\n    wk2 = if wk_idx + 2 < length all_keys then all_keys ! (wk_idx+2) else 0;\n    wk3 = if wk_idx + 3 < length all_keys then all_keys ! (wk_idx+3) else 0;\n    state_unwhitened =\n      if length state = 8 then\n        [ xor (state!0) wk0, state!1,\n          xor (state!2) wk1, state!3,\n          xor (state!4) wk2, state!5,\n          xor (state!6) wk3, state!7 ]\n      else state;\n    state_after_steps =\n      sparx_128_128_decrypt_steps_iterate state_unwhitened all_keys 0\n  in\n    sparx_128_128_words_to_block state_after_steps\n)\"", "metadata": {"component_type": "Block Bridge Inverse", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.319785"}}
{"instruction": "Translate this Top-Level Encrypt from SPARX-128/128 Python to Isabelle/HOL. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_encrypt(plaintext):\n        # 1. Unpack plaintext into 16-bit state words\n        s = _unpack_state(plaintext)\n    \n        # 2. Forward rounds\n        for step in range(n_steps):\n            for r in range(rps):\n                rk = _get_round_key(step * rps + r)\n                for b in range(n_branches):\n                    s[2 * b] ^= rk[b]\n                    s[2 * b], s[2 * b + 1] = A(\n                        s[2 * b], s[2 * b + 1], 16\n                    )\n    \n            if step < n_steps - 1:\n                s = linear_layer(s)\n    \n        # 3. Final whitening\n        wk = _get_round_key(total_rounds)\n        for b in range(n_branches):\n            s[2 * b] ^= wk[b]\n    \n        # 4. Pack state back into integer\n        return _pack_state(s)", "output": "definition sparx_128_128_encrypt :: \"128 word \\<Rightarrow> 128 word \\<Rightarrow> 128 word\" where\n  \"sparx_128_128_encrypt plaintext master_key = (\n    let rk_words = sparx_128_128_generate_key_schedule master_key\n    in sparx_128_128_encrypt_block plaintext rk_words)\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.321048"}}
{"instruction": "Translate this Top-Level Decrypt from SPARX-128/128 Python to Isabelle/HOL. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_decrypt(ciphertext):\n        # 1. Unpack ciphertext into 16-bit state words\n        s = _unpack_state(ciphertext)\n    \n        # 2. Undo final whitening\n        wk = _get_round_key(total_rounds)\n        for b in range(n_branches):\n            s[2 * b] ^= wk[b]\n    \n        # 3. Main inverse rounds\n        for step in reversed(range(n_steps)):\n    \n            # Inverse linear layer (except after last step)\n            if step < n_steps - 1:\n                s = linear_layer_inv(s)\n    \n            # Inverse ARX rounds\n            for r in reversed(range(rps)):\n                rk = _get_round_key(step * rps + r)\n                for b in range(n_branches):\n                    s[2 * b], s[2 * b + 1] = A_inv(\n                        s[2 * b], s[2 * b + 1], 16\n                    )\n                    s[2 * b] ^= rk[b]\n    \n        # 4. Pack state back into integer\n        return _pack_state(s)", "output": "definition sparx_128_128_decrypt :: \"128 word \\<Rightarrow> 128 word \\<Rightarrow> 128 word\" where\n  \"sparx_128_128_decrypt ciphertext master_key = (\n    let rk_words = sparx_128_128_generate_key_schedule master_key\n    in sparx_128_128_decrypt_block ciphertext rk_words)\"", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.321064"}}
{"instruction": "Translate this Round Key Extraction from SPARX-128/128 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_get_round_key(r_idx, rk_words, n_branches=4):\n    \"\"\"Extract round key for round r_idx\"\"\"\n    base = r_idx * n_branches\n    return rk_words[base:base + n_branches]", "output": "function sparx_128_128_get_round_key_iterate ::\n  \"16 word list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 16 word list \\<Rightarrow> 16 word list\" where\n  \"sparx_128_128_get_round_key_iterate rk_words idx max_idx keys = (\n    if idx \\<ge> max_idx then keys\n    else\n      let base = idx * sparx_128_128_round_key_words;\n          k1 = if base < length rk_words then rk_words ! base     else 0;\n          k2 = if base + 1 < length rk_words then rk_words ! (base + 1) else 0;\n          k3 = if base + 2 < length rk_words then rk_words ! (base + 2) else 0;\n          k4 = if base + 3 < length rk_words then rk_words ! (base + 3) else 0;\n          keys_new = keys @ [k1,k2,k3,k4]\n      in sparx_128_128_get_round_key_iterate rk_words (idx + 1) max_idx keys_new)\"\n   by pat_completeness auto\ntermination\n  apply (relation \"measure(\\<lambda>(rk_words, idx, max_idx, keys). max_idx - idx)\")\n  apply auto\n  done", "metadata": {"component_type": "Round Key Extraction", "difficulty": "medium", "semantic_group": "helpers", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.321933"}}
{"instruction": "Translate this All Round Keys from SPARX-128/128 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_get_all_round_keys(rk_words, total_rounds=32, n_branches=4):\n    \"\"\"Get all round keys as a flat list\"\"\"\n    all_keys = []\n    for r_idx in range(total_rounds + 1):\n        all_keys.extend(sparx_get_round_key(r_idx, rk_words, n_branches))\n    return all_keys", "output": "definition sparx_128_128_get_all_round_keys :: \"16 word list \\<Rightarrow> 16 word list\" where\n\"sparx_128_128_get_all_round_keys rk_words =\n  sparx_128_128_get_round_key_iterate\n    rk_words\n    0\n    sparx_128_128_total_rounds\n    []\"", "metadata": {"component_type": "All Round Keys", "difficulty": "medium", "semantic_group": "helpers", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.322261"}}
{"instruction": "Translate this Linear Word Function from SPARX-128/128 Python to Isabelle/HOL. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_L_w(x):\n    \"\"\"SPARX linear word function\"\"\"\n    return ((x << 8) ^ (x >> 8))", "output": "definition sparx_128_128_L_w :: \"16 word \\<Rightarrow> 16 word\" where\n  \"sparx_128_128_L_w x = xor (push_bit 8 x) (drop_bit 8 x)\"", "metadata": {"component_type": "Linear Word Function", "difficulty": "medium", "semantic_group": "helpers", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition", "linear_diffusion"], "extraction_time": "2026-01-24T13:11:48.322365"}}
{"instruction": "Translate this Whitening Index from SPARX-128/128 Python to Isabelle/HOL. Note: SPARX-128/128 uses 8 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_whitening_index(total_rounds=32, n_branches=4):\n    \"\"\"Index for whitening keys\"\"\"\n    # total_rounds = 32\n    # n_branches = 4\n    # return total_rounds * n_branches\n    return 32 * 4", "output": "definition sparx_128_128_whitening_index :: nat where\n  \"sparx_128_128_whitening_index =\n     (sparx_128_128_total_rounds - 1) * sparx_128_128_round_key_words\"", "metadata": {"component_type": "Whitening Index", "difficulty": "easy", "semantic_group": "helpers", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 128, "total_rounds": 32, "steps": 8, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "function_definition"], "extraction_time": "2026-01-24T13:11:48.322696"}}
{"instruction": "Translate this word_size Constant from SPARX-64/128 Python to Isabelle/HOL. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "# 16-bit words for SPARX operations\nword_size = 16", "output": "definition sparx_64_128_word_size :: nat where \"sparx_64_128_word_size = 16\"", "metadata": {"component_type": "word_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.323796"}}
{"instruction": "Translate this n_branches Constant from SPARX-64/128 Python to Isabelle/HOL. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "# 2 branches\nn_branches = 2", "output": "definition sparx_64_128_n_branches :: nat where \"sparx_64_128_n_branches = 2\"", "metadata": {"component_type": "n_branches Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.324121"}}
{"instruction": "Translate this n_words Constant from SPARX-64/128 Python to Isabelle/HOL. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "# 4 total words in state\nn_words = 4", "output": "definition sparx_64_128_n_words :: nat where \"sparx_64_128_n_words = 4\"", "metadata": {"component_type": "n_words Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.324421"}}
{"instruction": "Translate this n_steps Constant from SPARX-64/128 Python to Isabelle/HOL. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "# Number of steps\nn_steps = 8", "output": "definition sparx_64_128_n_steps :: nat where \"sparx_64_128_n_steps = 8\"", "metadata": {"component_type": "n_steps Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["step_iteration"], "extraction_time": "2026-01-24T13:11:48.324683"}}
{"instruction": "Translate this rounds_per_step Constant from SPARX-64/128 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "# Rounds per step\nrounds_per_step = 3", "output": "definition sparx_64_128_rounds_per_step :: nat where \"sparx_64_128_rounds_per_step = 3\"", "metadata": {"component_type": "rounds_per_step Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["step_iteration"], "extraction_time": "2026-01-24T13:11:48.324964"}}
{"instruction": "Translate this total_rounds Constant from SPARX-64/128 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "# Total encryption rounds\ntotal_rounds = 24", "output": "definition sparx_64_128_total_rounds :: nat where \n  \"sparx_64_128_total_rounds = sparx_64_128_n_steps * sparx_64_128_rounds_per_step\"", "metadata": {"component_type": "total_rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.325187"}}
{"instruction": "Translate this key_size Constant from SPARX-64/128 Python to Isabelle/HOL. Apply: implement key expansion with rotations, generate round keys for all steps, handle whitening key extraction. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "# 128-bit key\nkey_size = 128", "output": "definition sparx_64_128_key_size :: nat where \"sparx_64_128_key_size = 128\"", "metadata": {"component_type": "key_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.325455"}}
{"instruction": "Translate this block_size Constant from SPARX-64/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle 4 words per block, maintain block structure. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "# 64-bit block\nblock_size = 64", "output": "definition sparx_64_128_block_size :: nat where \"sparx_64_128_block_size = 64\"", "metadata": {"component_type": "block_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.325718"}}
{"instruction": "Translate this A Permutation from SPARX-64/128 Python to Isabelle/HOL. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_A(x, y, width):\n        \"\"\"ARX A-permutation. Parametric by width (16 or 32).\"\"\"\n        mask = (1 << width) - 1\n        x = _ror(x, 7, width)\n        x = (x + y) & mask\n        y = _rol(y, 2, width)\n        y ^= x\n        return x, y", "output": "definition sparx_64_128_A_perm_16 :: \"16 word \\<Rightarrow> 16 word \\<Rightarrow> (16 word \\<times> 16 word)\" where\n  \"sparx_64_128_A_perm_16 x y = (\n    let x_rot = sparx_64_128_ror x 7;\n        x_new = x_rot + y;\n        y_rot = sparx_64_128_rol y 2;\n        y_new = xor y_rot x_new\n    in (x_new, y_new))\"", "metadata": {"component_type": "A Permutation", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.326157"}}
{"instruction": "Translate this A Permutation Inverse from SPARX-64/128 Python to Isabelle/HOL. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_A_inv(x, y, width):\n        \"\"\"Inverse A-permutation.\"\"\"\n        mask = (1 << width) - 1\n        y = _ror(y ^ x, 2, width)\n        x = _rol((x - y) & mask, 7, width)\n        return x, y\n\n    # -------------------------------------------------\n    # Linear Layer\n    # -------------------------------------------------", "output": "definition sparx_64_128_A_perm_16_inv :: \"16 word \\<Rightarrow> 16 word \\<Rightarrow> (16 word \\<times> 16 word)\" where\n  \"sparx_64_128_A_perm_16_inv x y = (\n    let y_temp = xor y x;\n        y_new = sparx_64_128_ror y_temp 2;\n        x_temp = x - y_new;\n        x_new = sparx_64_128_rol x_temp 7\n    in (x_new, y_new))\"", "metadata": {"component_type": "A Permutation Inverse", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.326411"}}
{"instruction": "Translate this Linear Word Function from SPARX-64/128 Python to Isabelle/HOL. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_L_w(x):\n        \"\"\"SPARX linear word function\"\"\"\n        return ((x << 8) ^ (x >> 8)) & 0xFFFF", "output": "definition sparx_64_128_L_w :: \"16 word \\<Rightarrow> 16 word\" where\n  \"sparx_64_128_L_w x = xor (push_bit 8 x) (drop_bit 8 x)\"", "metadata": {"component_type": "Linear Word Function", "difficulty": "easy", "semantic_group": "diffusion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition", "linear_diffusion"], "extraction_time": "2026-01-24T13:11:48.326674"}}
{"instruction": "Translate this Linear Layer from SPARX-64/128 Python to Isabelle/HOL. Apply: implement diffusion across branches, use XOR operations between words, handle 2 branches. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_linear_layer(s):\n        \"\"\"SPARX linear layer for 2 branches\"\"\"\n        t = sparx_L_w(s[0] ^ s[1])  # Uses separate L_w function\n        return [s[2] ^ t, s[3] ^ t, s[0], s[1]]", "output": "definition sparx_64_128_linear_layer :: \"16 word list \\<Rightarrow> 16 word list\" where\n\"sparx_64_128_linear_layer s = (\n  if length s = sparx_64_128_n_words then\n    let\n      t = sparx_64_128_L_w (xor (s ! 0) (s ! 1))\n    in\n      [ xor (s ! 2) t, xor (s ! 3) t,\n        s ! 0, s ! 1 ]\n  else s)\"", "metadata": {"component_type": "Linear Layer", "difficulty": "medium", "semantic_group": "diffusion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "function_definition", "linear_diffusion"], "extraction_time": "2026-01-24T13:11:48.326943"}}
{"instruction": "Translate this Linear Layer Inverse from SPARX-64/128 Python to Isabelle/HOL. Apply: implement diffusion across branches, use XOR operations between words, handle 2 branches. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_linear_layer_inv(s):\n        \"\"\"Inverse SPARX linear layer for 2 branches\"\"\"\n        t = sparx_L_w(s[2] ^ s[3])\n        return [s[2], s[3], s[0] ^ t, s[1] ^ t]", "output": "definition sparx_64_128_linear_layer_inv :: \"16 word list \\<Rightarrow> 16 word list\" where\n  \"sparx_64_128_linear_layer_inv s = (\n    if length s = sparx_64_128_n_words then\n      let t = sparx_64_128_L_w (xor (s ! 2) (s ! 3))\n      in [s ! 2, s ! 3, xor (s ! 0) t, xor (s ! 1) t]\n    else s)\"", "metadata": {"component_type": "Linear Layer Inverse", "difficulty": "medium", "semantic_group": "diffusion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "function_definition", "linear_diffusion"], "extraction_time": "2026-01-24T13:11:48.327258"}}
{"instruction": "Translate this Round Application from SPARX-64/128 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_apply_encrypt_round(state, round_keys):\n    \"\"\"Apply SPARX encrypt round\"\"\"\n    # n_branches = 2\n    if len(state) != 4 or len(round_keys) < 2:\n        return state\n    \n    result = []\n    for b in range(2):\n        s0 = state[2*b] ^ round_keys[b]\n        s0_new, s1_new = sparx_A(s0, state[2*b + 1], 16)\n        result.extend([s0_new, s1_new])\n    \n    return result", "output": "definition sparx_64_128_apply_encrypt_round :: \n  \"16 word list \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word list\" where\n  \"sparx_64_128_apply_encrypt_round state key1 key2 = (\n    if length state = sparx_64_128_n_words then\n      let s0_xor = xor (state ! 0) key1;\n          (s0_new, s1_new) = sparx_64_128_A_perm_16 s0_xor (state ! 1);\n          s2_xor = xor (state ! 2) key2;\n          (s2_new, s3_new) = sparx_64_128_A_perm_16 s2_xor (state ! 3)\n      in [s0_new, s1_new, s2_new, s3_new]\n    else state)\"", "metadata": {"component_type": "Round Application", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.327986"}}
{"instruction": "Translate this Round Application Inverse from SPARX-64/128 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_apply_decrypt_round(state, round_keys):\n    \"\"\"Apply SPARX decrypt round (inverse)\"\"\"\n    # n_branches = 2\n    \n    if len(state) != 4 or len(round_keys) < 2:\n        return state\n    \n    result = []\n    for b in range(2):\n        s0_new, s1_new = sparx_A_inv(state[2*b], state[2*b + 1], 16)\n        s0_final = s0_new ^ round_keys[b]\n        result.extend([s0_final, s1_new])\n    \n    return result", "output": "definition sparx_64_128_apply_decrypt_round :: \n  \"16 word list \\<Rightarrow> 16 word \\<Rightarrow> 16 word \\<Rightarrow> 16 word list\" where\n  \"sparx_64_128_apply_decrypt_round state key1 key2 = (\n    if length state = sparx_64_128_n_words then\n      let (s2_new, s3_new) = sparx_64_128_A_perm_16_inv (state ! 2) (state ! 3);\n          s2_final = xor s2_new key2;\n          (s0_new, s1_new) = sparx_64_128_A_perm_16_inv (state ! 0) (state ! 1);\n          s0_final = xor s0_new key1\n      in [s0_final, s1_new, s2_final, s3_new]\n    else state)\"", "metadata": {"component_type": "Round Application Inverse", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.328002"}}
{"instruction": "Translate this Key Schedule from SPARX-64/128 Python to Isabelle/HOL. Apply: implement key expansion with rotations, generate round keys for all steps, handle whitening key extraction. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_generate_key_schedule():\n        \"\"\"\n        Generates subkeys using 16-bit words.\n        Produces enough 16-bit words to satisfy all rounds + whitening.\n        \"\"\"\n        k = [(master_key >> (16 * i)) & 0xFFFF for i in range(key_size // 16)]\n        rk = []\n        c = 1\n        \n        # We need enough 16-bit words for (total_rounds + 1) injections.\n        # Each injection XORs the first word of each branch.\n        # S-64 (b=2, w=16): 1 word per branch = 2 words per round.\n        # Each injection XORs the first 16-bit word of each branch.\n        # words_per_injection = n_branches\n\n        words_per_injection = n_branches * (word_size // 16)\n        total_k_words = (total_rounds + 1) * words_per_injection\n\n        while len(rk) < total_k_words:\n            # Current subkeys are k0, k1\n            rk.extend([k[0], k[1]])\n            \n            # Update key state using 16-bit A-permutation\n            k[0], k[1] = A(k[0], k[1], 16)\n            \n            if key_size == 128:\n                k[2] = (k[2] + k[0]) & 0xFFFF\n                k[3] = (k[3] + k[1] + c) & 0xFFFF\n                k = k[2:] + k[:2]\n            else: # 256-bit key\n                k[2] = (k[2] + k[0]) & 0xFFFF\n                k[3] = (k[3] + k[1]) & 0xFFFF\n                k[4] = (k[4] + c) & 0xFFFF\n                k[5] = (k[5] + (c >> 8)) & 0xFFFF\n                k = k[3:] + k[:3]\n            c += 1\n            \n        return rk", "output": "definition sparx_64_128_generate_key_schedule :: \"128 word \\<Rightarrow> 16 word list\" where\n  \"sparx_64_128_generate_key_schedule master_key = (\n    let key_words = sparx_64_128_key_size div 16;\n        total_needed = (sparx_64_128_total_rounds + 1) * sparx_64_128_n_branches;\n        initial_k = sparx_64_128_extract_key_words master_key\n    in sparx_64_128_gen_key_schedule_iterate initial_k 1 0 [])\"", "metadata": {"component_type": "Key Schedule", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.328462"}}
{"instruction": "Translate this Step Iteration from SPARX-64/128 Python to Isabelle/HOL. Apply: convert nested loops to recursion, handle step and round indices, maintain state across iterations. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_encrypt_step_iterate(state, all_keys, round, step):\n    \"\"\"Iterate through rounds within a step for encryption\"\"\"\n    # rounds_per_step = 3\n    if round >= 3:\n        return state\n\n    # n_branches = 2\n    idx = step * 3 + round\n    # Extract keys for this round\n    round_keys = all_keys[idx*2:(idx+1)*2]\n    \n    new_state = sparx_apply_encrypt_round(state, round_keys)\n    return sparx_encrypt_step_iterate(new_state, all_keys, round + 1, step)", "output": "function sparx_64_128_encrypt_step_iterate :: \n  \"16 word list \\<Rightarrow> 16 word list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 16 word list\" where\n  \"sparx_64_128_encrypt_step_iterate state all_keys round step = (\n    if round \\<ge> sparx_64_128_rounds_per_step then state\n    else\n      let idx = step * sparx_64_128_rounds_per_step + round;\n          key1 = if idx * 2 < length all_keys then all_keys ! (idx * 2) else 0;\n          key2 = if idx * 2 + 1 < length all_keys then all_keys ! (idx * 2 + 1) else 0;\n          new_state = sparx_64_128_apply_encrypt_round state key1 key2\n      in sparx_64_128_encrypt_step_iterate new_state all_keys (round + 1) step)\"\n  by pat_completeness auto\ntermination\n  apply (relation \"measure (\\<lambda>(state, all_keys, round, step). sparx_64_128_rounds_per_step - round)\")\n  apply auto\n  done", "metadata": {"component_type": "Step Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition", "step_iteration"], "extraction_time": "2026-01-24T13:11:48.328846"}}
{"instruction": "Translate this Step Iteration Inverse from SPARX-64/128 Python to Isabelle/HOL. Apply: convert nested loops to recursion, handle step and round indices, maintain state across iterations. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_decrypt_step_iterate(state, all_keys, round, step):\n    \"\"\"Iterate through rounds within a step for decryption (reverse)\"\"\"\n    # rounds_per_step = 3\n    if round >= 3:\n        return state\n        \n    # n_branches = 2\n    \n    idx = step * 3 + (3 - round - 1)\n    round_keys = all_keys[idx*2:(idx+1)*2]\n    \n    new_state = sparx_apply_decrypt_round(state, round_keys)\n    return sparx_decrypt_step_iterate(new_state, all_keys, round + 1, step)", "output": "function sparx_64_128_decrypt_step_iterate :: \n  \"16 word list \\<Rightarrow> 16 word list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 16 word list\" where\n  \"sparx_64_128_decrypt_step_iterate state all_keys round step = (\n    if round \\<ge> sparx_64_128_rounds_per_step then state\n    else\n      let idx = step * sparx_64_128_rounds_per_step + (sparx_64_128_rounds_per_step - round - 1);\n          key1 = if idx * 2 < length all_keys then all_keys ! (idx * 2) else 0;\n          key2 = if idx * 2 + 1 < length all_keys then all_keys ! (idx * 2 + 1) else 0;\n          new_state = sparx_64_128_apply_decrypt_round state key1 key2\n      in sparx_64_128_decrypt_step_iterate new_state all_keys (round + 1) step)\"\n  by pat_completeness auto\ntermination\n  apply (relation \"measure (\\<lambda>(state, all_keys, round, step). sparx_64_128_rounds_per_step - round)\")\n  apply auto\n  done", "metadata": {"component_type": "Step Iteration Inverse", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition", "step_iteration"], "extraction_time": "2026-01-24T13:11:48.329221"}}
{"instruction": "Translate this Steps Iteration from SPARX-64/128 Python to Isabelle/HOL. Apply: convert nested loops to recursion, handle step and round indices, maintain state across iterations. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_encrypt_steps_iterate(state, all_keys, step):\n    \"\"\"Iterate through steps for encryption\"\"\"\n    # rounds_per_step = 3\n    \n    if step >= 8:\n        return state\n    \n    # Process rounds in current step\n    state_after_rounds = sparx_encrypt_step_iterate(state, all_keys, 0, step)\n\n    # step = 8\n    # Apply linear layer (except after last step)\n    if step < 8 - 1:\n        state_after_linear = sparx_linear_layer(state_after_rounds)\n    else:\n        state_after_linear = state_after_rounds\n    \n    return sparx_encrypt_steps_iterate(state_after_linear, all_keys, step + 1)", "output": "function sparx_64_128_encrypt_steps_iterate :: \n  \"16 word list \\<Rightarrow> 16 word list \\<Rightarrow> nat \\<Rightarrow> 16 word list\" where\n  \"sparx_64_128_encrypt_steps_iterate state all_keys step = (\n    if step \\<ge> sparx_64_128_n_steps then state\n    else\n      let state_after_rounds = sparx_64_128_encrypt_step_iterate state all_keys 0 step;\n          state_after_linear = if step < sparx_64_128_n_steps - 1 then\n              sparx_64_128_linear_layer state_after_rounds\n            else state_after_rounds\n      in sparx_64_128_encrypt_steps_iterate state_after_linear all_keys (step + 1))\"\n  by pat_completeness auto\ntermination\n  apply (relation \"measure (\\<lambda>(state, all_keys, step). sparx_64_128_n_steps - step)\")\n  apply auto\n  done", "metadata": {"component_type": "Steps Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition", "step_iteration"], "extraction_time": "2026-01-24T13:11:48.329618"}}
{"instruction": "Translate this Steps Iteration Inverse from SPARX-64/128 Python to Isabelle/HOL. Apply: convert nested loops to recursion, handle step and round indices, maintain state across iterations. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_decrypt_steps_iterate(state, all_keys, step):\n    \"\"\"Iterate through steps for decryption (reverse)\"\"\"\n    # step = 8\n    if step >= 8:\n        return state\n        \n    # step = 8\n    rev_step = 8 - step - 1\n    \n    # Apply linear layer inverse (except before first step)\n    if rev_step > 0:\n        state_before_linear = sparx_linear_layer_inv(state)\n    else:\n        state_before_linear = state\n    \n    # Process rounds in current step\n    state_after_rounds = sparx_decrypt_step_iterate(state_before_linear, all_keys, 0, rev_step)\n    \n    return sparx_decrypt_steps_iterate(state_after_rounds, all_keys, step + 1)", "output": "function sparx_64_128_decrypt_steps_iterate ::\n  \"16 word list \\<Rightarrow> 16 word list \\<Rightarrow> nat \\<Rightarrow> 16 word list\" where\n\"sparx_64_128_decrypt_steps_iterate state all_keys step = (\n  if step \\<ge> sparx_64_128_n_steps then state\n  else\n    let rev_step = sparx_64_128_n_steps - step - 1;\n        state_after_rounds =\n          sparx_64_128_decrypt_step_iterate\n            state\n            all_keys\n            0\n            rev_step;\n        state_after_linear =\n          if rev_step > 0 then\n            sparx_64_128_linear_layer_inv state_after_rounds\n          else state_after_rounds\n    in sparx_64_128_decrypt_steps_iterate\n         state_after_linear\n         all_keys\n         (step + 1))\"\nby pat_completeness auto\ntermination\n  apply (relation \"measure (\\<lambda>(s, k, i). sparx_64_128_n_steps - i)\")\n  apply auto\n  done", "metadata": {"component_type": "Steps Iteration Inverse", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition", "step_iteration"], "extraction_time": "2026-01-24T13:11:48.329996"}}
{"instruction": "Translate this Block Conversion from SPARX-64/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle 4 words per block, maintain block structure. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_block_to_words(block):\n    \"\"\"Convert block to 4 16-bit words\"\"\"\n    #n_words = 4\n    return [(block >> (16 * i)) & 0xFFFF for i in range(4)]", "output": "definition sparx_64_128_block_to_words :: \"64 word \\<Rightarrow> 16 word list\" where\n  \"sparx_64_128_block_to_words block = \n    [ucast block,\n     ucast (drop_bit 16 block),\n     ucast (drop_bit 32 block),\n     ucast (drop_bit 48 block)]\"", "metadata": {"component_type": "Block Conversion", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.330356"}}
{"instruction": "Translate this Words Conversion from SPARX-64/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle 4 words per block, maintain block structure. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_words_to_block(words):\n    \"\"\"Convert 4 16-bit words to block\"\"\"\n    if len(words) != 4:\n        return 0\n    \n    result = 0\n    for i in range(4):\n        result |= (words[i] & 0xFFFF) << (16 * i)\n    return result", "output": "definition sparx_64_128_words_to_block :: \"16 word list \\<Rightarrow> 64 word\" where\n  \"sparx_64_128_words_to_block words = (\n    if length words = sparx_64_128_n_words then\n      foldl (\\<lambda>acc i. \n        let idx = sparx_64_128_n_words - i - 1;\n            shift = 16 * idx;\n            word_val = if idx < length words then ucast (words ! idx) else 0\n        in or (push_bit shift word_val) acc) 0 [0..<sparx_64_128_n_words]\n    else 0)\"", "metadata": {"component_type": "Words Conversion", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.330897"}}
{"instruction": "Translate this Key Extraction from SPARX-64/128 Python to Isabelle/HOL. Apply: implement key expansion with rotations, generate round keys for all steps, handle whitening key extraction. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_extract_key_words(master_key):\n    \"\"\"Extract 8 16-bit words from master key\"\"\"\n    return [(master_key >> (16 * i)) & 0xFFFF for i in range(8)]", "output": "definition sparx_64_128_extract_key_words :: \"128 word \\<Rightarrow> 16 word list\" where\n  \"sparx_64_128_extract_key_words master_key = \n    [ucast master_key,\n     ucast (drop_bit 16 master_key),\n     ucast (drop_bit 32 master_key),\n     ucast (drop_bit 48 master_key),\n     ucast (drop_bit 64 master_key),\n     ucast (drop_bit 80 master_key),\n     ucast (drop_bit 96 master_key),\n     ucast (drop_bit 112 master_key)]\"", "metadata": {"component_type": "Key Extraction", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.331319"}}
{"instruction": "Translate this Block Bridge from SPARX-64/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle 4 words per block, maintain block structure. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_encrypt_block(plaintext, rk_words):\n    \"\"\"SPARX block encryption\"\"\"\n    # Convert to words\n    state = sparx_block_to_words(plaintext)\n    \n    # Get all round keys\n    # total_rounds = 24\n    # n_branches = 2\n    all_keys = sparx_get_all_round_keys(rk_words, 24, 2)\n    \n    # Process steps\n    state = sparx_encrypt_steps_iterate(state, all_keys, 0)\n    \n    # Final whitening\n    wk = sparx_get_round_key(24, rk_words, 2)\n    for b in range(2):\n        state[2*b] ^= wk[b]\n    \n    # Convert back to block\n    return sparx_words_to_block(state)", "output": "definition sparx_64_128_encrypt_block ::\n  \"64 word \\<Rightarrow> 16 word list \\<Rightarrow> 64 word\" where\n\"sparx_64_128_encrypt_block plaintext rk_words = (\n  let state = sparx_64_128_block_to_words plaintext;\n      all_keys = sparx_64_128_get_all_round_keys rk_words;\n      wk_idx = sparx_64_128_whitening_index;\n      wk1 = if wk_idx < length all_keys then all_keys ! wk_idx else 0;\n      wk2 = if wk_idx + 1 < length all_keys then all_keys ! (wk_idx + 1) else 0;\n      state_after_steps = sparx_64_128_encrypt_steps_iterate state all_keys 0;\n      state_final =\n        if length state_after_steps = sparx_64_128_n_words then\n          [ xor (state_after_steps ! 0) wk1,\n            state_after_steps ! 1,\n            xor (state_after_steps ! 2) wk2,\n            state_after_steps ! 3 ]\n        else state_after_steps\n  in sparx_64_128_words_to_block state_final)\"", "metadata": {"component_type": "Block Bridge", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.331759"}}
{"instruction": "Translate this Block Bridge Inverse from SPARX-64/128 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle 4 words per block, maintain block structure. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_decrypt_block(ciphertext, rk_words):\n    \"\"\"SPARX block decryption\"\"\"\n    # Convert to words\n    state = sparx_block_to_words(ciphertext)\n    \n    # Get all round keys\n    # total_rounds = 24\n    # n_branches = 2\n    all_keys = sparx_get_all_round_keys(rk_words, 24, 2)\n    \n    # Undo final whitening\n    wk = sparx_get_round_key(24, rk_words, 2)\n    for b in range(2):\n        state[2*b] ^= wk[b]\n    \n    # Process steps in reverse\n    state = sparx_decrypt_steps_iterate(state, all_keys, 0)\n    \n    # Convert back to block\n    return sparx_words_to_block(state)", "output": "definition sparx_64_128_decrypt_block ::\n  \"64 word \\<Rightarrow> 16 word list \\<Rightarrow> 64 word\" where\n\"sparx_64_128_decrypt_block ciphertext rk_words = (\n  let state = sparx_64_128_block_to_words ciphertext;\n      all_keys = sparx_64_128_get_all_round_keys rk_words;\n      wk_idx = sparx_64_128_whitening_index;\n      wk1 = if wk_idx < length all_keys then all_keys ! wk_idx else 0;\n      wk2 = if wk_idx + 1 < length all_keys then all_keys ! (wk_idx + 1) else 0;\n      state_unwhitened =\n        if length state = sparx_64_128_n_words then\n          [ xor (state ! 0) wk1,\n            state ! 1,\n            xor (state ! 2) wk2,\n            state ! 3 ]\n        else state;\n      state_after_steps =\n        sparx_64_128_decrypt_steps_iterate state_unwhitened all_keys 0\n  in sparx_64_128_words_to_block state_after_steps)\"", "metadata": {"component_type": "Block Bridge Inverse", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.332280"}}
{"instruction": "Translate this Top-Level Encrypt from SPARX-64/128 Python to Isabelle/HOL. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_encrypt(plaintext):\n        # 1. Unpack plaintext into 16-bit state words\n        s = _unpack_state(plaintext)\n    \n        # 2. Forward rounds\n        for step in range(n_steps):\n            for r in range(rps):\n                rk = _get_round_key(step * rps + r)\n                for b in range(n_branches):\n                    s[2 * b] ^= rk[b]\n                    s[2 * b], s[2 * b + 1] = A(\n                        s[2 * b], s[2 * b + 1], 16\n                    )\n    \n            if step < n_steps - 1:\n                s = linear_layer(s)\n    \n        # 3. Final whitening\n        wk = _get_round_key(total_rounds)\n        for b in range(n_branches):\n            s[2 * b] ^= wk[b]\n    \n        # 4. Pack state back into integer\n        return _pack_state(s)", "output": "definition sparx_64_128_encrypt :: \"64 word \\<Rightarrow> 128 word \\<Rightarrow> 64 word\" where\n  \"sparx_64_128_encrypt plaintext master_key = (\n    let rk_words = sparx_64_128_generate_key_schedule master_key\n    in sparx_64_128_encrypt_block plaintext rk_words)\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.333673"}}
{"instruction": "Translate this Top-Level Decrypt from SPARX-64/128 Python to Isabelle/HOL. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_decrypt(ciphertext):\n        # 1. Unpack ciphertext into 16-bit state words\n        s = _unpack_state(ciphertext)\n    \n        # 2. Undo final whitening\n        wk = _get_round_key(total_rounds)\n        for b in range(n_branches):\n            s[2 * b] ^= wk[b]\n    \n        # 3. Main inverse rounds\n        for step in reversed(range(n_steps)):\n    \n            # Inverse linear layer (except after last step)\n            if step < n_steps - 1:\n                s = linear_layer_inv(s)\n    \n            # Inverse ARX rounds\n            for r in reversed(range(rps)):\n                rk = _get_round_key(step * rps + r)\n                for b in range(n_branches):\n                    s[2 * b], s[2 * b + 1] = A_inv(\n                        s[2 * b], s[2 * b + 1], 16\n                    )\n                    s[2 * b] ^= rk[b]\n    \n        # 4. Pack state back into integer\n        return _pack_state(s)", "output": "definition sparx_64_128_decrypt :: \"64 word \\<Rightarrow> 128 word \\<Rightarrow> 64 word\" where\n  \"sparx_64_128_decrypt ciphertext master_key = (\n    let rk_words = sparx_64_128_generate_key_schedule master_key\n    in sparx_64_128_decrypt_block ciphertext rk_words)\"", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.333694"}}
{"instruction": "Translate this Round Key Extraction from SPARX-64/128 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_get_round_key(r_idx, rk_words, n_branches=2):\n    \"\"\"Extract round key for round r_idx\"\"\"\n    base = r_idx * n_branches\n    return rk_words[base:base + n_branches]", "output": "function sparx_64_128_get_round_key_iterate ::\n  \"16 word list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 16 word list \\<Rightarrow> 16 word list\" where\n  \"sparx_64_128_get_round_key_iterate rk_words idx max_idx keys = (\n    if idx \\<ge> max_idx then keys\n    else\n      let base = idx * sparx_64_128_round_key_words;\n          k1 = if base < length rk_words then rk_words ! base else 0;\n          k2 = if base + 1 < length rk_words then rk_words ! (base + 1) else 0;\n          keys_new = keys @ [k1, k2]\n      in sparx_64_128_get_round_key_iterate rk_words (idx + 1) max_idx keys_new)\"\n   by pat_completeness auto\ntermination\n  apply (relation \"measure(\\<lambda>(rk_words, idx, max_idx, keys). max_idx - idx)\")\n  apply auto\n  done", "metadata": {"component_type": "Round Key Extraction", "difficulty": "medium", "semantic_group": "helpers", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.334626"}}
{"instruction": "Translate this All Round Keys from SPARX-64/128 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_get_all_round_keys(rk_words, total_rounds=24, n_branches=2):\n    \"\"\"Get all round keys as a flat list\"\"\"\n    all_keys = []\n    for r_idx in range(total_rounds + 1):\n        all_keys.extend(sparx_get_round_key(r_idx, rk_words, n_branches))\n    return all_keys", "output": "definition sparx_64_128_get_all_round_keys :: \"16 word list \\<Rightarrow> 16 word list\" where\n\"sparx_64_128_get_all_round_keys rk_words =\n  sparx_64_128_get_round_key_iterate\n    rk_words\n    0\n    sparx_64_128_total_rounds\n    []\"", "metadata": {"component_type": "All Round Keys", "difficulty": "medium", "semantic_group": "helpers", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.334927"}}
{"instruction": "Translate this Linear Word Function from SPARX-64/128 Python to Isabelle/HOL. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_L_w(x):\n    \"\"\"SPARX linear word function\"\"\"\n    return ((x << 8) ^ (x >> 8))", "output": "definition sparx_64_128_L_w :: \"16 word \\<Rightarrow> 16 word\" where\n  \"sparx_64_128_L_w x = xor (push_bit 8 x) (drop_bit 8 x)\"", "metadata": {"component_type": "Linear Word Function", "difficulty": "medium", "semantic_group": "helpers", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition", "linear_diffusion"], "extraction_time": "2026-01-24T13:11:48.335092"}}
{"instruction": "Translate this Whitening Index from SPARX-64/128 Python to Isabelle/HOL. Note: SPARX-64/128 uses 8 steps with 3 rounds each, using A-permutations and a linear layer.", "input": "def sparx_whitening_index(total_rounds=24, n_branches=2):\n    \"\"\"Index for whitening keys\"\"\"\n    # total_rounds = 24\n    # n_branches = 2\n    # return total_rounds * n_branches\n    return 24 * 2", "output": "definition sparx_64_128_whitening_index :: nat where\n  \"sparx_64_128_whitening_index =\n     (sparx_64_128_total_rounds - 1) * sparx_64_128_round_key_words\"", "metadata": {"component_type": "Whitening Index", "difficulty": "easy", "semantic_group": "helpers", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 64, "key_size": 128, "total_rounds": 24, "steps": 8, "rounds_per_step": 3}, "algorithm_params": {"word_size": 16, "branches": 2, "words_per_block": 4, "key_words": 8, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "function_definition"], "extraction_time": "2026-01-24T13:11:48.335439"}}
{"instruction": "Translate this word_size Constant from SPARX-128/256 Python to Isabelle/HOL. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "# 16-bit words for SPARX operations\nword_size = 16", "output": "definition sparx_128_256_word_size :: nat where \"sparx_128_256_word_size = 16\"", "metadata": {"component_type": "word_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.336261"}}
{"instruction": "Translate this n_branches Constant from SPARX-128/256 Python to Isabelle/HOL. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "# 4 branches\nn_branches = 4", "output": "definition sparx_128_256_n_branches :: nat where \"sparx_128_256_n_branches = 4\"", "metadata": {"component_type": "n_branches Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.336541"}}
{"instruction": "Translate this n_words Constant from SPARX-128/256 Python to Isabelle/HOL. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "# 8 total words in state\nn_words = 8", "output": "definition sparx_128_256_n_words :: nat where \"sparx_128_256_n_words = 8\"", "metadata": {"component_type": "n_words Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.336819"}}
{"instruction": "Translate this n_steps Constant from SPARX-128/256 Python to Isabelle/HOL. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "# Number of steps\nn_steps = 10", "output": "definition sparx_128_256_n_steps :: nat where \"sparx_128_256_n_steps = 10\"", "metadata": {"component_type": "n_steps Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["step_iteration"], "extraction_time": "2026-01-24T13:11:48.337077"}}
{"instruction": "Translate this rounds_per_step Constant from SPARX-128/256 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "# Rounds per step\nrounds_per_step = 4", "output": "definition sparx_128_256_rounds_per_step :: nat where \"sparx_128_256_rounds_per_step = 4\"", "metadata": {"component_type": "rounds_per_step Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["step_iteration"], "extraction_time": "2026-01-24T13:11:48.337342"}}
{"instruction": "Translate this total_rounds Constant from SPARX-128/256 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "# Total encryption rounds\ntotal_rounds = 40", "output": "definition sparx_128_256_total_rounds :: nat where \n  \"sparx_128_256_total_rounds = sparx_128_256_n_steps * sparx_128_256_rounds_per_step\"", "metadata": {"component_type": "total_rounds Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": [], "extraction_time": "2026-01-24T13:11:48.337553"}}
{"instruction": "Translate this key_size Constant from SPARX-128/256 Python to Isabelle/HOL. Apply: implement key expansion with rotations, generate round keys for all steps, handle whitening key extraction. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "# 256-bit key\nkey_size = 256", "output": "definition sparx_128_256_key_size :: nat where \"sparx_128_256_key_size = 256\"", "metadata": {"component_type": "key_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.337805"}}
{"instruction": "Translate this block_size Constant from SPARX-128/256 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle 8 words per block, maintain block structure. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "# 128-bit block\nblock_size = 128", "output": "definition sparx_128_256_block_size :: nat where \"sparx_128_256_block_size = 128\"", "metadata": {"component_type": "block_size Constant", "difficulty": "easy", "semantic_group": "constants", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["modular_arithmetic"], "extraction_time": "2026-01-24T13:11:48.338055"}}
{"instruction": "Translate this A Permutation from SPARX-128/256 Python to Isabelle/HOL. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_A(x, y, width):\n        \"\"\"ARX A-permutation. Parametric by width (16 or 32).\"\"\"\n        mask = (1 << width) - 1\n        x = _ror(x, 7, width)\n        x = (x + y) & mask\n        y = _rol(y, 2, width)\n        y ^= x\n        return x, y", "output": "definition sparx_128_256_A_perm_16 :: \"16 word \\<Rightarrow> 16 word \\<Rightarrow> (16 word \\<times> 16 word)\" where\n  \"sparx_128_256_A_perm_16 x y = (\n    let x_rot = sparx_128_256_ror x 7;\n        x_new = x_rot + y;\n        y_rot = sparx_128_256_rol y 2;\n        y_new = xor y_rot x_new\n    in (x_new, y_new))\"", "metadata": {"component_type": "A Permutation", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.338473"}}
{"instruction": "Translate this A Permutation Inverse from SPARX-128/256 Python to Isabelle/HOL. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_A_inv(x, y, width):\n        \"\"\"Inverse A-permutation.\"\"\"\n        mask = (1 << width) - 1\n        y = _ror(y ^ x, 2, width)\n        x = _rol((x - y) & mask, 7, width)\n        return x, y\n\n    # -------------------------------------------------\n    # Linear Layer\n    # -------------------------------------------------", "output": "definition sparx_128_256_A_perm_16_inv :: \"16 word \\<Rightarrow> 16 word \\<Rightarrow> (16 word \\<times> 16 word)\" where\n  \"sparx_128_256_A_perm_16_inv x y = (\n    let y_temp = xor y x;\n        y_new = sparx_128_256_ror y_temp 2;\n        x_temp = x - y_new;\n        x_new = sparx_128_256_rol x_temp 7\n    in (x_new, y_new))\"", "metadata": {"component_type": "A Permutation Inverse", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.338720"}}
{"instruction": "Translate this Linear Word Function from SPARX-128/256 Python to Isabelle/HOL. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_L_w(x):\n        \"\"\"SPARX linear word function\"\"\"\n        return ((x << 8) ^ (x >> 8)) & 0xFFFF", "output": "definition sparx_128_256_L_w :: \"16 word \\<Rightarrow> 16 word\" where\n  \"sparx_128_256_L_w x = xor (push_bit 8 x) (drop_bit 8 x)\"", "metadata": {"component_type": "Linear Word Function", "difficulty": "easy", "semantic_group": "diffusion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition", "linear_diffusion"], "extraction_time": "2026-01-24T13:11:48.338966"}}
{"instruction": "Translate this Linear Layer from SPARX-128/256 Python to Isabelle/HOL. Apply: implement diffusion across branches, use XOR operations between words, handle 4 branches. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_linear_layer(s):\n        \"\"\"SPARX linear layer for 4 branches\"\"\"\n        t = sparx_L_w(s[0] ^ s[1] ^ s[2] ^ s[3])\n        return [\n            s[4] ^ t, s[5] ^ t,\n            s[6] ^ t, s[7] ^ t,\n            s[0], s[1], s[2], s[3]\n        ]", "output": "definition sparx_128_256_linear_layer :: \"16 word list \\<Rightarrow> 16 word list\" where\n\"sparx_128_256_linear_layer s = (\n  if length s = sparx_128_256_n_words then\n    let\n      t = sparx_128_256_L_w (xor (xor (s ! 0) (s ! 1)) (xor (s ! 2) (s ! 3)))\n    in\n      [ xor (s ! 4) t, xor (s ! 5) t,\n        xor (s ! 6) t, xor (s ! 7) t,\n        s ! 0, s ! 1, s ! 2, s ! 3 ]\n  else s)\"", "metadata": {"component_type": "Linear Layer", "difficulty": "medium", "semantic_group": "diffusion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "function_definition", "linear_diffusion"], "extraction_time": "2026-01-24T13:11:48.339214"}}
{"instruction": "Translate this Linear Layer Inverse from SPARX-128/256 Python to Isabelle/HOL. Apply: implement diffusion across branches, use XOR operations between words, handle 4 branches. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_linear_layer_inv(s):\n        \"\"\"Inverse SPARX linear layer for 4 branches\"\"\"\n        t = sparx_L_w(s[4] ^ s[5] ^ s[6] ^ s[7])\n        return [\n            s[4], s[5], s[6], s[7],\n            s[0] ^ t, s[1] ^ t, s[2] ^ t, s[3] ^ t\n        ]", "output": "definition sparx_128_256_linear_layer_inv :: \"16 word list \\<Rightarrow> 16 word list\" where\n\"sparx_128_256_linear_layer_inv s = (\n  if length s = sparx_128_256_n_words then\n    let\n      t = sparx_128_256_L_w (xor (xor (s ! 4) (s ! 5)) (xor (s ! 6) (s ! 7)))\n    in\n      [ s ! 4, s ! 5, s ! 6, s ! 7,\n        xor (s ! 0) t, xor (s ! 1) t, \n        xor (s ! 2) t, xor (s ! 3) t ]\n  else s)\"", "metadata": {"component_type": "Linear Layer Inverse", "difficulty": "medium", "semantic_group": "diffusion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "function_definition", "linear_diffusion"], "extraction_time": "2026-01-24T13:11:48.339478"}}
{"instruction": "Translate this Round Application from SPARX-128/256 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_apply_encrypt_round(state, round_keys):\n    \"\"\"Apply SPARX encrypt round\"\"\"\n    # n_branches = 4\n    if len(state) != 8 or len(round_keys) < 4:\n        return state\n    \n    result = []\n    for b in range(4):\n        s0 = state[2*b] ^ round_keys[b]\n        s0_new, s1_new = sparx_A(s0, state[2*b + 1], 16)\n        result.extend([s0_new, s1_new])\n    \n    return result", "output": "definition sparx_128_256_apply_encrypt_round ::\n  \"16 word list \\<Rightarrow> 16 word list \\<Rightarrow> 16 word list\" where\n\"sparx_128_256_apply_encrypt_round state round_keys = (\n  if length state = sparx_128_256_n_words \\<and> length round_keys = 4 then\n    let\n      (a0,a1) = sparx_128_256_A_perm_16 (xor (state!0) (round_keys!0))(state!1);\n      (a2,a3) = sparx_128_256_A_perm_16 (xor (state!2) (round_keys!1))(state!3);\n      (a4,a5) = sparx_128_256_A_perm_16 (xor (state!4) (round_keys!2))(state!5);\n      (a6,a7) = sparx_128_256_A_perm_16  (xor (state!6) (round_keys!3))(state!7)\n    in\n      [a0,a1,a2,a3,a4,a5,a6,a7]\n  else state\n)\"", "metadata": {"component_type": "Round Application", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.340211"}}
{"instruction": "Translate this Round Application Inverse from SPARX-128/256 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_apply_decrypt_round(state, round_keys):\n    \"\"\"Apply SPARX decrypt round (inverse)\"\"\"\n    # n_branches = 4\n    \n    if len(state) != 8 or len(round_keys) < 4:\n        return state\n    \n    result = []\n    for b in range(4):\n        s0_new, s1_new = sparx_A_inv(state[2*b], state[2*b + 1], 16)\n        s0_final = s0_new ^ round_keys[b]\n        result.extend([s0_final, s1_new])\n    \n    return result", "output": "definition sparx_128_256_apply_decrypt_round ::\n  \"16 word list \\<Rightarrow> 16 word list \\<Rightarrow> 16 word list\" where\n\"sparx_128_256_apply_decrypt_round state round_keys = (\n  if length state = sparx_128_256_n_words \\<and> length round_keys = 4 then\n    let\n      (s0', s1') = sparx_128_256_A_perm_16_inv (state ! 0) (state ! 1);\n      s0 = xor s0' (round_keys ! 0);\n      (s2', s3') = sparx_128_256_A_perm_16_inv (state ! 2) (state ! 3);\n      s2 = xor s2' (round_keys ! 1);\n      (s4', s5') = sparx_128_256_A_perm_16_inv (state ! 4) (state ! 5);\n      s4 = xor s4' (round_keys ! 2);\n      (s6', s7') = sparx_128_256_A_perm_16_inv (state ! 6) (state ! 7);\n      s6 = xor s6' (round_keys ! 3)\n    in\n      [ s0, s1',\n        s2, s3',\n        s4, s5',\n        s6, s7' ]\n  else state)\"", "metadata": {"component_type": "Round Application Inverse", "difficulty": "medium", "semantic_group": "round_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.340228"}}
{"instruction": "Translate this Key Schedule from SPARX-128/256 Python to Isabelle/HOL. Apply: implement key expansion with rotations, generate round keys for all steps, handle whitening key extraction. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_generate_key_schedule():\n        \"\"\"\n        Generates subkeys using 16-bit words.\n        Produces enough 16-bit words to satisfy all rounds + whitening.\n        \"\"\"\n        k = [(master_key >> (16 * i)) & 0xFFFF for i in range(key_size // 16)]\n        rk = []\n        c = 1\n        \n        # We need enough 16-bit words for (total_rounds + 1) injections.\n        # Each injection XORs the first word of each branch.\n        # S-64 (b=2, w=16): 1 word per branch = 2 words per round.\n        # Each injection XORs the first 16-bit word of each branch.\n        # words_per_injection = n_branches\n\n        words_per_injection = n_branches * (word_size // 16)\n        total_k_words = (total_rounds + 1) * words_per_injection\n\n        while len(rk) < total_k_words:\n            # Current subkeys are k0, k1\n            rk.extend([k[0], k[1]])\n            \n            # Update key state using 16-bit A-permutation\n            k[0], k[1] = A(k[0], k[1], 16)\n            \n            if key_size == 128:\n                k[2] = (k[2] + k[0]) & 0xFFFF\n                k[3] = (k[3] + k[1] + c) & 0xFFFF\n                k = k[2:] + k[:2]\n            else: # 256-bit key\n                k[2] = (k[2] + k[0]) & 0xFFFF\n                k[3] = (k[3] + k[1]) & 0xFFFF\n                k[4] = (k[4] + c) & 0xFFFF\n                k[5] = (k[5] + (c >> 8)) & 0xFFFF\n                k = k[3:] + k[:3]\n            c += 1\n            \n        return rk", "output": "definition sparx_128_256_generate_key_schedule :: \"256 word \\<Rightarrow> 16 word list\" where\n  \"sparx_128_256_generate_key_schedule master_key = (\n    let key_words = sparx_128_256_key_size div 16;\n        total_needed = (sparx_128_256_total_rounds + 1) * sparx_128_256_n_branches;\n        initial_k = sparx_128_256_extract_key_words master_key\n    in sparx_128_256_gen_key_schedule_iterate initial_k 1 0 [])\"", "metadata": {"component_type": "Key Schedule", "difficulty": "hard", "semantic_group": "key_expansion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.340712"}}
{"instruction": "Translate this Step Iteration from SPARX-128/256 Python to Isabelle/HOL. Apply: convert nested loops to recursion, handle step and round indices, maintain state across iterations. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_encrypt_step_iterate(state, all_keys, round, step):\n    \"\"\"Iterate through rounds within a step for encryption\"\"\"\n    # rounds_per_step = 4\n    if round >= 4:\n        return state\n\n    # n_branches = 4\n    idx = step * 4 + round\n    # Extract keys for this round\n    round_keys = all_keys[idx*4:(idx+1)*4]\n    \n    new_state = sparx_apply_encrypt_round(state, round_keys)\n    return sparx_encrypt_step_iterate(new_state, all_keys, round + 1, step)", "output": "function sparx_128_256_encrypt_step_iterate :: \n  \"16 word list \\<Rightarrow> 16 word list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 16 word list\" where\n\"sparx_128_256_encrypt_step_iterate state all_keys round step = (\n  if round \\<ge> sparx_128_256_rounds_per_step then state\n  else\n    let\n      idx = step * sparx_128_256_rounds_per_step + round;\n      k0 = if idx * 4 < length all_keys then all_keys ! (idx * 4) else 0;\n      k1 = if idx * 4 + 1 < length all_keys then all_keys ! (idx * 4 + 1) else 0;\n      k2 = if idx * 4 + 2 < length all_keys then all_keys ! (idx * 4 + 2) else 0;\n      k3 = if idx * 4 + 3 < length all_keys then all_keys ! (idx * 4 + 3) else 0;\n      round_keys = [k0, k1, k2, k3];\n      new_state = sparx_128_256_apply_encrypt_round state round_keys\n    in\n      sparx_128_256_encrypt_step_iterate new_state all_keys (round + 1) step\n)\"\nby pat_completeness auto\ntermination\n  apply (relation \"measure (\\<lambda>(state, all_keys, round, step). sparx_128_256_rounds_per_step - round)\")\n  apply auto\n  done", "metadata": {"component_type": "Step Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition", "step_iteration"], "extraction_time": "2026-01-24T13:11:48.341104"}}
{"instruction": "Translate this Step Iteration Inverse from SPARX-128/256 Python to Isabelle/HOL. Apply: convert nested loops to recursion, handle step and round indices, maintain state across iterations. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_decrypt_step_iterate(state, all_keys, round, step):\n    \"\"\"Iterate through rounds within a step for decryption (reverse)\"\"\"\n    # rounds_per_step = 4\n    if round >= 4:\n        return state\n        \n    # n_branches = 4\n    \n    idx = step * 4 + (4 - round - 1)\n    round_keys = all_keys[idx*4:(idx+1)*4]\n    \n    new_state = sparx_apply_decrypt_round(state, round_keys)\n    return sparx_decrypt_step_iterate(new_state, all_keys, round + 1, step)", "output": "function sparx_128_256_decrypt_step_iterate :: \n  \"16 word list \\<Rightarrow> 16 word list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 16 word list\" where\n\"sparx_128_256_decrypt_step_iterate state all_keys round step = (\n  if round \\<ge> sparx_128_256_rounds_per_step then state\n  else\n    let\n      idx = step * sparx_128_256_rounds_per_step + (sparx_128_256_rounds_per_step - round - 1);\n      k0 = if idx * 4 < length all_keys then all_keys ! (idx * 4) else 0;\n      k1 = if idx * 4 + 1 < length all_keys then all_keys ! (idx * 4 + 1) else 0;\n      k2 = if idx * 4 + 2 < length all_keys then all_keys ! (idx * 4 + 2) else 0;\n      k3 = if idx * 4 + 3 < length all_keys then all_keys ! (idx * 4 + 3) else 0;\n      round_keys = [k0, k1, k2, k3];\n      new_state = sparx_128_256_apply_decrypt_round state round_keys\n    in\n      sparx_128_256_decrypt_step_iterate new_state all_keys (round + 1) step\n)\"\nby pat_completeness auto\ntermination\n  apply (relation \"measure (\\<lambda>(state, all_keys, round, step). sparx_128_256_rounds_per_step - round)\")\n  apply auto\n  done", "metadata": {"component_type": "Step Iteration Inverse", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition", "step_iteration"], "extraction_time": "2026-01-24T13:11:48.341484"}}
{"instruction": "Translate this Steps Iteration from SPARX-128/256 Python to Isabelle/HOL. Apply: convert nested loops to recursion, handle step and round indices, maintain state across iterations. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_encrypt_steps_iterate(state, all_keys, step):\n    \"\"\"Iterate through steps for encryption\"\"\"\n    # rounds_per_step = 4\n    \n    if step >= 10:\n        return state\n    \n    # Process rounds in current step\n    state_after_rounds = sparx_encrypt_step_iterate(state, all_keys, 0, step)\n\n    # step = 10\n    # Apply linear layer (except after last step)\n    if step < 10 - 1:\n        state_after_linear = sparx_linear_layer(state_after_rounds)\n    else:\n        state_after_linear = state_after_rounds\n    \n    return sparx_encrypt_steps_iterate(state_after_linear, all_keys, step + 1)", "output": "function sparx_128_256_encrypt_steps_iterate :: \n  \"16 word list \\<Rightarrow> 16 word list \\<Rightarrow> nat \\<Rightarrow> 16 word list\" where\n  \"sparx_128_256_encrypt_steps_iterate state all_keys step = (\n    if step \\<ge> sparx_128_256_n_steps then state\n    else\n      let state_after_rounds = sparx_128_256_encrypt_step_iterate state all_keys 0 step;\n          state_after_linear = \n            if step < sparx_128_256_n_steps - 1 then\n              sparx_128_256_linear_layer state_after_rounds\n            else state_after_rounds\n      in sparx_128_256_encrypt_steps_iterate state_after_linear all_keys (step + 1))\"\n  by pat_completeness auto\ntermination\n  apply (relation \"measure (\\<lambda>(state, all_keys, step). sparx_128_256_n_steps - step)\")\n  apply auto\n  done", "metadata": {"component_type": "Steps Iteration", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition", "step_iteration"], "extraction_time": "2026-01-24T13:11:48.341907"}}
{"instruction": "Translate this Steps Iteration Inverse from SPARX-128/256 Python to Isabelle/HOL. Apply: convert nested loops to recursion, handle step and round indices, maintain state across iterations. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_decrypt_steps_iterate(state, all_keys, step):\n    \"\"\"Iterate through steps for decryption (reverse)\"\"\"\n    # step = 10\n    if step >= 10:\n        return state\n        \n    # step = 10\n    rev_step = 10 - step - 1\n    \n    # Apply linear layer inverse (except before first step)\n    if rev_step > 0:\n        state_before_linear = sparx_linear_layer_inv(state)\n    else:\n        state_before_linear = state\n    \n    # Process rounds in current step\n    state_after_rounds = sparx_decrypt_step_iterate(state_before_linear, all_keys, 0, rev_step)\n    \n    return sparx_decrypt_steps_iterate(state_after_rounds, all_keys, step + 1)", "output": "function sparx_128_256_decrypt_steps_iterate ::\n  \"16 word list \\<Rightarrow> 16 word list \\<Rightarrow> nat \\<Rightarrow> 16 word list\" where\n\"sparx_128_256_decrypt_steps_iterate state all_keys step = (\n  if step \\<ge> sparx_128_256_n_steps then state\n  else\n    let rev_step = sparx_128_256_n_steps - step - 1;\n        state_after_rounds =\n          sparx_128_256_decrypt_step_iterate\n            state\n            all_keys\n            0\n            rev_step;\n        state_after_linear =\n          if rev_step > 0 then\n            sparx_128_256_linear_layer_inv state_after_rounds\n          else state_after_rounds\n    in sparx_128_256_decrypt_steps_iterate\n         state_after_linear\n         all_keys\n         (step + 1))\"\nby pat_completeness auto\ntermination\n  apply (relation \"measure (\\<lambda>(s, k, i). sparx_128_256_n_steps - i)\")\n  apply auto\n  done", "metadata": {"component_type": "Steps Iteration Inverse", "difficulty": "medium", "semantic_group": "iteration_patterns", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition", "step_iteration"], "extraction_time": "2026-01-24T13:11:48.342344"}}
{"instruction": "Translate this Block Conversion from SPARX-128/256 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle 8 words per block, maintain block structure. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_block_to_words(block):\n    \"\"\"Convert block to 8 16-bit words\"\"\"\n    #n_words = 8\n    return [(block >> (16 * i)) & 0xFFFF for i in range(8)]", "output": "definition sparx_128_256_block_to_words :: \"128 word \\<Rightarrow> 16 word list\" where\n\"sparx_128_256_block_to_words block =\n  [ ucast block,\n    ucast (drop_bit 16 block),\n    ucast (drop_bit 32 block),\n    ucast (drop_bit 48 block),\n    ucast (drop_bit 64 block),\n    ucast (drop_bit 80 block),\n    ucast (drop_bit 96 block),\n    ucast (drop_bit 112 block) ]\"", "metadata": {"component_type": "Block Conversion", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.342789"}}
{"instruction": "Translate this Words Conversion from SPARX-128/256 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle 8 words per block, maintain block structure. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_words_to_block(words):\n    \"\"\"Convert 8 16-bit words to block\"\"\"\n    if len(words) != 8:\n        return 0\n    \n    result = 0\n    for i in range(8):\n        result |= (words[i] & 0xFFFF) << (16 * i)\n    return result", "output": "definition sparx_128_256_words_to_block :: \"16 word list \\<Rightarrow> 128 word\" where\n  \"sparx_128_256_words_to_block words = (\n    if length words = sparx_128_256_n_words then\n      foldl (\\<lambda>acc i. \n        let idx = sparx_128_256_n_words - i - 1;\n            shift = 16 * idx;\n            word_val = if idx < length words then ucast (words ! idx) else 0\n        in or (push_bit shift word_val) acc) 0 [0..<sparx_128_256_n_words]\n    else 0)\"", "metadata": {"component_type": "Words Conversion", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.343236"}}
{"instruction": "Translate this Key Extraction from SPARX-128/256 Python to Isabelle/HOL. Apply: implement key expansion with rotations, generate round keys for all steps, handle whitening key extraction. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_extract_key_words(master_key):\n    \"\"\"Extract 16 16-bit words from master key\"\"\"\n    return [(master_key >> (16 * i)) & 0xFFFF for i in range(16)]", "output": "definition sparx_128_256_extract_key_words :: \"256 word \\<Rightarrow> 16 word list\" where\n  \"sparx_128_256_extract_key_words master_key = \n    [ucast master_key,\n     ucast (drop_bit 16 master_key),\n     ucast (drop_bit 32 master_key),\n     ucast (drop_bit 48 master_key),\n     ucast (drop_bit 64 master_key),\n     ucast (drop_bit 80 master_key),\n     ucast (drop_bit 96 master_key),\n     ucast (drop_bit 112 master_key)]\"", "metadata": {"component_type": "Key Extraction", "difficulty": "easy", "semantic_group": "data_conversion", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bit_operations", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.343531"}}
{"instruction": "Translate this Block Bridge from SPARX-128/256 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle 8 words per block, maintain block structure. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_encrypt_block(plaintext, rk_words):\n    \"\"\"SPARX block encryption\"\"\"\n    # Convert to words\n    state = sparx_block_to_words(plaintext)\n    \n    # Get all round keys\n    # total_rounds = 40\n    # n_branches = 4\n    all_keys = sparx_get_all_round_keys(rk_words, 40, 4)\n    \n    # Process steps\n    state = sparx_encrypt_steps_iterate(state, all_keys, 0)\n    \n    # Final whitening\n    wk = sparx_get_round_key(40, rk_words, 4)\n    for b in range(4):\n        state[2*b] ^= wk[b]\n    \n    # Convert back to block\n    return sparx_words_to_block(state)", "output": "definition sparx_128_256_encrypt_block ::\n  \"128 word \\<Rightarrow> 16 word list \\<Rightarrow> 128 word\" where\n\"sparx_128_256_encrypt_block plaintext rk_words = (\n  let\n    state = sparx_128_256_block_to_words plaintext;\n    all_keys = sparx_128_256_get_all_round_keys rk_words;\n    wk_idx = sparx_128_256_whitening_index;\n    wk0 = if wk_idx     < length all_keys then all_keys ! wk_idx     else 0;\n    wk1 = if wk_idx + 1 < length all_keys then all_keys ! (wk_idx+1) else 0;\n    wk2 = if wk_idx + 2 < length all_keys then all_keys ! (wk_idx+2) else 0;\n    wk3 = if wk_idx + 3 < length all_keys then all_keys ! (wk_idx+3) else 0;\n    state_after_steps =\n      sparx_128_256_encrypt_steps_iterate state all_keys 0;\n    state_final =\n      if length state_after_steps = 8 then\n        [ xor (state_after_steps!0) wk0, state_after_steps!1,\n          xor (state_after_steps!2) wk1, state_after_steps!3,\n          xor (state_after_steps!4) wk2, state_after_steps!5,\n          xor (state_after_steps!6) wk3, state_after_steps!7 ]\n      else state_after_steps\n  in\n    sparx_128_256_words_to_block state_final\n)\"", "metadata": {"component_type": "Block Bridge", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.344000"}}
{"instruction": "Translate this Block Bridge Inverse from SPARX-128/256 Python to Isabelle/HOL. Apply: split/combine words using bit operations, handle 8 words per block, maintain block structure. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_decrypt_block(ciphertext, rk_words):\n    \"\"\"SPARX block decryption\"\"\"\n    # Convert to words\n    state = sparx_block_to_words(ciphertext)\n    \n    # Get all round keys\n    # total_rounds = 40\n    # n_branches = 4\n    all_keys = sparx_get_all_round_keys(rk_words, 40, 4)\n    \n    # Undo final whitening\n    wk = sparx_get_round_key(40, rk_words, 4)\n    for b in range(4):\n        state[2*b] ^= wk[b]\n    \n    # Process steps in reverse\n    state = sparx_decrypt_steps_iterate(state, all_keys, 0)\n    \n    # Convert back to block\n    return sparx_words_to_block(state)", "output": "definition sparx_128_256_decrypt_block ::\n  \"128 word \\<Rightarrow> 16 word list \\<Rightarrow> 128 word\" where\n\"sparx_128_256_decrypt_block ciphertext rk_words = (\n  let\n    state = sparx_128_256_block_to_words ciphertext;\n    all_keys = sparx_128_256_get_all_round_keys rk_words;\n    wk_idx = sparx_128_256_whitening_index;\n    wk0 = if wk_idx     < length all_keys then all_keys ! wk_idx     else 0;\n    wk1 = if wk_idx + 1 < length all_keys then all_keys ! (wk_idx+1) else 0;\n    wk2 = if wk_idx + 2 < length all_keys then all_keys ! (wk_idx+2) else 0;\n    wk3 = if wk_idx + 3 < length all_keys then all_keys ! (wk_idx+3) else 0;\n    state_unwhitened =\n      if length state = 8 then\n        [ xor (state!0) wk0, state!1,\n          xor (state!2) wk1, state!3,\n          xor (state!4) wk2, state!5,\n          xor (state!6) wk3, state!7 ]\n      else state;\n    state_after_steps =\n      sparx_128_256_decrypt_steps_iterate state_unwhitened all_keys 0\n  in\n    sparx_128_256_words_to_block state_after_steps\n)\"", "metadata": {"component_type": "Block Bridge Inverse", "difficulty": "medium", "semantic_group": "block_operations", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "function_definition"], "extraction_time": "2026-01-24T13:11:48.344535"}}
{"instruction": "Translate this Top-Level Encrypt from SPARX-128/256 Python to Isabelle/HOL. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_encrypt(plaintext):\n        # 1. Unpack plaintext into 16-bit state words\n        s = _unpack_state(plaintext)\n    \n        # 2. Forward rounds\n        for step in range(n_steps):\n            for r in range(rps):\n                rk = _get_round_key(step * rps + r)\n                for b in range(n_branches):\n                    s[2 * b] ^= rk[b]\n                    s[2 * b], s[2 * b + 1] = A(\n                        s[2 * b], s[2 * b + 1], 16\n                    )\n    \n            if step < n_steps - 1:\n                s = linear_layer(s)\n    \n        # 3. Final whitening\n        wk = _get_round_key(total_rounds)\n        for b in range(n_branches):\n            s[2 * b] ^= wk[b]\n    \n        # 4. Pack state back into integer\n        return _pack_state(s)", "output": "definition sparx_128_256_encrypt :: \"128 word \\<Rightarrow> 256 word \\<Rightarrow> 128 word\" where\n  \"sparx_128_256_encrypt plaintext master_key = (\n    let rk_words = sparx_128_256_generate_key_schedule master_key\n    in sparx_128_256_encrypt_block plaintext rk_words)\"", "metadata": {"component_type": "Top-Level Encrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.345900"}}
{"instruction": "Translate this Top-Level Decrypt from SPARX-128/256 Python to Isabelle/HOL. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_decrypt(ciphertext):\n        # 1. Unpack ciphertext into 16-bit state words\n        s = _unpack_state(ciphertext)\n    \n        # 2. Undo final whitening\n        wk = _get_round_key(total_rounds)\n        for b in range(n_branches):\n            s[2 * b] ^= wk[b]\n    \n        # 3. Main inverse rounds\n        for step in reversed(range(n_steps)):\n    \n            # Inverse linear layer (except after last step)\n            if step < n_steps - 1:\n                s = linear_layer_inv(s)\n    \n            # Inverse ARX rounds\n            for r in reversed(range(rps)):\n                rk = _get_round_key(step * rps + r)\n                for b in range(n_branches):\n                    s[2 * b], s[2 * b + 1] = A_inv(\n                        s[2 * b], s[2 * b + 1], 16\n                    )\n                    s[2 * b] ^= rk[b]\n    \n        # 4. Pack state back into integer\n        return _pack_state(s)", "output": "definition sparx_128_256_decrypt :: \"128 word \\<Rightarrow> 256 word \\<Rightarrow> 128 word\" where\n  \"sparx_128_256_decrypt ciphertext master_key = (\n    let rk_words = sparx_128_256_generate_key_schedule master_key\n    in sparx_128_256_decrypt_block ciphertext rk_words)\"\n\n\nend", "metadata": {"component_type": "Top-Level Decrypt", "difficulty": "medium", "semantic_group": "top_level", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "bitwise_operations", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.345920"}}
{"instruction": "Translate this Round Key Extraction from SPARX-128/256 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_get_round_key(r_idx, rk_words, n_branches=4):\n    \"\"\"Extract round key for round r_idx\"\"\"\n    base = r_idx * n_branches\n    return rk_words[base:base + n_branches]", "output": "function sparx_128_256_get_round_key_iterate ::\n  \"16 word list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 16 word list \\<Rightarrow> 16 word list\" where\n  \"sparx_128_256_get_round_key_iterate rk_words idx max_idx keys = (\n    if idx \\<ge> max_idx then keys\n    else\n      let base = idx * sparx_128_256_round_key_words;\n          k1 = if base < length rk_words then rk_words ! base     else 0;\n          k2 = if base + 1 < length rk_words then rk_words ! (base + 1) else 0;\n          k3 = if base + 2 < length rk_words then rk_words ! (base + 2) else 0;\n          k4 = if base + 3 < length rk_words then rk_words ! (base + 3) else 0;\n          keys_new = keys @ [k1,k2,k3,k4]\n      in sparx_128_256_get_round_key_iterate rk_words (idx + 1) max_idx keys_new)\"\n   by pat_completeness auto\ntermination\n  apply (relation \"measure(\\<lambda>(rk_words, idx, max_idx, keys). max_idx - idx)\")\n  apply auto\n  done", "metadata": {"component_type": "Round Key Extraction", "difficulty": "medium", "semantic_group": "helpers", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.346859"}}
{"instruction": "Translate this All Round Keys from SPARX-128/256 Python to Isabelle/HOL. Apply: implement A-permutation followed by key XOR, process each branch independently, handle round key extraction. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_get_all_round_keys(rk_words, total_rounds=40, n_branches=4):\n    \"\"\"Get all round keys as a flat list\"\"\"\n    all_keys = []\n    for r_idx in range(total_rounds + 1):\n        all_keys.extend(sparx_get_round_key(r_idx, rk_words, n_branches))\n    return all_keys", "output": "definition sparx_128_256_get_all_round_keys :: \"16 word list \\<Rightarrow> 16 word list\" where\n\"sparx_128_256_get_all_round_keys rk_words =\n  sparx_128_256_get_round_key_iterate\n    rk_words\n    0\n    sparx_128_256_total_rounds\n    []\"", "metadata": {"component_type": "All Round Keys", "difficulty": "medium", "semantic_group": "helpers", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "modular_arithmetic", "function_definition"], "extraction_time": "2026-01-24T13:11:48.347245"}}
{"instruction": "Translate this Linear Word Function from SPARX-128/256 Python to Isabelle/HOL. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_L_w(x):\n    \"\"\"SPARX linear word function\"\"\"\n    return ((x << 8) ^ (x >> 8))", "output": "definition sparx_128_256_L_w :: \"16 word \\<Rightarrow> 16 word\" where\n  \"sparx_128_256_L_w x = xor (push_bit 8 x) (drop_bit 8 x)\"", "metadata": {"component_type": "Linear Word Function", "difficulty": "medium", "semantic_group": "helpers", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["bit_operations", "bitwise_operations", "function_definition", "linear_diffusion"], "extraction_time": "2026-01-24T13:11:48.347397"}}
{"instruction": "Translate this Whitening Index from SPARX-128/256 Python to Isabelle/HOL. Note: SPARX-128/256 uses 10 steps with 4 rounds each, using A-permutations and a linear layer.", "input": "def sparx_whitening_index(total_rounds=40, n_branches=4):\n    \"\"\"Index for whitening keys\"\"\"\n    # total_rounds = 40\n    # n_branches = 4\n    # return total_rounds * n_branches\n    return 40 * 4", "output": "definition sparx_128_256_whitening_index :: nat where\n  \"sparx_128_256_whitening_index =\n     (sparx_128_256_total_rounds - 1) * sparx_128_256_round_key_words\"", "metadata": {"component_type": "Whitening Index", "difficulty": "easy", "semantic_group": "helpers", "cipher": "SPARX", "family": "ARX", "variant": {"block_size": 128, "key_size": 256, "total_rounds": 40, "steps": 10, "rounds_per_step": 4}, "algorithm_params": {"word_size": 16, "branches": 4, "words_per_block": 8, "key_words": 16, "structure": "Feistel-like with step structure", "arx_order": "A-permutation → linear layer", "step_based": true}, "transformation_patterns": ["loop_to_recursion", "function_definition"], "extraction_time": "2026-01-24T13:11:48.347885"}}
